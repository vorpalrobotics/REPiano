<!--

TO DO:
 - [HARD, long term] Chord support in noteon/noteoff

 - Day chart improvements
    * Add notes feature for day chart

 - Smart Metronome improvements (rhythms, match bar, etc.)

 - Skills Manager improvements
  * Properly display different numbers of octaves for scales/arps. Currently only shows 2 octave data.

 - Backing Track manager (low priority since there is no native "time stretch" in web audio)
    * Low priority because using an external app works pretty well with just a few more clicks

-->

<!DOCTYPE html>
<html>
<head>
  <title>REPiano Practice Tracker</title>
  <meta charset="UTF-8">
  <style>
    .green-note {
      color: green;
    }
    .red-note {
      color: red;
    }
    th.col, td.col, td, th {
      border-left:1px solid black;
      border-right:1px solid black;
    }
    th {
      border-top:1px solid black;
      border-bottom:1px solid black;
    }
    button, select {
      font-size:14px;
      margin-right:12px;
    }

    .bigstat {
      font-size: 30px;
    }

    .smallstat {
      font-size: 18px;
    }

    body {
      margin: 2px;
      padding: 0px;
    }

    .container {
      position: relative;
      right:0;
      top:0;
    }

    .gear-button {
      position: fixed;
      top: 40px;
      right: -10px;
      border: none;
      background-color:transparent;
      cursor: pointer;
    }

    .mode-container {
      display: inline;
    }

.mode-box {
  display:inline;
  text-align: center;
  margin-right: 5px;
  padding: 2px;
  padding-left:10px;
  padding-right:10px;
  margin-right:15px;
  margin-bottom:10px;
  background-color: white;
  color: gray;
  font-weight: normal;
  cursor: pointer;
  border: 1px solid black;
  opacity: 0.7;
}

.mode-box-bars {
  display:inline;
  text-align: center;
  padding: 1px;
  margin-right:7px;
  margin-bottom:7px;
  background-color: white;
  color: gray;
  font-weight: normal;
  cursor: pointer;
  border: 1px solid black;
  opacity:0.7;
}

.mode-box-bars-selected {
  outline: 4px solid black;
  font-weight:bold;
  color: black;
}

.selected {
  background-color: rgba(216, 191, 216, 1);
  color: black;
  font-weight: bold;
}

#scaleArpWizardContainer {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: auto;
  height: auto;
  background-color: rgba(0, 0, 0, 0.5);
  justify-content: center;
  align-items: center;
}

#popup-form {
  background-color: white;
  padding: 20px;
  border-radius: 5px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

#popup-form select, #popup-form button {
  margin: 5px 0;
}

.mfs {
  font-family: 'Noto Music', 'Noto Sans Symbols 2';
  font-weight: normal;
  font-style: normal;
  font-size:small;
}

.mf {
  font-family: 'Noto Music', 'Noto Sans Symbols 2';
  font-weight: normal;
  font-style: normal;
  font-size: medium;
}

.mfl {
  font-family: 'Noto Music', 'Noto Sans Symbols 2';
  font-weight: normal;
  font-style: normal;
  font-size:  large;
}

.mfxl {
  font-family: 'Noto Music', 'Noto Sans Symbols 2';
  font-weight: normal;
  font-style: normal;
  font-size:  x-large;
}

@keyframes flashRedWhite {
  0%, 100% {outline: none; }
  50% { outline: solid 3px red; }
}

.flash-animation {
  animation: flashRedWhite 1s infinite;
}

@keyframes expandModeDiv {
  from {
    transform: scaleY(0);
  }
  to {
    transform: scaleY(1);
    height: 100vh; /* Set to desired final height */
  }
}

@keyframes contractModeDiv {
  from {
    transform: scaleY(1);
  }
  to {
    transform: scaleY(0);
    height: 100vh; /* Set to desired final height */
  }
}


input[type='range']::-webkit-slider-thumb {
    -webkit-appearance: none; /* Necessary to remove default styling */
    appearance: none;
    background-color: darkgreen; /* Sets the thumb color to dark green */
    width: 20px; /* Set the width of the thumb */
    height: 10px; /* Set the height of the thumb */
    border-radius: 50%; /* Optional: makes the thumb circular */
    cursor: pointer; /* Changes the cursor to a pointer when hovered */
}

.slider {
  background-color: darkgreen;
}

input[type='range']::-webkit-slider-runnable-track {
    background: lightgreen;
}



  </style>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Music&family=Noto+Sans+Symbols+2&display=swap" rel="stylesheet">

  <script src="https://cdn.jsdelivr.net/npm/webmidi@next/dist/iife/webmidi.iife.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script><script src="https://kit.fontawesome.com/3f379ed013.js" crossorigin="anonymous"></script>
  <script src="https://kit.fontawesome.com/3f379ed013.js" crossorigin="anonymous"></script>
</head>
<body>
  <div class="container">
    <button class="gear-button" id="gearButton" onclick="showPrefs(true)" title="Preferences and Settings">
    <i class="fa-solid fa-gear" style=font-size:x-large;></i></button>
  </div>
    <button id="fullscreenButton" onclick="fullscreen()" class=mfs
        style="position:fixed;right:-5px;top:2px;background:lightblue;z-index:1000000;padding:2px;"><i class="fa-solid fa-expand"></i> Full Screen</button>
  <div id=uitop style=user-select:none;cursor:pointer >
    <span onclick="repianoAbout()" class=mfl style=font-size:18px;display:inline-block title="REPiano: keyboard practice utility">
       &#119046;&#127929;</span><span onclick="repianoAbout()" title="REPiano: keyboard practice utility"><strong>REP<em>iano</em></strong>&nbsp;<i class="fa-solid fa-circle-info" style=color:blue;font-size:smaller></i>&nbsp;&nbsp;</span>
    <button id="skillMap" class=mfs style=padding:5px onclick="showSkillMap();"
            title="Show a grid of skills with priorities for practice today"
    ><i class="fa-solid fa-earth-americas"></i>&nbsp;Skill&nbsp;Map</button>
    <button id="dayChart" class=mfs style=padding:5px onclick="showDayChart();"
       title="Show a summary of what you've practiced today and how well you did"
       ><i class="fa-regular fa-calendar-days"></i>&nbsp;Day&nbsp;Chart</button>
       <button id="freePlayButton" class=mfs style=padding:5px onclick="showFreePlay();"
          title="Manage Free Play routines to practice without scoring."><i class="fa-solid fa-music"></i>&nbsp;Free&nbsp;Play</button>
    <button id="historyButton" class=mfs style=padding:5px;margin-left:3em onclick="showHistory();"
       title="Show a graph of progress for specific skills over time, defaults to current preset"><i class="fa-solid fa-chart-line"></i>&nbsp;History</button>
   <button id="generateNotesButton" class=mfs style=padding:5px onclick="showScaleArpWizard();"
      title:"Generate scales or arpeggios that don't already appear in the presets>
      <i class="fa-solid fa-wand-magic-sparkles"></i>&nbsp;Scales</button>
    <button id=exportButton style=padding:5px;margin-left:8em class=mfs onclick="importExportHistory();"
       title="Export or Import a backup copy of history data. The number of days since last backup is shown in parentheses."><i class="fa-solid fa-file-arrow-down"></i>&nbsp;Imp/Exp</button>
  </div>

  <div style="max-height:90vh; padding-top:10px;">
    <table id=data style="border-collapse:collapse; border: 1px solid black;width:100%">
      <tr id="statsArea" style="border-bottom:1px solid black;vertical-align:top;">
        <td style='width:15%;vertical-align:bottom;position:relative;'>
          <div style='width:100%;height:100%;text-align:center;vertical-align:bottom;'>
            <div id="elapsedTime" style="font-size:60px;text-align:center;vertical-align:middle;width:100%;user-select:none;">0:00</div>
            <div style="display:block;width:100%;vertical-align:middle;text-align:center;background-color:rgba(0,0,0,.1);">
            <div id="testNotesButton"
                title="Start or stop a test"
                style=font-size:24px;user-select:none;display:inline-block;cursor:pointer;padding-top:14px;padding-bottom:14px;border:none;vertical-align:middle;color:"";>
              START
            </div>
              <div id=timerPauseButton onclick="pauseTimer();" class=mfxl
                title="Pause test clock"
                style="color:gray;vertical-align:middle;display:none;cursor:pointer;font-size:xx-large;padding-left:12px;">
                &#9208;<!--pause symbol-->
              </div>
            </div>
          </div>

        <span id="toggleVoiceButton" class=mf onclick="togglePref('enableVoice')" title="Toggle voice reports (green = ON, red = OFF)"
          style=cursor:pointer;position:fixed;right:2px;top:60px;font-size:30px;color:green;>&#x1F5E3;</span>
        </td>
        <td colspan=4><div id="statsDiv" style="font-size:12px;user-select:none;">&nbsp;<br>&nbsp;</div></td></tr>
        <tr style="border-bottom:1px solid black"><td colspan=4>
        <div style="width:100%;max-width:100vw;overflow-x:auto;overflow-y:hidden;white-space:nowrap;user-select:none;">
          <div id=staffArea style=display:flex;flex-direction:row;align-items:center;overflow-x:hidden;overflow-y:hidden>
            <div id="noteDisplayAreaMenuDiv" style="padding:5px;display:inline-block;line-height:1">
              <div id="clearNotesToPlaySelection" class=mfxl
                style=vertical-align:top;padding-right:1px;padding-top:0px;line-height:1.5;
                >
                <span title="clear selected notes"
                onclick="clearNotesToPlaySelection();">&#x2298;</span>&nbsp;&nbsp;
                <span id=toggleFavoriteIcon title="toggle whether the current selection is a favorite preset" style=color:#999
                onclick="toggleFavoriteBarSelection();">
              &#x2764;</span>
              </div><br>
              <div id="playNotesToPlaySelection"
                style=vertical-align:top;padding-right:4px;padding-top:2px;font-size:x-large;text-align:center;display:inline-block
                title="play notes from current score"
                onclick="playNotesToPlay(curDisplayedBPMFrac);this.style.backgroundColor='red';const obj=this;setTimeout(function(){obj.style.backgroundColor='';},500);">
                <i class="fa-solid fa-play"></i>
              </div>
              <div id=targetBPMDiv onclick="displayTargetBPM(true);" title="target BPM of this score, click to change" style="border:1px solid blue;display:inline-block"></div>
            </div>
            <div id=timeSigDiv class=mfxl style=position:relative;height:100%;text-align:center;padding-bottom:5px;padding-top:5px;display:flex;flex-direction:column;line-height:0.9;padding-right:4px;padding-left:4px;margin-right:8px;margin-left:8px;font-size:x-large;font-weight:bold>
            <div id=constDurDiv onclick="cycleConstDur();" title="This score has a constant note value, click to change it" style=display:block;padding-bottom:12px;font-size:medium;></div>
            <div id=beatsPerBarDiv onclick="cycleBeatsPerBar();" title="Beats per Bar" style=display:block;>4</div>
            <div id=meterDiv onclick="cycleMeter();" title="Duration of a beat" style=display:block;>4</div>
            <div id=sw8Div onclick="cycleSw8();" title="Swung eighths" style=display:block;font-size:x-small;padding-top:8px;padding-bottom:8px></div>
          </div>
            <div style=overflow-x:auto;overflow-y:hidden;width:95%>
              <div id=noteArea class=mf style=font-size:20px;height:15px;width:100%;position:relative>
                &nbsp;
              </div>
              <div id=labelRH style=width:1.5em;display:inline-block><strong>RH:</strong></div>
              <div id="notesRH" style="display:inline-block;"></div>
              <br>
              <div id=labelLH style=width:1.5em;display:inline-block><strong>LH:</strong></div>
              <div id="notesLH" style="display:inline-block;"></div>
              <br><div id=labelRepStats style=line-height:0.8; title="Left hand REPs in blue, RH red, HT purple">
                <span style=font-size:x-small;color:blue>LH</span>
                  <span style=font-size:x-small;color:red>RH</span>
                  <span style=font-size:x-small;color:purple>HT</span>
                </div>
            </div>
          </div>
        </div></tr></td>
        <tr><td colspan=2 style="border-bottom:1px solid black;position:relative;">
          <div style="width:100%">
              <canvas id=graphCanvas style="width:100%;height:65vh;position:relative;"></canvas>
              <div id=runEvalArea style=position:absolute;bottom:10%;left:0;font-size:40px;height:60px;>&nbsp;</div>
          </div>
          <div style="position:absolute;top:15vh;right:0;border:1px solid black;padding-left:5px;border-radius:5px;margin-right:2px;user-select:none;z-index:1000000">
            <div id=playNotesButton title="Play notes from graph" style='cursor:pointer;font-size:xx-large' onclick="playGraph();">
              &#9654; <!-- Play button (right facing triangle) -->
              <br>
              <div id=playGraphNotesSpeed title="Change speed of graph playback" style='cursor:pointer;font-size:x-small;color:green;' onclick="cycleGraphPlaySpeed();">
                100%
              </div>
            </div>
            <br>
            <div onclick="magnifyScreen(1)" title="magnify graph" style=font-size:xx-large;font-weight:800;cursor:pointer;user-select:none>+</div><br>
            <div onclick="magnifyScreen(-1)" title="shrink graph" style=font-size:xx-large;font-weight:800;cursor:pointer;user-select:none>&ndash;</div>
          </div>
          <div id="keyboardCollapseDiv" style="position:absolute;top:0;left:40%;text-align:left;user-select:none;background-color:rgba(173,216,230,0.5);">
            <div id="keyboardAndPresetsDiv" style=display:inline-block>
            <canvas id="keyboardCanvas" style="width:50vw;height:4vw;position:relative;opacity:0.8;" ontap="playVoice(event);" onclick="playVoice(event)"></canvas>
            <div id=pedalSymbolDiv style=position:absolute;right:100%;top:0;font-size:xxx-large>&nbsp;</div>
            <br>
            <div id=learningScheduleDiv
                onclick="toggleLearningScheduleMenu()"
                style=display:inline;padding-right:5px>
              <i id=learningScheduleIcon class="fa fa-sliders" style=font-size:18px aria-hidden="true"></i>
            </div>
            <script>
            const learningScheduleIconName = {
              "begin": "fa-regular fa-flag",
              "refine": "fa-solid fa-sliders",
              "maintain": "fa-solid fa-sync-alt",
              "archive": "fa-solid fa-archive"
            };
            const learningScheduleDayParams = {
              "begin": [1, 2, 3],
              "refine": [4, 7, 14],
              "maintain": [30, 45, 60],
              "archive": [180, 360, 600]
            }
            </script>
            <div id="learningScheduleMenu" class=mfs
              style="display:none;position:absolute;left:25px;top:50px;z-index:400000;background-color:lightgray;border:1px solid black; padding:5px;width:auto">
              <em>Learning schedule:</em><br>
              <ul style=list-style-type:none;padding:0;margin:0;text-align:left>
                  <li onclick="updateLearningSchedule('begin')"
                    onmouseover='this.style.backgroundColor="#f0f0f0";'
                    onmouseout='this.style.backgroundColor="";'
                    style=padding:5px;cursor:pointer>
                    <i class="fa-regular fa-flag"></i> Begin
                  </li>
                  <li onclick="updateLearningSchedule('refine')"
                    onmouseover='this.style.backgroundColor="#f0f0f0";'
                    onmouseout='this.style.backgroundColor="";'
                    style=padding:5px;cursor:pointer>
                    <i class="fa-solid fa-sliders"></i> Refine
                  </li>
                  <li onclick="updateLearningSchedule('maintain')"
                    onmouseover='this.style.backgroundColor="#f0f0f0";'
                    onmouseout='this.style.backgroundColor="";'
                    style=padding:5px;cursor:pointer>
                    <i class="fa-solid fa-sync-alt"></i> Maintain
                  </li>
                  <li onclick="updateLearningSchedule('archive')"
                    onmouseover='this.style.backgroundColor="#f0f0f0";'
                    onmouseout='this.style.backgroundColor="";'
                    style=padding:5px;cursor:pointer>
                    <i class="fa-solid fa-archive"></i> Archive
                  </li>
              </ul>
          </div>
            <div id="presetMenuContainer" style="font-size:24px;display:inline;width:30%;text-align:center;opacity:0.7"></div>
            <div class="mode-container" style=padding-left:15px>
              <div class="mode-box" id="lh" onclick="changeSelectedHand('left',true)" title="play only left hand" style=user-select:none;opacity:0.7>LH</div>
              <div class="mode-box" id="rh" onclick="changeSelectedHand('right',true)" title="play only right hand" style=user-select:none;opacity:0.7>RH</div>
              <div class="mode-box" id="ht" onclick="changeSelectedHand('both',true)" title="play hands together" style=user-select:none;opacity:0.7>HT</div>
            </div>
            <br>
            <div id="scaleModContainer" style="font-size:medium;text-align:left;display:block;padding-top:10px">
              <div class="mode-box" id="oct1" onclick="changeOctave(1);" title="change to 1 octave scale/arp" style=user-select:none;>1 Oct</div>
              <div class="mode-box" id="oct2" onclick="changeOctave(2);" title="change to 2 octave scale/arp" style=user-select:none;>2 Oct</div>
              <div class="mode-box" id="oct3" onclick="changeOctave(3);" title="change to 3 octave scale/arp" style=user-select:none;>3 Oct</div>
              <div class="mode-box" id="oct4" onclick="changeOctave(4);" title="change to 4 octave scale/arp" style=user-select:none;>4 Oct</div>
            </div>

            <div id="barSelectContainer" style="width:55vw;max-width:55vw;font-size:medium;text-align:left;display:block;padding-top:10px;display:none;">
                &nbsp;
            </div>
          </div>
          <div id="keyboardCollapseExpandButton"
            style=display:inline-block;vertical-align:top;padding-right:1px;padding-top:10px;font-size:large;
            onclick="hideOrDisplayKeyboard();"><i class="fa-solid fa-minimize"></i></div>

          </div>

          </td></tr>
      <tr>
        <div id=runSummary style="">
        </div>
      </tr>
      <tr>
        <td id=consoleTD colspan=2 style="vertical-align: top;">
          <strong>Console:</strong>
          <div id="console" style="max-height:40vh;overflow-y:auto;"></div>
        </td>
      </tr>
    </table>
    <!-- Preferences Screen -->
  <div id="prefsScreen" class="prefs-screen" style="display:none;position:fixed;top:60px;right:10px;background-color:lightgrey;padding:10px;">
    <div style="max-height:70vh;overflow-y:auto;">
    <h2 style=margin-top:2px;padding-top:2px;>Preferences</h2>
    <label>
      <input id='autoFullscreenStartToggle' type="checkbox" onchange="togglePref('autoFullscreenStart')" checked />
      Auto Full Screen on START
    </label><br>
    <label>
      <input id='autoExitFullscreenStopToggle' type="checkbox" onchange="togglePref('autoExitFullscreenStop')" checked />
      Auto Exit Full Screen on STOP
    </label><br>
    <label>
      <input id='autoPauseClockToggle' type="checkbox" onchange="togglePref('autoPauseClock')" checked />
      Auto Pause Clock on 5 seconds inactivity
    </label><br>
    <label>
      <input id='qualFailRepSuccessToggle' type="checkbox" onchange="togglePref('qualFailRepSuccess')" checked />
      QFail Still Counts as a REP
    </label><br>
    <label>
      <input id='showKeyboardToggle' type="checkbox" onchange="togglePref('showKeyboard')" checked />
      Show Keyboard
    </label><br><br>
    <label>
      <input id='strictStreakToggle' type="checkbox" onchange="togglePref('strictStreak')" checked />
      Strict Streaks (restart breaks streak)
    </label><br><br>
    <label>
      <input id='enableVoiceToggle' type="checkbox" onchange="togglePref('enableVoice')" checked />
      Enable Voice Reports
    </label><br>
    <label>
      Voice Volume:
      <select id=speakingVolumeMenu onchange="setPref('speakingVolume', this.value)">
        <option value="0.1">10%</option>
        <option value="0.2">20%</option>
        <option value="0.3">30%</option>
        <option value="0.4">40%</option>
        <option value="0.5">50%</option>
        <option value="0.6">60%</option>
        <option value="0.7">70%</option>
        <option value="0.8">80%</option>
        <option value="0.9">90%</option>
        <option value="1" selected>100%</option>
      </select>
    </label>
    <br><br>
    <label>
      BPM measured in:
      <select id=bpmNoteValueMenu onchange="setPref('bpmNoteValue', this.value)">
        <option value="1">&#119133; whole </option>
        <option value="0.5">&#119134; half </option>
        <option value="0.25" selected>&#119135; quarter </option>
        <option value="0.125">&#119136; 8th </option>
        <option value="0.06125">&#119137; 16th </option>
        <option value="0.030625">&#119138; 32nd </option>
      </select> (when not fixed)
    </label><br><br>
    <label>
      Ignore outrange notes, semitones:
      <select id=noteFilterMenu onchange="setPref('noteFilter', this.value)">
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3" selected>3</option>
        <option value="-1">don't ignore</option>
      </select>
    </label>
    <hr>
    <h4 style=margin-top:3px;margin-bottom:3px;max-width:70vw;>
      Score "strikes" on these metrics:
    </h4>
    <label>
      <input id='scoreHTQToggle' type="checkbox" onchange="togglePref('scoreHTQ')" checked />
      Score HT Quality
    </label><br>
    <label>
      <input id='scoreMetQToggle' type="checkbox" onchange="togglePref('scoreMetQ')" checked />
      Score Metric Quality
    </label><br>
    <label>
      <input id='scoreDynQToggle' type="checkbox" onchange="togglePref('scoreDynQ')" checked />
      Score Dynamic Quality (loudness)
    </label><br>
    <label>
      <input id='scoreLegQToggle' type="checkbox" onchange="togglePref('scoreLegQ')" checked />
      Score Legato Quality
    </label><br>
    <label>
      <input id='scoreStaQToggle' type="checkbox" onchange="togglePref('scoreStaQ')" checked />
      Score Staccato Quality
    </label><br>
    <div style=margin-top:5px>Note: if both staccato and legato are checked,<br>then
    if either one passes there is no strike.</div>
    <hr>
    <label>
      Metronome Volume:
      <select id=metroVolumeMenu onchange="setPref('metroVolume', this.value)">
        <option value="0.0">0% (mute)</option>
        <option value="0.1">10%</option>
        <option value="0.2">20%</option>
        <option value="0.3" selected>30%</option>
        <option value="0.4">40%</option>
        <option value="0.5">50%</option>
        <option value="0.6">60%</option>
        <option value="0.7">70%</option>
        <option value="0.8">80%</option>
        <option value="0.9">90%</option>
        <option value="1">100%</option>
      </select>
    </label>
    <hr>
    <h4 style=margin-top:3px;margin-bottom:3px;max-width:70vw;>
      Play tones based on run results:
    </h4>
    <label>
      <input id='enableTonesToggle' type="checkbox" onchange="togglePref('enableTones')" checked />
      Enable result tones
    </label><br>
    <label>
      <span style=width:10em;display:inline-block>Tone on Note Fail:</span>
      <select id=toneOnNoteFailMenu onchange="setPref('toneOnNoteFail', this.value)">
        <option value="none">none</option>
        <option value="C2" selected>C2</option>
        <option value="D2">D2</option>
        <option value="E2">E2</option>
        <option value="F2">F2</option>
        <option value="G2">G2</option>
      </select>
    </label><br>
    <label>
      <span style=width:10em;display:inline-block>Tone on QFail:</span>
      <select id=toneOnQFailMenu onchange="setPref('toneOnQFail', this.value)">
        <option value="none">none</option>
        <option value="C2">C2</option>
        <option value="D2">D2</option>
        <option value="E2">E2</option>
        <option value="F2">F2</option>
        <option value="G2" selected>G2</option>
      </select>
    </label><br>
    <label>
      <span style=width:10em;display:inline-block>Tone on Passing:</span>
      <select id=toneOnPassingMenu onchange="setPref('toneOnPassing', this.value)">
        <option value="none">none</option>
        <option value="C5" selected>C5</option>
        <option value="D5">D5</option>
        <option value="E5">E5</option>
        <option value="F5">F5</option>
        <option value="G5">G5</option>
      </select>
    </label><br>
    <label>
      <span style=width:10em;display:inline-block>Tone on Good:</span>
      <select id=toneOnGoodMenu onchange="setPref('toneOnGood', this.value)">
        <option value="none">none</option>
        <option value="C5">C5</option>
        <option value="D5">D5</option>
        <option value="E5" selected>E5</option>
        <option value="F5">F5</option>
        <option value="G5">G5</option>
      </select>
    </label><br>
    <label>
      <span style=width:10em;display:inline-block>Tone on Excellent:</span>
      <select id=toneOnExcellentMenu onchange="setPref('toneOnExcellent', this.value)">
        <option value="none">whole</option>
        <option value="C5">C5+</option>
        <option value="D5">D5+</option>
        <option value="E5">E5+</option>
        <option value="F5">F5+</option>
        <option value="G5" selected>G5+</option>
      </select>
    </label><br>
    <label>
      <span style=width:10em;display:inline-block>Tone Duration:</span>
      <select id=toneDurationMenu onchange="setPref('toneDuration', this.value)">
        <option value="100">100 ms</option>
        <option value="200" selected>200 ms</option>
        <option value="300">300 ms</option>
        <option value="400">400 ms</option>
        <option value="500">500 ms</option>
      </select>
    </label><br>
    <label>
      <span style=width:10em;display:inline-block>Tone Velocity:</span>
      <select id=toneVelocityMenu onchange="setPref('toneVelocity', this.value)">
        <option value="10">10</option>
        <option value="30">30</option>
        <option value="60">60</option>
        <option value="80">80</option>
        <option value="100" selected>100</option>
        <option value="127">127 (max)</option>
      </select>
    </label><br>
  </div>
      <hr>
      <div style=text-align:center><button onclick="showPrefs(false);">DONE</button></div>
  </div>
    <div id=helpDiv style=max-width:80vw;display:none>
    <h2>Explanations:</h2>
    <h3>Top line statistics</h3>
    <dl>
      <dt>REPS</dt><dd>The number of repetitions completed. For a run to count as a valid REP there must be no note errors. A note error is a NoteFail.</dd>
      <dt>NoteFail</dt><dd>The number of runs in which you hit an incorrect note.</dd>
      <dt>QFail</dt><dd>The number of runs where there was a Quality Fail. A Quality Fail doesn't cause
        you to lose the REP. A Quality Fail occurs if you get 3 strikes on quality metrics, which are defined
        below.</dd>
      <dt>BPM</dt><dd>The beats per minute speed of your most recent run that did not have a note fail. This
        assumes each note played is a "beat". So this is really "notes per minute".</dd>
      <dt>Avg, Max, Best</dt><dd>These are the Average BPM, Maximum BPM, and Best BPM, respectively. Best BPM
        is defined as the maximum BPM among runs with no strikes, in other words your highest BPM during a high
        quality run.</dd>
      <dt>AvgHQ, AvgMQ, AvgLQ</dt><dd>These are the average BPM values during High Quality (0 strikes), Medium Quality (1 strike),
        and Low Quality (2 or more strikes) runs. As always, runs with a note failure don't count at all, as they are considered
        totally failed runs for which BPM can't really be measured.</dd>
      </dl>
    <h3>Bottom Line Statistics</h3>
    The second line of stats give quality metrics.
    <dl>
    <dt>HTQ</dt><dd>Hands Together Quality measures what percentage of time your hands struck the corresponding notes
      at the same time. Over 85% is considered high quality.</dd>
    <dt>MetQ</dt><dd>Metric Quality measures how similar the lengths of time of each note is. If every note was played exacty the same amount of time this measure would be 100%.
      If the standard deviation of note durations is bigger than the mean note duration this measure would be 0 percent.
      You can ignore this stat if you are purposefully playing some notes longer than others, for example you are
      playing your scales to a rhythm. The mean and standard deviation are displayed under this stat in a small font in the format: mean&plusmn;sd.</dd>
    <dt>DynQ</dt><dd>Dynamic Quality measures whether each note was played with the same loudness (velocity in midi terms).
      If every note is equally loud this will be 100%. If the standard deviation of loudness is greater than the mean loudness this will be
      zero percent. The mean and standard deviation are displayed under this stat in a small font in the format: mean&plusmn;sd. You can ignore this stat
      if you are purposefully putting a louder beat on certain notes, or if you are purposefully playing one hand loud and the other soft.</dd>
    <dt>LegQ</dt><dd>Legato quality measures how well you are playing Legato (smoothly without breaks). Note that strikes are not assigned to low legato scores since we don't know if you're attempting to play legato or not. If each note (in each hand) starts exactly when the
      last note finishes every single time, this measure will be 100%. A very small overlap is not penalized because some teachers instruct that legato has
      a small overlap. A gap or a larger overlap is penalized. Underneath this stat there is a display of the amount of average gap in milliseconds (when there was a gap), and the amount of average overlap (when there was an overlap).
      If you are purposely playing one hand legato and one hand staccatto you can just bear in mind that this figure would only be 50% at most (i.e. half the notes are perfect legato).</dd>
    <dt>StaQ</dt><dd>Staccato Quality, like Legato Quality, measures how closely you are playing Staccato. It also doesn't cause strikes for the same reason as
      Legato Quality doesn't. A perfect score of 100% would occur if every note has a gap afterwards of at least the duration of the note. We do not attempt to distinguish different kinds of staccatto.</dd>
    </dl>
    <p>Strikes occur on a run with no note failures when one or more quality metrics (not counting LegQ or StaQ) are below certain values.
       Generally, scores of 85 or higher get zero strikes. Scores between 70 and 84 inclusive get 1 strike. Scores between 50 and 69 inclusive get 2 strikes, and scores under 50 get 3 strikes.
       Strikes are added up between the HTQ, MetQ, and DynQ stats. Zero total strikes is considered a "high quality run", one total strike is a "medium quality run" and anything more than 1 strike
       is considered a "quality fail".
    <h3>The Graph</h3>
    <p>The graph only displays data on runs without note fails.</p>
    <p>The graph shows proportional note start/end times as a bar graph, blue for left hand notes and red for right hand.</p>
    <p>The loudness (midi velocity) on a scale of 0 to 100 is displayed in white letters right on the note bars. Also, standard piano abbreviations such as "pp" for pianissimo or "mf" for mezzo forte are printed. However, depending on your exact midi keyboard parameters these may not be accurate, so just consider them approximations.
      Each bar's internal color is also faded the more softly it was played.</p>
    <p>For scales/arpeggios that have fingering data, the finger that was supposed to play the note is displayed underneath the bars.
      The left hand finger is blue and the right hand finger is red.</p>
    <p>On any run with 2 or more quality strikes, the words "Slow Down!" are printed on the graph in a large font.</p>
    <p>A legend in the upper right corner shows the proportional horizontal time scale for 100 milliseconds (1/10 of second). This can give you a feeling for how large gaps/overlaps are between
      played notes, how consistent note durations are, etc.</p>
    <p>Using the graph, you might be able to pick out fingering problems, for example some fingers might be
      holding too long or releasing too quickly in a consistent way. By concentrating on making those fingers
      consistent your quality should increase.</p>
    </div>

  </div>

  <div id="scaleArpWizardContainer">
  <div id="popup-form">
    <h2>Scale/Arpeggio Wizard</h2>
    <label for="test-type">Type:</label>
    <select id="test-type">
      <option value="Scale">Scale</option>
      <option value="Arpeggio">Arpeggio</option>
    </select><br>

    <label for="tonic">Tonic:</label>
    <select id="tonic">
      <option value="C">C</option>
      <option value="C#">C#</option>
      <option value="D">D</option>
      <option value="D#">D# / Eb</option>
      <option value="E">E</option>
      <option value="F">F</option>
      <option value="F#">F# / Gb</option>
      <option value="G">G</option>
      <option value="G#">G# / Ab</option>
      <option value="A">A</option>
      <option value="A#">A# / Bb</option>
      <option value="B">B</option>
    </select><br>

    <label for="mode">Mode:</label>
    <select id="mode">
      <option value="maj">Major</option>
      <option value="natMin">Minor</option>
      <option value="harMin">Harmonic Minor</option>
      <option value="melMin">Melodic Minor (Classical)</option>
      <option value="melMinJ">Melodic Minor (Jazz)</option>
      <option value="majBlues">Major Blues</option>
      <option value="minBlues">Minor Blues</option>
      <option value="mixoBlues">Mixo-Blues</option>
      <option value="majPent">Major Pentatonic</option>
      <option value="minPent">Minor Pentatonic</option>
      <option value="dor">Dorian Mode</option>
      <option value="phryg">Phrygian Mode</option>
      <option value="lyd">Lydian Mode</option>
      <option value="mixo">Mixolydian Mode</option>
      <option value="aeo">Aeolian Mode</option>
      <option value="loc">Locrian Mode</option>
      <option value="chroma">Chromatic</option>
    </select><br>

    <label for="octaves">Octaves:</label>
    <select id="octaves">
      <option value="1">1</option>
      <option value="2">2</option>
      <option value="3">3</option>
      <option value="4">4</option>
    </select><br>

    <label for="lh-start-octave">LH Start Octave:</label>
    <select id="lh-start-octave">
      <option value="1">1</option>
      <option value="2">2</option>
      <option value="3" selected>3</option>
      <option value="4">4</option>
    </select><br>

    <button onclick="generateTest()">GENERATE</button>
    <button onclick="dismissScaleArpWizard()">CANCEL</button>
  </div>
</div> <!-- end of scale/arp wizard container -->

<div id="historyTableContainer"
  style="display:none;border:1px solid black;background-color:#EEE;width:100vw;height:auto;position:fixed;top:0;left:0;z-index:2000000;scrollY:auto">
  <div style=width:100%;text-align:right;position:fixed;top:0;right:15px><button id="doneButton" onclick="animateClose('historyTableContainer');"><span class=mf><i class="fa-regular fa-rectangle-xmark"></i></span>
    &nbsp;Dismiss</button>
  </div>
  <div style=padding-left:10px;>
  <h2 style=margin:0;padding:0;padding-bottom:5px>History <span onclick='showHistoryHelp()' style=font-size:smaller;color:blue><i class="fa-solid fa-circle-info"></i></span></h2>
<div style=text-align:right;padding:5px;>
  <div id="filtersContainer" style=padding-bottom:10px;text-align:left>
    <button id="toggleGraphRawData" onclick="toggleGraphRawData();">Show Raw Data</button>
    <label for="dateRangeSelect">Date Range:</label>
    <select id="dateRangeSelect">
        <option value="all">ALL</option>
        <option value="1Month">1 Month</option>
        <option value="3Months">3 Months</option>
        <option value="1Year">1 Year</option>
    </select>

    <label for="testNameHistorySelect">Routine Name:</label>
    <select id="testNameHistorySelect">
        <!-- Options for test names will be populated dynamically using JavaScript -->
    </select>

    <label for="handSelect">Hand:</label>
    <select id="handSelect">
        <option value="any">ANY</option>
        <option value="left">Left</option>
        <option value="right">Right</option>
        <option value="both">Both</option>
    </select>
    <button onclick="filterAndDisplayHistory();">FILTER</button>
</div>
    <div id="historyGraphDiv" style=text-align:left>
      <canvas id="historyGraph" style="width:98%;height:50vh;"></canvas><br>
      <canvas id="historyGraphErr" style="width:98%;height:30vh;"></canvas>
    </div>
    <div id=historyRawDataDiv style=height:80vh;overflow:auto;font-size:12px;text-align:center;display:none>
    <table id="historyTable" border="1" style=height:25vh;overflow:auto;border-collapse:separate;>
        <thead id=sticky-thead style=position:sticky;top:0;background-color:rgb(220,220,220);border:2;z-index:10000>

            <tr style=background-color:rgb(240,240,240);border:2>
                <th rowspan=2>Date</th>
                <th rowspan=2>Name</th>
                <th rowspan=2>Hand</th>
                <th rowspan=2>REPS</th>
                <th rowspan=2>NFail</th>
                <th rowspan=2>Elapsed</th>
                <th rowspan=2>Avg.<br>Strikes</th>
                <th rowspan=2>NNAcc</th>
                <th rowspan=2>ErrMap</th>
                <th rowspan=2>Streak</th>
                <th colspan=8  style=background-color:rgb(240,240,240)>BPM</th>
              </tr>
              <tr style=background-color:rgb(240,240,240);border:'2px solid black'>
                <th style=background-color:rgb(240,240,240) style=background-color:rgb(240,240,240) style=background-color:rgb(240,240,240)>Avg</th>
                <th style=background-color:rgb(240,240,240) style=background-color:rgb(240,240,240)>Max</th>
                <th style=background-color:rgb(240,240,240)>Bst</th>
                <th>HQ</th>
                <th>MQ</th>
                <th>LQ</th>
                <th>FQ</th>
            </tr>
        </thead>
        <tbody id="historyTableBody">
            <!-- Run data will be inserted here -->
        </tbody>
    </table>
  </div>
</div>

</div>
</div> <!-- end of history container-->

<!-- History Import/Export screen -->
<div id="importExportContainer" style="z-index:3000000;padding:10px;background-color:#DED;font-size:small;border:1px black solid;display:none;position:fixed;top:0;left:0;overflow-y:auto;text-align:left">
    <div style=width:100%;text-align:right><button id="doneButton" onclick="animateClose('importExportContainer');"><span class=mf><i class="fa-regular fa-rectangle-xmark"></i></span>&nbsp;Dismiss</button></div>
    <h2>Quick Import/Export:</h2>
    <table style=border-collapse=collapse>
      <tr style=border:none>
        <td style=border:none style=border:none style=border:none style=border:none style=border:none style=border:none><strong><i class="fa-solid fa-file-arrow-down"></i> EXPORT HISTORY:</strong></td>
        <td style=border:none style=border:none style=border:none style=border:none style=border:none>
          <button id="exportBackup" onclick="exportBackupFile();">EXPORT</button></td>
        <td style=border:none>Your data is important, export a backup file after every session!</td>
      </tr>
      <tr style=border:none style=border:none><td style=border:none>&nbsp;</td>
      <tr style=border:none style=border:none style=border:none style=border:none>
        <td style=border:none style=border:none style=border:none><strong><i class="fa-solid fa-file-arrow-up"></i> IMPORT HISTORY:</strong></td>
        <td style=border:none style=border:none><input id="importBackup" type=file name="files[]"></td>
        <td style=border:none>Note: importing data <em>permanently</em> wipes out all current history, always export a backup file first.</td>
      </tr>
    </table>

    <br>

    <hr>
    <button id=AdvancedButton onclick="toggleAdvancedImportExport()">Show Advanced</button>
    <div id="advancedImportExportDiv" style=display:none>
      <h2>Advanced Import/Export:</h2>
      <p style=text-align:left;font-size:small>Another backup option is copy/paste, for example into an email or google docs file. The text below is a JSON encoding of your practice history. You can back it up by copying this text to a file, email, sms, etc.
        To restore a prior backup, erase the data below, paste in the backup data, then click RESTORE.
      <br><br>
        JSON TEXT:
      </p>
      <textarea id="importExportTextarea" placeholder="Paste JSON here or copy JSON to export" rows=10 style=scrollY:auto;width:100%;font-size:x-small></textarea>

      <div id="importExportSizeDiv" style=text-align:left;font-weight:bold;display:inline-block></div>
      <button id="copyToClipboardButton" onclick="document.getElementById('importExportTextarea').select();document.execCommand('copy');">Copy JSON To Clipboard</button>
      <button id="restoreButton">Restore From JSON Text</button>
      <button id="eraseButton" onclick="document.getElementById('importExportTextarea').value='';">Erase JSON Text</button>
      <br><br>
      NOTES:<br>
      (1) Restoring from JSON text will erase all prior data permanently, so do a backup first.<br>
      (2) Practice data is stored between sessions in browser local storage. Clearing your browser history or cache will wipe it out, so make backups of your data often.<br>
    </div>
</div> <!-- end of history import/export screen -->

<div id="skillMapContainer" style='display:none;z-index:3000000;position:fixed;top:0;left:0;padding-left:8px;width:100vw;min-height:100vh;background-color:lightgray;transform-origin:top;transition:0.5s ease-in-out'>
  <button onclick="animateClose('skillMapContainer');"
    style=position:fixed;top:0;right:15px><span class=mf><i class="fa-regular fa-rectangle-xmark"></i></span>
  &nbsp;Dismiss</button>
<h2 style=margin:0;padding:0;padding-bottom:5px;display:inline-block>Skill Map: Practice Guide
  <span onclick='showHelp("skillMapHelp")' class=mfl style=font-size:smaller;color:blue;cursor:pointer><i class="fa-solid fa-circle-info"></i></span></h2>
<button class=mfs style=display:inline-block;margin-left:20px onclick="animateClose('skillMapContainer');setTimeout(showDayChart,500);"><i class="fa-regular fa-calendar-days"></i>&nbsp;Day&nbsp;Chart</button>
<button id="freePlayButton" class=mfs style=padding:1px;padding-left:5px onclick="animateClose('skillMapContainer');setTimeout(showFreePlay,500);"
   title="Manage Free Play routines to practice without scoring."><i class="fa-solid fa-music"></i>&nbsp;Free&nbsp;Play</button>
  <div style=overflow-y:scroll;height:90vh>
  <table id=skillMapTable border="1" style=height:25vh;border-collapse:separate;>
  </table>
  </div>
</div>  <!-- end of skill map container -->

<div id="skillMapHelp" style='display:none;z-index:3000000;position:fixed;top:0;left:0;padding-left:8px;width:100vw;min-height:100vh;background-color:lightgray;transform-origin:top;transition:0.5s ease-in-out;'>
    <button onclick="animateClose('skillMapHelp');"
      style=position:fixed;top:0;right:15px><span class=mf><i class="fa-regular fa-rectangle-xmark"></i></span>
    &nbsp;Dismiss</button>
  <div style=margin:5px;margin-right:20px;padding:5px;padding-right:20px;overflow-y:scroll;max-height:95vh>
  <h2>Skill Map Help</h2>
  <p>Skill Map helps you find items to practice. It shows routines you have practiced, organized
    by the type of routine (Scale, Drill, Repertoire, etc.) as color coded blocks.</p>
    <h3>Block Color Codes</h3>
    <p>The background color of the blocks
    indicates how well you did the last time you practiced (this takes into account both streak and accuracy data). Dark green and green
    had high accuracy and long streaks, blue for items means "good but could be better". Orange items were defficient and red indicates
    a failing level of accuracy/streaks.</p>
    <div style=width:7vw;background-color:blue;color:white;text-align:center></div>
    <p>The number of
    days ago that you last practiced (0 = today, 1 = yesterday, etc) is also shown, and is highlighted with a background color that
    makes it easy to see routines that you've not tried in a while. Again, green is good (recent), blue is ok, orange is not so good, and red means you've not
    practiced in quite some time.</p>
    <p>The amount of time indicated by color changes depends on the Learning Schedule of the routine. For BEGIN schedules, a single day causes a color change, since things you're just starting
      to learn should be practiced just about every day. For REFINE schedules, the color is green for days 0 to 3, then blue up to 7, then yellow up to 14 days, then red. For MAINTAIN schedules,
      green is up to 30 days, then blue up to 45, yellow to 60, red over 60. For ARCHIVE, green stays for 6 months, blue up to 9 months, yellow up to 1 year, red over 1 year.
    <h3>Scales and Arpeggios</h3>
    <p>The number of octaves you've practiced is shown in a circled number. If that circled number is yellow then the practice was not hands together (HT).
    <h3>Repertoire Routines</h3>
    <p>For Repertoire routines, the bar numbers of sections you have practiced are broken out in the table, for example B3-7 means that block is for bars 3 through 7, inclusive.</p>
    <h3>Using the Skill Map to Prioritize Practice</h3>
    <p>By prioritizing items that are orange or red (either in accuracy or age), you'll be devoting the most practice time to the items you're having
      more trouble with, or that you have not practiced in a while. If you get through all those and still have time, try some blue items next.</p>
    <p>You can click on a box to immediately set the main screen to that item and start practicing.</p>
</div>
</div>

<div id="freePlayContainer" style=display:none;z-index:3000000;position:fixed;top:0;left:0;width:100vw;min-height:100vh;background-color:#FFF9E3>
  <button onclick="animateClose('freePlayContainer');"
    style=position:fixed;top:0;right:15px><span class=mf><i class="fa-regular fa-rectangle-xmark"></i></span>
  &nbsp;Dismiss</button>
  <div style=padding-left:10px;>
  <h2 style=margin:0;padding:0;padding-bottom:5px;display:inline-block><i class="fa-solid fa-music"></i> Free Play: Non-scored Practice Tracking <span onclick='showHelp("freePlayHelp")' style=font-size:smaller;color:blue;font-weight:normal><i class="fa-solid fa-circle-info"></i></span></h2>
<button class=mfs style=display:inline-block;margin-left:20px onclick="animateClose('freePlayContainer');setTimeout(showSkillMap,500);"><i class="fa-solid fa-earth-americas"></i>&nbsp;Skill&nbsp;Map</button>
<button class=mfs style=display:inline-block;margin-left:20px onclick="animateClose('freePlayContainer');setTimeout(showDayChart,500);"><i class="fa-regular fa-calendar-days"></i>&nbsp;Day&nbsp;Chart</button>
<br>
  <button id=showFreePlayHiddenButton onclick="showFreePlayHiddenItems()" style=margin-top:5px;margin-bottom:5px>Show Hidden Items</button>
  <div style=overflow-y:scroll;max-height:80vh>

  <table border="1" style=border-collapse:separate;>
    <thead>
    <tr style="font-weight:bold">
      <td></td>
      <td></td>
      <td></td>
      <td>Short Name</td>
      <td>Description</td>
      <td>Category</td>
   </tr>
    </thead>
    <tbody id=freePlayTbody>
    </tbody>
  </table>
  </div>
  </div>
</div>  <!-- end of Free Play container -->

<div id="freePlayHelp" style='display:none;z-index:3000000;position:fixed;top:0;left:0;padding-left:8px;width:100vw;min-height:100vh;background-color:lightgray;transform-origin:top;transition:0.5s ease-in-out'>
<button onclick="animateClose('freePlayHelp');"
  style=position:fixed;top:0;right:15px><span class=mf><i class="fa-regular fa-rectangle-xmark"></i></span>
&nbsp;Dismiss</button>
<h2>Free Play: Help</h2>
<p>
  The Free Play feature allows you to track practice items that are not tested using REPiano.
  Examples: (1) improvisation, (2) practicing an entire song using a backing track,
  or (3) practicing all major scales in chromatic order, or randomly changing the number of octaves as you practice.</p>
<p>These items are important to practice,
  but would not be practical using the REPiano scoring system--which is best for short sequences of up to a few bars.</p>
  <p>By defining "Free Play" items then choosing them from the menu, you can use REPiano to time how
  long you practiced and save this data to the Day Chart for inclusion in your practice time totals.</p>
  <p>You can also log time for activities that happen away from the keyboard, such as reading music, aural training, etc.</p>
  <p>NOTE: Free Play items that are hidden are never really deleted since there may be references to them in the practice
    history. They won't show up in the Presets menu, however. You can bring them back by unhiding them.</p>
</div>

<div id="dayChartContainer" style=display:none;z-index:3000000;position:fixed;top:0;left:0;width:100%;height:100vh;background-color:#FFF9E3>
  <button onclick="animateClose('dayChartContainer');"
    style=position:fixed;top:0;right:15px><span class=mf><i class="fa-regular fa-rectangle-xmark"></i></span>
  &nbsp;Dismiss</button>
  <div style=padding-left:10px;>
  <h2 style=display:inline-block;margin:0;padding:0;padding-bottom:5px><i class="fa-regular fa-calendar-days"></i> Day Chart: Practice Summary
    <span class=mf onclick='showHelp("dayChartHelp")' title="Show Day Chart help page" style=cursor:pointer;font-size:smaller;color:blue><i class="fa-solid fa-circle-info"></i></span>
  </h2>
    <button class=mfs style=display:inline-block;margin-left:20px onclick="animateClose('dayChartContainer');setTimeout(showSkillMap,500);"><i class="fa-solid fa-earth-americas"></i>&nbsp;Skill&nbsp;Map</button>
    <button id="freePlayButton" class=mfs style=padding:1px;padding-left:5px onclick="animateClose('dayChartContainer');setTimeout(showFreePlay,500);"
       title="Manage Free Play routines to practice without scoring."><i class="fa-solid fa-music"></i>&nbsp;Free&nbsp;Play</button>
    <br>
  <label for:dayChartDatePicker style=font-weight:bold>Date: </label>
  <button id=dayChartPriorDay onclick="dayChartDate(-1)" style=margin-right:5px;border:none;background:transparent><i class="fa-solid fa-caret-left" style=font-size:large></i></button>
  <input type="date" id="dayChartDatePicker" name="date"
          onchange="computeDayChart()" style=background-color:transparent;margin-bottom:10px>
  <button id=dayChartNextDay onclick="dayChartDate(+1)" style=margin-right:0;margin-left:5px;border:none;background:transparent><i class="fa-solid fa-caret-right" style=font-size:large></i></button>
  <div id=dayChartNoteDisplay style=display:inline-block></div>
  <br>
  <div style=overflow-y:scroll;max-height:80vh>
    <style>
  .float-right {
    float: right;
    margin-left: 20px; /* Add some space between the tables */
    margin-right:15px;
  }
</style>

<div style=float:right>
<table id=dayChartOverviewTable class=float-right; border="1">

</table>
<br>
<div style=width:15vw;>
<canvas id=dayChartPieCanvas width=100px height=100px></canvas>
</div>
<div id=dayChartTimeSummaryDiv style=width:20vw;padding-top:20px></div>
</div>

  <table border="1" style=border-collapse:separate;>
    <thead>
      <tr style="font-weight:bold">
     <td rowspan="2" style=background-color:beige>Practice&nbsp;Routine</td>
     <td rowspan="2" style=font-size:small;background-color:beige><i class="fa-regular fa-hand" style=transform:scaleX(-1)></i><i class="fa-regular fa-hand"></i></td>
     <td rowspan="2" style=font-size:small;background-color:beige><i class="fa-solid fa-stopwatch"></i> Time</td>
     <td rowspan="2" style=font-size:small;background-color:beige><i class="fa-solid fa-percent"></i> Acc</td>
     <td rowspan="2" style=font-size:small;background-color:beige><i class="fa-solid fa-arrow-up-wide-short"></i> Strk@BPM</td> <!-- Assuming Streak@BPM is a single header, if not, adjust as needed -->
     <td rowspan="2" style=font-size:small;background-color:beige>&#119046;REPS</td>
     <td rowspan="2" style=font-size:small;background-color:beige><i class="fa-solid fa-triangle-exclamation"></i>Fails</td>
     <td colspan="4" style=text-align:center;background-color:beige><i class="fa-solid fa-gauge-high"></i> BPM</td> <!-- This cell spans over the next four columns -->
   </tr>
   <!-- Second row for specific BPM metrics -->
   <tr style="font-weight:bold;text-align:center">
     <!-- No need for empty cells due to the use of rowspan in the first row -->
     <td style=font-size:x-small;background-color:beige>Avg</td>
     <td style=font-size:x-small;background-color:beige;background-color:beige>Max</td>
     <td style=font-size:x-small;background-color:beige>Best</td>
     <td style=font-size:x-small;background-color:beige>Target</td>
   </tr>
    </thead>
    <tbody id=dayChartTbody>
    </tbody>
  </table>
  <br>
  <div>
  <form onsubmit="updateDayChartNote(event)">
      <label for="dayChartNote" style=font-weight:bold>Notes:</label><br>
      <textarea id="dayChartNoteTextArea" name="dayChartNote" maxlength="250" rows="2" cols="75" required placeholder="Enter any desired notes about this date's practice here."></textarea><br>
      <input type="submit" value="Submit">
  </form>
  </div>
  </div>

  </div>
</div>  <!-- end of day chart container -->

<div id="dayChartHelp" style='display:none;z-index:3000000;position:fixed;top:0;left:0;padding-left:8px;width:100vw;min-height:100vh;background-color:lightgray;transform-origin:top;transition:0.5s ease-in-out'>
  <button onclick="animateClose('dayChartHelp');"
    style=position:fixed;top:0;right:15px><span class=mf><i class="fa-regular fa-rectangle-xmark"></i></span>
  &nbsp;Dismiss</button>
<div style=margin:5px;margin-right:20px;padding:5px;padding-right:20px>
<h2>Day Chart: Help</h2>
<p>Note: Total time is the time actually spent striking keys during a test run and only includes minimal rest time (3 beats) between repetitions. So, it
will generally be shorter than your clock time at the keyboard practicing, depending on how much you pause between repetitions.</p>
<p>Color codes:</p>
<div>For accuracy:
  <ul>
    <li><span style=background-color:green;width:2em;display:inline-block>&nbsp;</span> &gt;90%</li>
    <li><span style=background-color:blue;width:2em;display:inline-block>&nbsp;</span> 85-90%</li>
    <li><span style=background-color:orange;width:2em;display:inline-block>&nbsp;</span> 80-84%+</li>
    <li><span style=background-color:red;width:2em;display:inline-block>&nbsp;</span> &lt;80%</li>
  </ul><br>
  For Streaks:
  <ul>
    <li><span style=background-color:green;width:2em;display:inline-block>&nbsp;</span> 10+</li>
    <li><span style=background-color:blue;width:2em;display:inline-block>&nbsp;</span> 9</li>
    <li><span style=background-color:orange;width:2em;display:inline-block>&nbsp;</span> 7 or 8</li>
    <li><span style=background-color:red;width:2em;display:inline-block>&nbsp;</span> &lt7</li>
  </ul><br>
   To get dark green and a star, you need both 100% accuracy and a streak of 10+.
</div>
</div>
</div>

<!-- Error Map -->
<div id="errorMapContainer" style="display:none;border:1px solid black;background-color:#EEE;width:100vw;height:100vh;position:fixed;top:0;left:0;z-index:10000;">
<div style=text-align:right;padding:5px;>
  <button onclick="document.getElementById('errorMapContainer').style.display='none';" class=mf style="margin-bottom:10px;border:2px solid black"><span class=mf><i class="fa-regular fa-rectangle-xmark"></i></span>&nbsp;Dismiss</button><div>
  <div id="errorMapFiltersContainer" style=padding-bottom:10px;text-align:left>
    <label for="dateRangeSelect">Date Range:</label>
    <select id="dateRangeSelect">
        <option value="all">ALL</option>
        <option value="1Month">1 Month</option>
        <option value="3Months">3 Months</option>
        <option value="6Months">6 Months</option>
        <option value="1Year">1 Year</option>
    </select>

    <label for="testNameSelectErrorMap">Test Name:</label>
    <select id="testNameSelectErrorMap">
        <!-- Options for test names will be populated dynamically using JavaScript -->
    </select>

    <label for="handSelectErrorMap">Hand:</label>
    <select id="handSelectErrorMap">
        <option value="any">ANY</option>
        <option value="left">Left</option>
        <option value="right">Right</option>
        <option value="both">Both</option>
    </select>
    <button onclick="filterAndDisplayErrorMap();">FILTER</button>
</div>
  <div id="errorMap" style=height:35vh;overflow:auto;font-size:12px;text-align:left;>
    <div style=overflow-x:auto>
      <div id=errorDisplayArea style=font-size:40px;height:50px;width:100%;>&nbsp;</div>
      <div style=width:2em;display:inline-block><strong>RH:</strong></div>
      <div id="errorNotesRH" style="display:inline-block;"></div>
      <br>
      <div style=width:2em;display:inline-block><strong>LH:</strong></div>
      <div id="errorNotesLH" style="display:inline-block;"></div><br>
    </div>
  </div>
</div>
</div>
</div>

  <script>

    "use strict";

    // global variables. Yeah there are way too many and some day I would restructure
    // so that, for example, statistics about the current run are held in an object.

    // States
    const STATE = {
      SETTING_NOTES: 'SETTING_NOTES',
      TESTING_NOTES: 'TESTING_NOTES',
      WAITING_FOR_BUTTON: 'WAITING_FOR_BUTTON',
      TEST_FLUSHING: 'TEST_FLUSHING'
    };

    let currentState = STATE.WAITING_FOR_BUTTON;

    // routine categories

    const presetCats = [
      {name: 'scaleArp', description: 'Scale/Arpeggio'},
      {name: 'drill', description: 'Other Drill'},
      {name: 'repertoire', description: 'Repertoire'},
      {name: 'misc', description: 'Miscellaneous'},
    ];

    // Musical symbol codepoints

    const M = {
      "whole":    String.fromCodePoint(119133),
      "half":     String.fromCodePoint(119134),
      "quarter":  String.fromCodePoint(119135),
      "8th":      String.fromCodePoint(119136),
      "16th":     String.fromCodePoint(119137),
      "32nd":     String.fromCodePoint(119138),
      "barline":  String.fromCodePoint(119140),
      "multirest": String.fromCodePoint(119098),
      "wholerest": String.fromCodePoint(119099),
      "halfrest": String.fromCodePoint(119100),
      "quarterrest": String.fromCodePoint(119101),
      "8threst":  String.fromCodePoint(119102),
      "16threst": String.fromCodePoint(119103),
      "32ndrest": String.fromCodePoint(119104),
      "dot":      ".",                           // noto music is missing this: " "+String.fromCodePoint(119149),
                                                 // so for now just use period
      "pedal":    String.fromCodePoint(119214),
      "pedalup":  String.fromCodePoint(119215),
      "forte":    String.fromCodePoint(119185),
      "piano":    String.fromCodePoint(119183),
      "mezzo":    String.fromCodePoint(119184),
      "keyboard": String.fromCodePoint(127929),
      "finalbar": String.fromCodePoint(0x1D102)
    };

    const RESTNOTE = -1;  // numerical value for a "rest" or lack of a note

    let currentBPMNote = M["quarter"]; // what note time is BPM measured in, this is usually associated with the routine being tested

    // Variables for note tracking
    let notesToPlay = [[], []];
    let fingersToPlay = null;
    let playedNotes = [[], []];  // lh, rh
    let errorNotes = [[],[]];    // number of errors made at each note position
    let noteStartBeat = [[],[]]; // what beat number does the note start on
    let durationsToPlay = null;
    let holdsToPlay = null;
    let beatsToPlay = [0,0]; // lh, rh number of beats in selected preset.
    let noteScope = null;    // which notes within selected bars are to be tested
    let activeBars = {first:1, last:1000};
    let midiNotes = []; // for replay feature
    let waitNotes = null;  // played notes transfer here while awaiting the final notes to stop playing
    let nnAccuracy = {success:0, fail:0};
    let goodNotes = 0;  // number of good notes just in current run
    let currentErrorNote = null; // tracks hand and index of current error note for logging
    let maxBar;  // the highest bar number of the active preset.
    let barAnnotations = null;  // notes to display with a bar
    let testOptions = {};
    let barReps = null;
    let BPMRecommendedRange = [0,100000];
    let PriorStreak = [0,0,0,0];
    let practiceStrategy = "";
    let draggingWarning = 0;
    let rushingWarning = 0;

    let repCount = 0;
    let successCount = 0;
    let failCount = 0;
    let noteFailCount = 0;
    let softFailCount = 0;
    let startTime = null;
    let testStartTime = null;
    let testPauseTime = 0;
    let timerPaused = false;
    let lastNoteTime = 0;
    let totalDuration = 0;
    let currentHand = 'right';
    let wrongNotePlayed = false;
    let wrongNoteNumber = -1;
    let averageBPM = 0;
    let maxBPM = 0; // highest bpm not worrying about quality (but notes have to all be correct)
    let bestBPM = 0;  // best bpm among high quality runs
    let sumQBPM = [0,0,0,0];
    let numQBPM = [0,0,0,0];
    let noteFilterHigh = -1;
    let noteFilterLow = 1000;
    let flushRight = false;
    let midiOutput = null;
    let priorFailed = false;

    let curStreak = [0,0,0,0]; // indexed by high quality:0, at least medium: 1, at least low: 2
    let curStreakBPM = [0,0,0,0];
    let maxStreak = [0,0,0,0];
    let maxStreakBPM = [0,0,0,0];

    let canvasLarge = null;    // buffer used for full resolution graph
    const DEFAULTGRAPHMAG = 0.32;
    const MAXGRAPHMAG = 3;
    let graphMag = DEFAULTGRAPHMAG;
    let graphOffset = {x:0, y:0};

    let freePlayDragIndex = -1;
    let showFreePlayHidden = false;

    let runHistory = null;
    let freePlayPresetIndex = -1;
    let freePlay = [
      {
        name: "Scales3",
        description: "Scales, 3 octaves in chromatic order",
        category: "scaleArp",
        deleted: false,
        isFreePlay: true
      },
      {
        name: "Scales4",
        description: "Scales, 4 octaves in chromatic order",
        category: "scaleArp",
        deleted: false,
        isFreePlay:true
      },
      {
        name: "Arps, various",
        description: "Arpeggios switching from 1 to 3 octaves and tonic",
        category: "scaleArp",
        deleted: false,
        isFreePlay:true
      }
    ];

    let curPresetName = "";
    let curPresetIndex = -1;
    let keyboardStatus = 'disconnected';
    const meterChoices = ["2", "4", "8", "16", "32"];
    const sw8Choices = ["sw8", ""];
    let meter = "4";

    // metronome variables
    let metroBPM = 120;
    let nextTickTime = 0; // When the next tick is scheduled to play
    let tickInterval = 0; // The interval between ticks, based on BPM
    let metronomeRunning = false; // Whether the metronome is currently running
    let metroSmart = false;  // if true, use smart metronome that auto-adjusts based on quality of runs
    let metroSmartExtra = 0;  // this holds how many "extra BPM" are added based on quality
    let metroExpanded = false;

    // skill map variables
    const skillMapSectionCollapsed = {
      scales: false,
      arps: false,
      drills: false,
      freeplay: false,
      repertoire: false
    };

    // Array of presets
    let presets = [];

    let dayChartPie = null;

    let keyboardOptions = {
      canvasId: 'keyboardCanvas',
      numOctaves: 5,
      startingOctave: 2,
      notesOn: []
    };

// Global object to store preferences

const preferences = {
  autoFullscreenStart: true,
  autoExitFullscreenStop: true,
  autoPauseClock: true,
  enableVoice: true,

  enableTones: true,
  toneOnNoteFail: "C2",
  toneOnQFail: "G2",
  toneOnPassing: "C5",
  toneOnGood: "E5",
  toneOnExcellent: "G5", // also this gets doubled
  toneDuration: "200",  // milliseconds
  toneVelocity: "100", // pretty loud
  toneFailVoice: "11", // vibraphone on most GM128 keyboards
  toneSuccessVoice: "52", // choir on most GM128 keyboards
  noteFilter: 3,
  scoreHTQ: true,
  scoreMetQ: true,
  scoreDynQ: true,
  scoreLegQ: true,
  scoreStaQ: true,
  showKeyboard: true,
  bpmNoteValue: "0.025",
  metroVolume: 0.7,
  speakingVolume: 1.0,

  speakingRate: 1.2,  // slightly fast

  barPresetAll: true,

  metroSmartExtraMax: 20,  // the maximum amount of BPM we will add when using smart metronome
  metroSmartInc: 2,        // how much do we increment smart metronome by
  metroSmartIncStrikes: 1, // the maximum number of strikes before incrementing smart metronom. 1 = "GOOD" or "EXCELLENT" run
  metroSmartResetStrikes: 3, // the minimum number of strikes before resetting to the base rate. 3 = QFAIL run.
                            // note: a notefail automatically resets smart metronome to base rate.
};

function cycleConstDur() {
  if (testOptions.constDur === false) {
    return; // we don't allow changing the meter if there are different durations of note.
            // this feature only really applies to things like scales and arps that have same note values
  }
  const dd = document.getElementById("constDurDiv");
  const durChoices = [ 1/32, 1/16, 3/32, 1/8, 3/16, 1/4, 3/8, 1/2, 3/4, 1 ];

  for (let i = 0; i < durChoices.length; i++) {
      if (parseFloat(testOptions.constDur) === durChoices[i]) {
        testOptions.constDur = durChoices[(i+1)%durChoices.length];
        break;
      }
  }

  durationsToPlay[0] = durationsToPlay[1] = [testOptions.constDur];

  updateDisplayedNotesToPlay();
  document.getElementById("constDurDiv").innerHTML = "<i class=\"fa-solid fa-arrow-rotate-right\"></i>c="+durUnicode(testOptions.constDur);
}

function cycleMeter() {
  if (testOptions.constDur === false) {
    return; // we don't allow changing the meter if there are different durations of note.
            // this feature only really applies to things like scales and arps that have same note values
  }
  const md = document.getElementById("meterDiv");

  for (let i = 0; i < meterChoices.length; i++) {
    if (meter === meterChoices[i]) {
      meter = meterChoices[ (i+1)%meterChoices.length];
      md.innerHTML = meter;
      break;
    }
  }
  md.innerHTML = "<span style=font-size:small;color:gray;display:inline-block;><i class=\"fa-solid fa-arrow-rotate-right\"></i></span>" + meter;
  testOptions.beatDur =  (1/parseInt(meter));
  updateDisplayedNotesToPlay();
}

function cycleBeatsPerBar() {
  if (testOptions.constDur === false) {
    return; // we don't allow changing this if there are different durations of note.
            // this feature only really applies to things like scales and arps that have same note values
  }
  const bpb = document.getElementById("beatsPerBarDiv");
  const beatsPerBarChoices = [1,2,3,4,5,6,8,12]; // in theory it could be anything but this is enough for now

  for (let i = 0; i < beatsPerBarChoices.length; i++) {
    if (testOptions.beatsPerBar === beatsPerBarChoices[i]) {
      testOptions.beatsPerBar = beatsPerBarChoices[ (i+1)%beatsPerBarChoices.length];
      bpb.innerHTML = "<span style=font-size:small;color:gray;display:inline-block;><i class=\"fa-solid fa-arrow-rotate-right\"></i></span>"+testOptions.beatsPerBar;
      updateDisplayedNotesToPlay();
      return;
    }
  }
}

let keyboardHidden = false;

function hideOrDisplayKeyboard() {
  const button = document.getElementById("keyboardCollapseExpandButton");
  const div = document.getElementById("keyboardAndPresetsDiv")
  if (keyboardHidden) {
    button.innerHTML= "<i class=\"fa-solid fa-minimize\"></i>"; // collapse
    div.style.display = "inline-block";
    button.style.transform = "";
  } else {
    button.innerHTML= M["keyboard"]; // keyboard
    div.style.display = "none";
    button.style.transform = "translateX(55vw)";
  }
  keyboardHidden = !keyboardHidden;
}

function clearNotesToPlaySelection() {
  noteScope[0].first = noteScope[1].first = 0;
  noteScope[0].last = notesToPlay[0].length-1;
  noteScope[1].last = notesToPlay[1].length-1;
  removeTrailingRestsFromNoteScope();
  recolorNoteScope(0);
  recolorNoteScope(1);
  clearAllBarPresetButtons();
  setFavoriteIcon(false);
}

function handleNoteDisplayAreaMenu(sel) {
  if (sel.value === "cancel") {
    ; // nothing needs to be done, fall through to code to set display to none
  } else if (sel.value === "play") {
    playNotesToPlay(1.0);
  } else if (sel.value === "playhalf") {
    playNotesToPlay(0.5);
  } else if (sel.value === "clear") {
    noteScope[0].first = noteScope[1].first = 0;
    noteScope[0].last = notesToPlay[0].length-1;
    noteScope[1].last = notesToPlay[1].length-1;
    removeTrailingRestsFromNoteScope();
    recolorNoteScope(0);
    recolorNoteScope(1);
  } else {
    alert("Unknown selection in handleNoteDisplayAreaMenu:"+sel.value+" index:"+sel.selectedIndex);
  }
  sel.parentElement.style.display = "none";
  sel.selectedIndex = -1; // make sure any future selection represents a change so handler is called
}

function showSkillMap() {
  animateOpen("skillMapContainer");
  generateSkillMap();
}

function showHelp(helpdiv) {
  console.log("showHelp:"+helpdiv);
  animateOpen(helpdiv);
}

function animateOpen(divelement, delay=0) {
  divelement = document.getElementById(divelement);
  setTimeout(function() {
    divelement.style.display = "block";
    divelement.style.transform = "scaleY(0)";
    divelement.style.transformOrigin = "top";
    setTimeout(function() {
      divelement.style.animation = "expandModeDiv 0.5s forwards";
    }, 0);
  },delay);
}

function animateClose(divelement) {
  divelement = document.getElementById(divelement);
  divelement.style.animation = "contractModeDiv 0.5s forwards";
  divelement.style.transformOrigin = "top";
  setTimeout(function() {
    divelement.style.display = "none";
  }, 510);
}

function showDayChart() {

  animateOpen("dayChartContainer");

  const today = new Date();
  const yyyy = today.getFullYear();
  let mm = today.getMonth() + 1; // getMonth() is zero-based
  let dd = today.getDate();

  // Pad single digit month and day values with a leading zero
  if (dd < 10) dd = '0' + dd;
  if (mm < 10) mm = '0' + mm;

  const formattedToday = `${yyyy}-${mm}-${dd}`;
  document.getElementById('dayChartDatePicker').value = formattedToday;

  computeDayChart();
}

function updateDayChartNote(event) {
  event.preventDefault();

  const text = document.getElementById("dayChartNoteTextArea").value;
  const date = document.getElementById("dayChartDatePicker").value;

  console.log("updateDayChartNote: date:"+date+" text=/"+text+"/");

  runHistory[".PREF.DAYCHARTNOTE."+date] = text;
  saveRunHistory();
  document.getElementById("dayChartNoteDisplay").innerHTML = "NOTE: "+text;
}

function hideSkillMap() {
  document.getElementById("skillMapContainer").style.display = "none";
}

// Function to show preferences screen
function showPrefs(show) {
  const prefsScreen = document.getElementById("prefsScreen");
  prefsScreen.style.display = show?"block":"none";
}

// Function to close preferences screen
function closePrefs() {
  const prefsScreen = document.getElementById("prefsScreen");
  prefsScreen.style.display = "none";
}

// Function to toggle preference values (boolean)
function togglePref(prefName, forcevalue = null, toggleIcon = null) {

  if (forcevalue !== null) {
    preferences[prefName] = forcevalue;
  } else {
    preferences[prefName] = !preferences[prefName]; // Toggle the boolean value
  }
  //warning("Toggled "+prefName+" now="+preferences[prefName]);

  if (forcevalue === null) {
    localStorage.setItem(prefName, preferences[prefName]); // Save to localStorage
    console.log("Saved "+prefName+"="+preferences[prefName]);
  }

  let td = document.getElementById("td"+prefName);
  if (td !== null) {
    td.style.backgroundColor = preferences[prefName]?statsColor:togglePrefColor;
    td.style.opacity = preferences[prefName]?"1":"0.3";
    //warning("Toggled pref "+prefName+" to "+td.style.backgroundColor);
  } else if (prefName === "enableVoice") {
    setVoiceIconColor();

    if (preferences[prefName]) {
      say("Voice on.");
    } else {
      say("Voice off.", true);
    }
  } else if (prefName === "barPresetAll") {
    let td = document.getElementById("toggleBarSelect");
    console.log("setting barpref label prefname="+prefName+" value:"+preferences[prefName]+" td="+td);
    td.innerHTML = ((preferences[prefName]) ? "<i class=\"fa-solid fa-arrow-rotate-right\"></i>All" : "<i class=\"fa-solid fa-arrow-rotate-right\"></i>Fav");; // redisplay
    computePriorStreakData(); // redisplay
  }

  if (forcevalue === null)
    loadPrefs(); // keep it in sync with saved values

  if (toggleIcon) {
    const icon = document.getElementById("prefIconToggle"+prefName);
    icon.className = "fa fa-toggle-"+(preferences[prefName]?"on":"off");
  }
}

// Function to set preference values (string) and save to localStorage
function setPref(prefName, value) {
  preferences[prefName] = value;
  localStorage.setItem(prefName, value);
  console.log("setPref set "+prefName+" to '"+value+"'");
  //warning("Set pref "+prefName+"="+value);
}

function setVoiceIconColor() {
  let td = document.getElementById("toggleVoiceButton");
  const color = preferences["enableVoice"] ? "green" : "red";
  td.style.color = color;
  console.log("SETVOICEICON COLOR:"+color);
}

let summary = null;

// Function to load preferences from localStorage
function loadPrefs() {
  console.log("###Loadprefs");

  if (typeof localStorage === "undefined" || localStorage === null) {
    warning("No local storage found");
    return;
  } else {
    console.log("**Reading Prefs from localStorage");
  }
  for (const prefName in preferences) {
    //console.log("Looking for "+prefName);

    if (preferences.hasOwnProperty(prefName)) {
      const value = localStorage.getItem(prefName);

      if (!isAvail(value)) {
        continue;
      }

      //console.log("***Loadprefs: found prefname="+prefName+" value="+value);

      if (prefName === 'bpmNoteValue' || prefName.startsWith('tone') || prefName === "noteFilter") {
        // For the menu item, directly set the value as a string
        preferences[prefName] = value;
        // Update the menu display
        const menu = document.getElementById(prefName+'Menu');
        if (menu === null) {
          warning("Could not find menu with name "+prefName+'Menu');
        } else {
          menu.value = value;
        }

      } else if (prefName === 'metroVolume' || prefName === 'speakingVolume') {

        //console.log("Setting volume "+prefName+" to "+value);

        preferences[prefName] = value;

        const mv = document.getElementById(prefName+"Menu");
        if (mv === null) {
          warning("Could not find"+prefName+" volume menu");
        } else {
          mv.value = value;
        }

        if (prefName === 'metroVolume') {
          document.getElementById("metroVolumeSlider").value = Number(value);
          //console.log("Set metroVolumeSlider to "+value);
        }

      } else {
        // For boolean preferences, convert the stored value to a boolean
        preferences[prefName] = (value === 'true');
        // Update the toggle display
        if (prefName === "enableVoice") {
          setVoiceIconColor();
        }

        const toggle = document.getElementById(prefName + 'Toggle');
        if (toggle === null) {
          //console.log("Could not find a toggle named "+prefName+'Toggle');
        } else {
          toggle.checked = preferences[prefName];
        }
      }
    }
  }
  console.log("####Completed LoadPrefs");
}

// set colors
const bodyColor = "rgba(173, 216, 230, 0.7)";
const bodyAlertColor = "yellow";
const staffColor = "rgba(216, 191, 216, 0.7)";
const staffScrollbarThumbColor = "rgba(200, 180, 200, 0.7)";
const staffScrollbarTrackColor = "rgba(240, 210, 240, 0.9)";
const statsColor = "rgba(152, 251, 152, 0.7)";
const togglePrefColor = "rgba(142,231,142,0.8)";

document.addEventListener('DOMContentLoaded', function () {

  document.body.style.backgroundColor = bodyColor;
  document.getElementById("statsArea").style.backgroundColor = statsColor;
  document.getElementById("staffArea").style.backgroundColor = staffColor;
  document.getElementById("staffArea").style.scrollbarColor = staffScrollbarThumbColor+" "+staffScrollbarTrackColor;
  document.getElementById("consoleTD").style.backgroundColor = statsColor;

  setInterval(function() {
    drawPianoKeyboard(keyboardOptions);
  }, 50);

  summary = document.getElementById("runSummary");
  summary.innerHTML="";
  changeSelectedHand('both');

  let syms = "";
  for (let key in M) {
    if (M.hasOwnProperty(key)) {
      syms += M[key];
    }
  }
  syms += "";
  message("symbols:<span class=mf style=font-size:32px>"+syms+"<span>");
  message("symbols2:<span class=mf style=font-size:24px><i class=\"fa-regular fa-rectangle-xmark\"></i>&#x1F5E3;<span>");

// JavaScript code for restoring
const restoreButton = document.getElementById("restoreButton");

restoreButton.addEventListener("click", function() {
    const importedJSON = importExportTextarea.value;
    restoreRunHistoryFromJSON(importedJSON);
});

// initialize history

setTimeout(function() {
  loadRunHistory(true);
  checkBackupStatus();
  updateMetronome();
}, 500);


});

const lastBackupKey = 'REPiano.lastBackupTimestamp';

function checkBackupStatus() {
  const expbutton = document.getElementById("exportButton");

  const lastBackup = avail(localStorage.getItem(lastBackupKey),0);
  const daysSinceBackup = Math.trunc((Date.now() - lastBackup)/(60*60*24*1000));
  let color;
  if (daysSinceBackup > 3) {
    color = "red";
  } else if (daysSinceBackup > 1) {
    color = "orange";
  } else {
    color = "green"
  }
  expbutton.innerHTML = "<i class=\"fa-solid fa-file-arrow-down\"></i>&nbsp;Imp/Exp <span style=color:"+color+";font-size:xx-small>("+daysSinceBackup+")</span>";

  if (daysSinceBackup > 3) {
    expbutton.classList.add('flash-animation');
    // we're going to voice report the lack of a backup in one minute. This allows
    // time for a user interaction to activate the voice api, and gives the user a chance
    // to notice the flashing red export button.
    setTimeout(function() {
      const lastBackup = avail(localStorage.getItem(lastBackupKey),0);
      const daysSinceBackup = Math.trunc((Date.now() - lastBackup)/(60*60*24*1000));

      if (daysSinceBackup > 14) {
        alert("CRITICAL: Last data backup was over 14 days ago, click Export to backup now.");
      } else if (daysSinceBackup > 3) {
        say("You have not backed up your history data in over 3 days. Click Export to back up your data.");
      }
    },60000);

  } else {
    expbutton.style.border = "solid 1px black";
    expbutton.classList.remove('flash-animation');
  }
}

function handleImportFileSelect(evt) {
    let file = evt.target.files[0]; // FileList object

    // Only proceed if a file was selected
    if (!file) {
        return;
    }

    let reader = new FileReader();

    // Closure to capture the file information
    reader.onload = (function(theFile) {
      return function(e) {
        // e.target.result contains the file's content
        let history = e.target.result;

        // You can now use the 'history' variable for your needs
        console.log("History import, bytes read="+history.length); // For demonstration, logging the content to console

        restoreRunHistoryFromJSON(history);
      };
    })(file);

    // Read the file as text
    reader.readAsText(file);
  }

  document.addEventListener('DOMContentLoaded', function () {
    document.getElementById('importBackup').addEventListener('change', handleImportFileSelect, false);
  });

function restoreRunHistoryFromJSON(importedJSON) {
  try {
      const importedData = JSON.parse(importedJSON);
      // Replace the existing runHistory with importedData
      runHistory = importedData;
      saveRunHistory();
      alert("History Data restored successfully!");

      // take down the history and import screens
      document.getElementById("historyTableContainer").style.display = "none";
      document.getElementById("importExportContainer").style.display = "none";
      document.getElementById("errorMapContainer").style.display = "none";
  } catch (error) {
      alert("Invalid JSON format. Please check and try again.");
  }
}

function freePlayDescription(name) {
  const fp = freePlay.find(p => p.name === name);

  return fp?fp.description:'';
}

function presetCategory(name) {
  const pre = presets.find(p => p.name === name);

  if (isAvail(pre)) {
    return pre.category;
  }

  const fp = freePlay.find(p => p.name === name);

  return fp?fp.category:null;
}

function stripPresetModifiers(name) {
  if (!isAvail(name)) {
    console.trace();
    return name;
  }
  name = name.replace(/ B[0-9]+$/,'');
  name = name.replace(/ B[0-9]+-[0-9]+$/,'');
  if (name.endsWith("Oct)")) {
    name = name.slice(0,-8);
  }
  return name;
}

function gotoPreset(name, dismissDiv=null, barRange=null, lfirst=-1, llast=-1, rfirst=-1, rlast=-1) {
  let index = presets.findIndex(preset => preset.name===name);

  if (index === -1 && name.endsWith("Oct)")) {
    for (let oct = 1; index===-1 && oct <= 4; oct++) {
      const name2 = name.slice(0,-6)+String(oct)+" Oct)";
      index = presets.findIndex(preset => preset.name===name2);
    }
  }

  if (index != -1) {
    handlePresetSelection(index, barRange, lfirst, llast, rfirst, rlast);
  } else {
    console.log("Could not find preset: /"+name+"/"+((barRange!==null)?barRange:""));
    alert("Preset not found: "+name+((barRange!==null)?barRange:""));
  }

  if (dismissDiv !== null) {
    if (typeof dismissDiv === 'string') {
      dismissDiv = document.getElementById(dismissDiv);
    }
    dismissDiv.style.display = 'none';
  }

}

// Function to handle preset selection

function handlePresetSelection(presetIndex, barRange=null, lfirst, llast, rfirst, rlast) {
  //console.log("in handlePresetSel");
  let selectedPreset = -1;

  if (presetIndex >= 0 && presetIndex < presets.length) {
    curPresetIndex = presetIndex;
    selectedPreset = presets[presetIndex];

    curPresetName = avail(presets[presetIndex].name, "Unknown Preset");

    if (avail(presets[presetIndex].isFreePlay)) {
      // special handling, there are no notes.
      notesToPlay = [null, null];
      barAnnotations = null;
      updateSelectableHands(false, false, false);
      fingersToPlay = [];
      durationsToPlay = [];
      testOptions = {
        graphOrder: "note",
        swingEighths: false,
        beatsPerBar: 4,
        originalBeatsPerBar: 4,
        beatDur: 1/4,
        originalBeatDur: 1/4,
        targetBPM: 120,
        maxBPM: 2000,
        disconnectDur: 0,
        constDur: true,
        originalConstDur: true, // in case user changes it we can log data under different name
        midiVoice: avail(selectedPreset.midiVoice, 0), // default is grand piano
        octaveParams: null,
        shortName: presets[presetIndex].name,
        fullName: presets[presetIndex].description,
        isFreePlay: true,
        learningSchedule: avail(runHistory[".PREF.LEARNINGSCHEDULE."+stripPresetModifiers(curPresetName)], "begin")
      };

      updateDisplayedNotesToPlay();

      document.getElementById("barSelectContainer").innerHTML = '';
      document.getElementById("scaleModContainer").style.display = "none";

      console.log("in freeplay section of handlePreset, learningSchedule=/"+testOptions.learningSchedule);
      setLearningSchedule(testOptions.learningSchedule);

      return;
    }

    // Update notesToPlay with the selected preset's notes
    processNotes(selectedPreset.leftHand);
    processNotes(selectedPreset.rightHand);
    notesToPlay = [selectedPreset.leftHand, selectedPreset.rightHand];

    //console.log("Set hands");

    // Update bar annotations, if any
    if (isAvail(selectedPreset.barAnnotations)) {
      barAnnotations = selectedPreset.barAnnotations;
      //console.log("Bar Annotations found");
    } else {
      barAnnotations = null;
      //console.log("Bar Annotations NOT found");
    }

    //console.log("Set bar annotations");
    // Auto-select a hand if only one is available

    if (selectedPreset.leftHand === null || selectedPreset.leftHand.length === 0) {
      updateSelectableHands(false, true, false);
      changeSelectedHand('right');
    } else if (selectedPreset.rightHand === null || selectedPreset.rightHand.length === 0) {
      updateSelectableHands(true, false, false);
      changeSelectedHand('left');
    } else {
      updateSelectableHands(true, true, true);
      changeSelectedHand('both');
    }

    //console.log("Set avail hands");

    fingersToPlay = [];
    fingersToPlay[0] = avail(selectedPreset.leftFingers, null);
    fingersToPlay[1] = avail(selectedPreset.rightFingers, null);

    durationsToPlay = [];
    durationsToPlay[0] = avail(selectedPreset.leftDur, [1/4]);
    durationsToPlay[1] = avail(selectedPreset.rightDur, [1/4]);
    holdsToPlay = [];
    holdsToPlay[0] = avail(selectedPreset.leftHold, null);
    holdsToPlay[1] = avail(selectedPreset.rightHold, null);

    let constDurFound = true;
    let dursFound = {};
    let constDurValue = null;

    for (let h = 0; h < 2; h++) {
      for (let d = 0; d < durationsToPlay[h].length; d++) {
        dursFound[durationsToPlay[h][d]] = true;
        constDurValue = durationsToPlay[h][d];
        //console.log("dursFound[]="+durationsToPlay[h][d]);
      }
    }

    // constDur tells us that all the durations of every note (left and right hand) are the same
    // this is used to tell whether we can compute an HTQ score. Although it is possible to compute an
    // HTQ score even when durations are not the same, it is much more complex and we have not yet
    // implemented that. For things like scales and arpeggios, constDur should be true but for
    // more complex songs it typically will not be.

    if (Object.keys(dursFound).length > 1) {
      constDurFound = false;
    }
    console.log("CONSTDUR="+constDurFound+" numfound:"+Object.keys(dursFound).length+" value="+constDurValue);
    //console.log("Set fingers and durations");

    // in the process of refactoring to bring all the different options into one
    // variable called testOptions.
    //console.log("Setting testopts");
    testOptions = {
      graphOrder: avail(selectedPreset.graphOrder, "note"),
      swingEighths: avail(selectedPreset.swingEighths, false),
      beatsPerBar: avail(selectedPreset.beatsPerBar, 4),
      originalBeatsPerBar: avail(selectedPreset.beatsPerBar, 4),
      beatDur: avail(selectedPreset.beatDur, 1/4),
      originalBeatDur: avail(selectedPreset.beatDur, 1/4),
      targetBPM: avail(selectedPreset.targetBPM, 120),
      maxBPM: avail(selectedPreset.maxBPM, 2000),
      disconnectDur: avail(selectedPreset.disconnectDur, 10),
      constDur: constDurFound?constDurValue:false,
      originalConstDur: constDurFound?constDurValue:false, // in case user changes it we can log data under different name
      midiVoice: avail(selectedPreset.midiVoice, 0), // default is grand piano
      octaveParams: avail(selectedPreset.octaveParams, null),
      fullName: avail(selectedPreset.fullName,null),
      learningSchedule: avail(runHistory[".PREF.LEARNINGSCHEDULE."+stripPresetModifiers(curPresetName)], "begin")
    };

    if (testOptions.octaveParams !== null) {
      changeOctave(testOptions.octaveParams);
    } else {
      changeOctave(null);
    }

    console.log("in NON-freeplay section of handlePreset, learningSchedule=/"+testOptions.learningSchedule);
    setLearningSchedule(testOptions["learningSchedule"]);

    displayTargetBPM(false);

    let cycleindicator = "";
    if (testOptions.constDur) {
      cycleindicator = "<span style=font-size:small;color:gray;display:inline-block;><i class=\"fa-solid fa-arrow-rotate-right\"></i></span>";
    }
    document.getElementById("meterDiv").innerHTML = cycleindicator + (1/parseFloat(testOptions.beatDur));
    document.getElementById("sw8Div").innerHTML = (testOptions.swingEighths?"sw8":"");
    document.getElementById("beatsPerBarDiv").innerHTML = cycleindicator + (testOptions.beatsPerBar);
    if (testOptions.constDur) {
      document.getElementById("constDurDiv").innerHTML = cycleindicator+"c="+durUnicode(testOptions.constDur);
    } else {
      document.getElementById("constDurDiv").innerHTML = "";
    }

    updateDisplayedNotesToPlay();

    // compute the number of beats in the left and right hands
    computeBeatsToPlay();

    // this preset has custom metrics settings
    if (isAvail(selectedPreset.metrics)) {
      const mets = ['HTQ', 'MetQ', 'DynQ', 'LegQ', 'StaQ'];
      const custmets = selectedPreset.metrics;

      for (let i = 0; i < mets.length; i++) {
        if (isAvail(custmets[mets[i]])) {
          togglePref('score'+mets[i], custmets[mets[i]]);
          //console.log("Set custom metric:"+mets[i]+"="+custmets[mets[i]]);
        }
      }
    }
  }
  setNoteFilters();

  sayTestParameters();

  clearStats(); // when changing to a new preset, clear the stats.

  loadTodayStats();

  setFavoriteIcon(false); // there is no selection

  if (barRange !== null) {
    changeBarScope(barRange, lfirst, llast, rfirst, rlast);
  }

  //document.getElementById("PresetMenu").value = presets[presetIndex].menuValue;
  document.getElementById("selectedPresetDisplay").innerHTML = avail(selectedPreset.menuName, selectedPreset.name);
}

function sayTestParameters(shortform=false) {
  const hand = getSelectedHand();

  if (!shortform) {
    if (testOptions.fullName !== null) {
      say(testOptions.fullName, false, "TESTNAME");
    } else {
      say(curPresetName, false, "TESTNAME");
    }
    setTimeout(function() { displayPriorRunStats(); }, 500);
  }

  if (hand !== "both") {
    say(hand+" hand only", false, "TESTNAME");
  } else {
    say("hands together", false, "TESTNAME");
  }

  computePriorStreakData();

  if (BPMRecommendedRange[0] > 0) {
      say("Recommended speed "+spokenNumber(BPMRecommendedRange[1]), false, "TESTNAME");
      setMetroBPM(Number(BPMRecommendedRange[1]), true);
  } else {
      setMetroBPM(avail(testOptions.targetBPM, metroBPM), true); // set to target if there is one, else leave it the same
  }

}

// Voice api command to queue voice utterances and cancel ones that are no longer valid

const speechQueue = [];
let isSpeaking = false;

function enqueueSpeech(words, classification = null, options = {}) {
  speechQueue.push({ words, classification, ...options });
  if (!isSpeaking) {
    speakNextInQueue();
  }
}

function speakNextInQueue() {
  if (speechQueue.length === 0) {
    isSpeaking = false;
    return;
  }

  isSpeaking = true;
  const item = speechQueue.shift(); // Get the first item in the queue
  const sayWords = new SpeechSynthesisUtterance(item.words);
  sayWords.rate = item.rate || preferences.speakingRate;
  sayWords.volume = item.volume || avail(preferences.speakingVolume, 1.0);

  sayWords.onend = sayWords.onerror = function() {
    isSpeaking = false;
    speakNextInQueue(); // Automatically proceed to the next item
  };

  window.speechSynthesis.speak(sayWords);
}

function cancelSpecificClassification(classification) {
  // Filter out all items with the given classification
  const remainingItems = speechQueue.filter(item => item.classification !== classification);
  speechQueue.length = 0; // Clear the queue
  speechQueue.push(...remainingItems); // Re-add items that do not match the classification
}

function say(words, force = false, classification = null) {
  if (!preferences.enableVoice && !force) {
    return;
  }
  if (classification) {
    cancelSpecificClassification(classification);
  }
  enqueueSpeech(words, classification, { rate: preferences.speakingRate, volume: avail(preferences.speakingVolume, 1.0) });
}

function old_say(words, force=false) {
  if (!preferences.enableVoice && !force) {
    return;
  }
  const sayWords = new SpeechSynthesisUtterance(words);
  sayWords.rate = preferences.speakingRate;
  sayWords.volume = avail(preferences.speakingVolume, 1.0);
  window.speechSynthesis.speak(sayWords);
}

function changeOctave(octaveParams) {
  if (octaveParams === null) {
    // this means octave choices should not be offered
    document.getElementById("scaleModContainer").style.display = "none";
    return;
  }
  document.getElementById("scaleModContainer").style.display = "block";
  let buttonDisplay;

  if (typeof octaveParams === "number" && isAvail(testOptions.octaveParams)) {
    // if we get a plain number, it means change the current scale/arp to the given number of
    // octaves

    // IMPLEMENT: Note that we should not really generate a new set of test data for every change, we
    // should be looking first to see if the given params are already in the presets menu and
    // if so just set that one. But in practice this won't hurt anything unless someone
    // clicks thousands of octave changes in a single session.

    let lhOctave;
    if (octaveParams === 1 || octaveParams === 2) {
      lhOctave = 3;
    } else {
      lhOctave = 2;
    }
    const p = generateScalePreset(testOptions.octaveParams.noteName,
                        testOptions.octaveParams.scaleType,
                        octaveParams,
                        lhOctave,
                      );
    console.log("ChangeOctaves generating new octave params:"+testOptions.octaveParams.noteName+" "+
      testOptions.octaveParams.scaleType+" "+lhOctave+" "+octaveParams);
    buttonDisplay = octaveParams;
    presets.push(p);
    handlePresetSelection(presets.length-1);
    curPresetName = avail(presets[presets.length-1].name, "Unknown Preset");
    console.log("ChangeOctaves: preset name set to: "+curPresetName);
    return;

  } else {
    console.log("ChangeOctaves: setting choices to "+testOptions.octaveParams.numOctaves);
    buttonDisplay = testOptions.octaveParams.numOctaves;
  }
  document.getElementById("oct1").classList.remove('selected');
  document.getElementById("oct2").classList.remove('selected');
  document.getElementById("oct3").classList.remove('selected');
  document.getElementById("oct4").classList.remove('selected');
  document.getElementById("oct"+buttonDisplay).classList.add('selected');
  console.log("ChangeOctaves: set display to:"+ buttonDisplay);

  clearStats();
  loadTodayStats();

}

let curDisplayedBPMFrac = 1;

function displayTargetBPM(advance=false) {

  const bpmFrac = {
    1: 0.75,
    0.75: 0.5,
    0.5: 0.25,
    0.25: 1.25,
    1.25: 1
  }

  if (!advance) {
    curDisplayedBPMFrac = 1;
  } else {
    curDisplayedBPMFrac = avail(bpmFrac[curDisplayedBPMFrac], 1);
  }
  document.getElementById("targetBPMDiv").innerHTML = "<div style=padding-left:2px;padding-right:2px;font-size:x-small;line-height:0.9;text-align:center;color:green><span class=mf style=font-size:small>"+
    "<i class=\"fa-solid fa-arrow-rotate-right\"></i>"+
    Math.trunc(curDisplayedBPMFrac*testOptions.targetBPM) +
    "="+durUnicode(testOptions.beatDur)+
    "</span><br><span style=font-size:x-small>"+
    Math.trunc(100*curDisplayedBPMFrac)+
    "%</span></div>";
}

function computeBeatsToPlay() {
  beatsToPlay = [0,0];

  //console.log("ComputeBeatsToPlay beatDur="+testOptions.beatDur);

  for (let h = 0; h < 2; h++) {
    for (let n = noteScope[h].first; n <= noteScope[h].last; n++) {
      beatsToPlay[h] += durationsToPlay[h][n%durationsToPlay[h].length]/testOptions.beatDur;
    }
  }
}

// substitute string versions of notes with midi numbers
function processNotes(notes) {
  for (let i = 0; i < notes.length; i++) {
    if (typeof notes[i] === 'string') {
      //console.log("Translating note:"+notes[i]+" to number:"+noteToMidiNumber(notes[i]));
      notes[i] = noteToMidiNumber(notes[i]);
    }
  }
  return notes;
}

function noteToMidiNumber(note) {
  // Define a map of note names to MIDI note numbers
  const noteMap = {
    'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3,
    'E': 4, 'F': 5, 'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8, 'Ab': 8,
    'A': 9, 'A#': 10, 'Bb': 10, 'B': 11
  };

  // Split the input note into note name and octave
  const match = note.match(/^([A-Ga-g#b]+)(\d+)$/);
  if (match) {
    const noteName = match[1].toUpperCase();
    const octave = parseInt(match[2], 10);

    if (noteMap.hasOwnProperty(noteName)) {
      // Calculate the MIDI note number based on the note name and octave
      return noteMap[noteName] + 12 * (octave + 1);
    }
  }

  // invalid input
  return null;
}

// these helper functions make code to test if a value is defined and set to non-null
// cleaner looking.
function avail(item, defaultValue = null) {
  if (typeof item !== 'undefined' && item !== null) {
    return item;
  }
  return defaultValue;
}

// boolean version of avail(), useful for if statements
function isAvail(item) {
  // the item===item tests for NaN
  if (typeof item !== 'undefined' && item !== null && item === item) {
    return true;
  }
  return false;
}

function limitNumber(inputElement) {
    if (inputElement.value.length > 2) {
        inputElement.value = inputElement.value.slice(0, 2);
    }
}

function logFreePlayManualTime() {
  console.log("logFreePlayManualTime");
  let value = document.getElementById("freePlayManualInput").value;

  value = avail(value, 0);

  logFreePlay(value*60*1000, true);  // the time value is minues, stored in milliseconds
  document.getElementById("freePlaySaveMessage").innerHTML = "Saved &check;";
  setTimeout(function() {
    document.getElementById("freePlaySaveMessage").innerHTML = "";
  }, 4000);

}

function getTodayFreePlayTime() {
  return 0;
}

function updateDisplayedNotesToPlay(isErrorMap = false) {

  if (testOptions.isFreePlay) {

        const timesofar = avail(getTodayFreePlayTime(),0);
        document.getElementById("notesRH").innerHTML =
           "<p style=font-size:x-large;padding-left:20px>Free Play: "+
              testOptions.shortName+"<br>"+testOptions.fullName+"</p>"+
           "<br><div style=display:flex;align-items:center>"+
           "<span style=padding-left:20px>Manually set minutes:&nbsp;</span>"+
           "<input id=freePlayManualInput type=number value='"+timesofar+
                "' min=0 max=99 oninput=limitNumber(this) style=width:3em;text-align:center;background-color:rgba(255,255,255,0.5)>"+
           "&nbsp;<button onclick=logFreePlayManualTime() style=background-color:rgba(255,255,255,0.5)>SAVE</button>"+
           "<span id=freePlaySaveMessage></span>"+
           "</div>"+
           "<p style=padding-left:20px>Note: Free Play time data is not logged unless clock is started then stopped or a manual time is entered.<br>Manual entries REPLACE data for today. Clock times ADD to data for today.</p>";
        document.getElementById("notesLH").innerHTML = "";
        document.getElementById("labelLH").style.display = "none";
        document.getElementById("labelRH").style.display = "none";
        document.getElementById("labelRepStats").style.display = "none";
        return;
  }
  document.getElementById("labelLH").style.display = "inline-block";
  document.getElementById("labelRH").style.display = "inline-block";
  document.getElementById("labelRepStats").style.display = "inline-block";

  const prefix = isErrorMap?"err_":"";

  maxBar = 0;
  noteStartBeat = [[],[]]; // beat number each note starts on, may be fractional
  let needbarreps = true;

  for (let h = 1; h >=0; h--) {
    let notepr = "";
    let totbeats = 0;
    let barnum = -1;
    let excessbeats = false;
    for (let i = 0; i < notesToPlay[h].length; i++) {
      if ( totbeats / testOptions.beatsPerBar >= barnum ) {
        const priorbar = barnum;
        barnum = 1 + Math.trunc(totbeats / testOptions.beatsPerBar);
        //console.log("TOPLOOP: h="+h+" i="+i+"priorBarnum:"+priorbar+" totbeats:"+totbeats+" bpb:"+testOptions.beatsPerBar+" newbarnum:"+barnum+" excess="+excessbeats);
        //console.log("OPEN DIV FOR NEW BAR "+barnum);
        let rel = "";
        rel = "position:relative;";
        // show the bar stroke and bar number
        notepr += "&nbsp;<div id="+prefix+"bar_"+h+"_"+barnum+
                  " style=user-select:none;display:inline-block;"+
                  rel+"><span id="+prefix+"barline_"+h+"_"+barnum+
                  " onclick='toggleNoteScope(event);' style='font-weight:bold;padding-right:6px;'>&nbsp;<sup>"+
                  barnum+"</sup><span style=font-size:larger>|</span></span>&nbsp;";

        if (excessbeats) {
          notepr += "<div id=ntp_tie data-beat="+(Math.trunc(totbeats))+" style=display:inline-block>&mdash;</div>"; // this tells the user that the last note of the prior bar ties over to this bar
        }
      }

      noteStartBeat[h][i] = totbeats; // this will be used for HTQ and graph display amoung other things
      //console.log("Set startbeat "+h+"-"+i+"="+noteStartBeat[h][i]);

      notepr += " <div id="+prefix+"ntp_"+h+"_"+i+" class=mfs style=display:inline-block;line-height:1.6; onclick='toggleNoteScope(event);' data-beat="+totbeats+">";
      if (isChord(notesToPlay[h][i])) {
        notepr += "<strong style=font-size:x-large>{</strong>";
        console.log("Found chord with "+notesToPlay[h][i].length+" notes");
        for (let c = 0; c < notesToPlay[h][i].length; c++) {
          const height = (10/(notesToPlay[h][i].length-1))*c-7; // jag each successive note a bit higher to visually show the "chord"
          notepr+="<div style=display:inline-block;font-size:smaller;transform:translateY("+height+"px)>"+prnotenum(notesToPlay[h][i][c], h, i, c);
          let finger = null;
          if (notesToPlay[h][i][c] !== RESTNOTE && isAvail(fingersToPlay)) {
            if (isAvail(fingersToPlay[h]) && isAvail(fingersToPlay[h][i])) {
                finger = fingersToPlay[h][i];
              }
              notepr += "<span class=mf>"+fmtFingerDurM(finger, h, i, c)+"</span>";
          }
          notepr+="</div>";
          //notepr += "&nbsp;";
        }
        notepr += "<strong style=font-size:x-large>}</strong>";
      } else {
        notepr+=prnotenum(notesToPlay[h][i], h, i);
        let finger = null;
        if (notesToPlay[h][i] !== RESTNOTE && isAvail(fingersToPlay)) {
          if (isAvail(fingersToPlay[h]) && isAvail(fingersToPlay[h][i])) {
              finger = fingersToPlay[h][i];
            }
            notepr += "<span class=mfs>"+fmtFingerDurM(finger, h, i)+"</span>";
        }
      }

      //console.log("FINGERDIR:"+fmtFingerDur(finger, h, i));

      const priortotbeats = totbeats;
      totbeats += durationsToPlay[h][i%durationsToPlay[h].length]/testOptions.beatDur;

      //console.log("h"+h+"n"+i+" totbeats:"+totbeats+" beats/bar:"+testOptions.beatsPerBar);

      if ( totbeats / testOptions.beatsPerBar >= barnum || i === notesToPlay[h].length-1 ) {

        // if the final note of the bar was larger than needed to fill out this bar, that means it must
        // split across bars (i.e. a tie is needed, although we don't currently support ties we
        // can still give an indication of this for now)

        excessbeats = ( (totbeats / testOptions.beatsPerBar) !== barnum);

        //console.log("ENDLOOP: h="+h+" i="+i+" totbeats:"+totbeats+" bpb:"+testOptions.beatsPerBar+
            // " barnum:"+barnum+" excess="+excessbeats);
        //console.log("CLOSE DIV FOR BAR "+barnum);
        // if we're at the end of a bar or we're at the last note without the bar ending, close off
        // this bar, add annotations if available, and add reps data if available.
        notepr += "</div>";
        if (h === 1 && isAvail(barAnnotations) && isAvail(barAnnotations[barnum])) {
          notepr += "<div style='position:absolute;bottom:100%;left:10px;font-size:x-small;padding-left:2em'><em>"+barAnnotations[barnum]+"</em></div>";
          //console.log("Added barAnno to bar "+barnum+" text:"+barAnnotations[barnum]);
        }
        if (h === 0) {
          if (needbarreps) {
            //console.log("Computing Bar Reps");
            computeBarReps(); // Get bar level repetition data from history
            needbarreps = false;
          }
          if (!isAvail(barReps[barnum])) {
            barReps[barnum] = [0,0,0];
          }
          notepr += "<div style='position:absolute;top:110%;left:3em;font-size:x-small;'><em><span style=color:blue>"+
                      barReps[barnum][0]+"</span>&nbsp;<span style=color:red>"+
                      barReps[barnum][1]+"</span>&nbsp;<span style=color:purple>"+
                      barReps[barnum][2]+
                      "</span></em></div>";
          //console.log("Added BarReps data:"+" R:"+barReps[barnum][1]+" B:"+barReps[barnum][2]);

        }
      }
      notepr+="</div>";

      maxBar = Math.max(maxBar, Math.ceil(totbeats/testOptions.beatsPerBar));
    }

    if (isErrorMap) {
      document.getElementById("errorNotes"+(h?"RH":"LH")).innerHTML = notepr;
      continue;
    }
    activeBars = {first:1, last:maxBar};

    // add an extra div for errors that happen at the end, after all legit notes are played
    notepr += "<div id=ntp_"+h+"_error style=display:inline-block>&nbsp;&nbsp;&nbsp;</div>";

    // add a final barline
    notepr += "<div style=display:inline-block>&nbsp;"+M["finalbar"]+"&nbsp;</div>"

    document.getElementById("notes"+(h?"RH":"LH")).innerHTML = notepr;

    // initialize noteScope to all notes.

    noteScope = [{first:0,last:notesToPlay[0].length-1}, {first:0,last:notesToPlay[1].length-1}];

    removeTrailingRestsFromNoteScope();

    computeBeatsToPlay();

    //warning("Set notescope:"+noteScope[0].first+":"+noteScope[0].last+":"+noteScope[1].first+":"+noteScope[1].last);
  } // end of for (h...)

  setTimeout(function() {
    // make bars for L and R the same width
    for (let b = 1; b <= maxBar; b++) {
      const lb = document.getElementById(prefix+"bar_0_"+b);
      const rb = document.getElementById(prefix+"bar_1_"+b);
      const lbw = (lb!==null)?parseInt(getComputedStyle(lb).width):0;
      const lbwx = (lb!==null)?parseInt(getComputedStyle(lb).xOffset):0;
      const rbw = (rb!==null)?parseInt(getComputedStyle(rb).width):0;
      const maxtmp = Math.max(lbw,rbw)*1.5;
      const maxw = maxtmp + "px";
      //console.log("barnum="+b+" maxw="+maxw+" lbw:"+lbw+" rbw:"+rbw+" rb:"+rb+" lb:"+lb);

      if (lb !== null && rb !== null) {
        lb.style.width = maxw;
        rb.style.width = maxw;

        // Adjust the position of the notes within the bars so they
        // line up based on each note's beat number. If we take maxw, and we know the number of beats in
        // each bar (we do, it's beatsPerBar) then we could move the ntp's within each bar so they line up
        // in terms of beat position.
        // IMPLEMENT: Sometimes this results in very short notes like sixteenths played rapidly next to each
        // other getting squished together. Detecting this and widening the bar would be a good idea. This could
        // be done by looking for overlapping bounding rectangles. You could also perhaps scale
        // the note notation narrower in this case

        const lbn = Array.from(lb.querySelectorAll('[id^="ntp_"]'));
        //console.log("LBN length="+lbn.length);
        const rbn = Array.from(rb.querySelectorAll('[id^="ntp_"]'));
        let beatoffset = 0;
        const margin = 25;
        for (let i = 0; i < lbn.length; i++) {
          const note = lbn[i];
          const beat = parseFloat(note.getAttribute('data-beat'));
          //console.log("Got NTP BEAT="+beat);
          if (i === 0) {
            beatoffset = beat;
          }
          const x = (maxtmp-2*margin)*(beat-beatoffset)/testOptions.beatsPerBar + margin;
          //console.log("Beat:"+beat+" beatoffset:"+beatoffset+" maxw:"+maxw+" b/bar:"+testOptions.beatsPerBar);
          note.style.left = x+"px";
          note.style.bottom = "-6px";
          note.style.position = "absolute";
          //console.log("For bar="+b+" set note id="+note.id+" x="+x);
        }

        // find collisions of rectangles of notes, narrow those that collide
        for (let i = 1; i < lbn.length; i++) {
          const note = lbn[i];
          const priornote = lbn[i-1];
          const noteRect = note.getBoundingClientRect();
          const priorRect = priornote.getBoundingClientRect();
          if (priorRect.x+priorRect.width > noteRect.x) {
            priornote.style.transformOrigin = "left";
            const nudge = 0;
            let scale = (noteRect.x-priorRect.x+nudge-1)/(priorRect.width);
            if (scale > 1) scale = 1;
            priornote.style.transform = "scaleX("+scale+")";
          }
        }

        beatoffset = 0;
        for (let i = 0; i < rbn.length; i++) {
          const note = rbn[i];
          const beat = parseFloat(note.getAttribute('data-beat'));
          //console.log("Got NTP BEAT="+beat);
          if (i === 0) {
            beatoffset = beat;
          }
          const x = (maxtmp-2*margin)*(beat-beatoffset)/testOptions.beatsPerBar + margin;
          //console.log("Beat:"+beat+" beatoffset:"+beatoffset+" maxw:"+maxw+" b/bar:"+testOptions.beatsPerBar);
          note.style.left = x+"px";
          note.style.bottom = "4px";
          note.style.position = "absolute";
          //console.log("For bar="+b+" set note id="+note.id+" x="+x);
        }

        // find collisions of rectangles of notes, narrow those that collide
        for (let i = 1; i < rbn.length; i++) {
          const note = rbn[i];
          const priornote = rbn[i-1];
          const noteRect = note.getBoundingClientRect();
          const priorRect = priornote.getBoundingClientRect();
          if (priorRect.x+priorRect.width > noteRect.x) {
            priornote.style.transformOrigin = "left";
            const nudge = 0;
            let scale = (noteRect.x-priorRect.x+nudge-1)/(priorRect.width);
            if (scale > 1) scale = 1;
            priornote.style.transform = "scaleX("+scale+")";
            // nudge the current one over a bit.
            // note.style.transform = window.getComputedStyle(note).getPropertyValue('transform') + " translateX("+nudge+"px)";
          }
        }
      }

    }
  }, 0);
}

function removeTrailingRestsFromNoteScope() {

  for (let h = 0; h < 2; h++) {
    noteScope[h].lastnonrest = Number(noteScope[h].last);
    while (notesToPlay[h][noteScope[h].last] == RESTNOTE) {
      noteScope[h].last--;
      noteScope[h].lastnonrest = noteScope[h].last;
      if (noteScope[h].last < 0) {
        break;
      }
    }

    noteScope[h].firstnonrest = 0;
    while (notesToPlay[h][noteScope[h].firstnonrest] == RESTNOTE) {
      noteScope[h].firstnonrest++;
      if (noteScope[h].firstnonrest > noteScope[h].last) {
        break;
      }
    }

    noteScope[h].firstrangenonrest = Number(noteScope[h].first);
    while (notesToPlay[h][noteScope[h].firstrangenonrest] == RESTNOTE) {
      noteScope[h].firstrangenonrest++;
      if (noteScope[h].firstrangenonrest > noteScope[h].last) {
        break;
      }
    }
  }
}

function restWithDur(h, i) {
    let dur = null;

    if (isAvail(durationsToPlay) && isAvail(durationsToPlay[h])
          && durationsToPlay[h].length > 0) {
        dur = durationsToPlay[h][i%durationsToPlay[h].length];
    } else {
      return M["wholerest"]; // we don't know the duration
    }
    dur = parseFloat(dur); // this and the next line canonicalize it as a decimal fraction
    dur = String(dur);
    const durMap = {
      "1":M["wholerest"],
      "1.5":M["wholerest"]+M["dot"],
      "0.5":M["halfrest"],
      "0.875":M["halfrest"]+M["quarterrest"]+M["8threst"],
      "0.75":M["halfrest"]+M["dot"],
      "0.25":M["quarterrest"],
      "0.375":M["quarterrest"]+M["dot"],
      "0.125":M["8threst"],
      "0.1875":M["8threst"]+M["dot"],
      "0.0625":M["16threst"],
      "0.09375":M["16threst"]+M["dot"],
      "0.03125":M["32ndrest"],
    }
    return avail(durMap[dur], M["wholerest"]+durFrac(dur));
}

function fmtFingerDurM(finger, h, n, c=null) {
  // IMPLEMENT: take into account c not null
  let dur = null;
  let hold = null;
  if (isAvail(durationsToPlay) && isAvail(durationsToPlay[h])
        && durationsToPlay[h].length > 0) {

      const dtp = durationsToPlay[h][n%(durationsToPlay[h].length)];
      if (isChord(dtp)) { // each note of a chord could have a different length, or all could be the same
        console.log("Chord Duration, len="+isChord(dtp)+" h="+h+" n="+n+" c="+c);
        if (c !== null) {
            dur = dtp[c%(dtp.length)]; // let the array wrap
        } else {
          dur = dtp[0];
        }
        dur = durUnicode(dur);
      } else {
        //console.log("Plain Duration, len="+isChord(dtp)+" h="+h+" n="+n+" c="+c);
        dur = durationsToPlay[h][n%durationsToPlay[h].length];
        hold = (isAvail(holdsToPlay) && isAvail(holdsToPlay[h]) && holdsToPlay[h].length !== null)?(holdsToPlay[h][n%holdsToPlay[h].length]):dur;

        if (0 && isAvail(hold) && hold !== dur) {
          console.log("HOLD NOT DUR: hold:"+hold+" dur:"+dur);
          dur = durUnicode(hold);
          hold = restUnicode(dur);
          console.log("HOLD NOT DUR: hold:"+hold+" dur:"+dur);
        } else {
          dur = durUnicode(dur);
          hold = dur;
        }
      }
  }

  let color = (h===0)?"blue":"red";
  let fmtdur = "<span class=mfl>"+dur+"</span>";
  if (dur !== hold) {
    fmtdur = "<div class=mf style=display:flex;flex-direction:column><div>"+
              hold+"</div><div>"+dur+"</div></div>"
  }
  return fmtdur + "<sup style=font-size:xx-small;color:"+color+";font-weight:bold>"+ ((finger !== null)?finger:"&nbsp;") + "</sup>";
}

function durUnicode(dur) {
  dur = parseFloat(dur); // this and the next line canonicalize it as a decimal fraction
  dur = String(dur);
  const durMap = {
    "2":M["whole"]+M["whole"],
    "1":M["whole"],
    "1.5":M["whole"]+M["dot"],
    "1.25":M["whole"]+M["quarter"],
    "1.125":M["whole"]+M["8th"],
    "0.5":M["half"],
    "0.625":M["half"]+M["8th"],
    "0.75":M["half"]+M["dot"],
    "0.875":M["half"]+M["quarter"]+M["8th"],
    "0.25":M["quarter"],
    "0.375":M["quarter"]+M["dot"],
    "0.4375":M["quarter"]+M["8th"]+M["dot"],
    "0.125":M["8th"],
    "0.1875":M["8th"]+M["dot"],
    "0.0625":M["16th"],
    "0.09375":M["16th"]+M["dot"],
    "0.08333333333333333":M["quarter"]+String.fromCodePoint(0x2153),
    "0.03125":M["32nd"],
  }
  return avail(durMap[dur], String(durFrac(dur)));
}


function restUnicode(dur) {
  dur = parseFloat(dur); // this and the next line canonicalize it as a decimal fraction
  dur = String(dur);
  const durMap = {
    "1":M["wholerest"],
    "1.125":M["wholerest"]+M["8threst"],
    "1.25":M["wholerest"]+M["quarterrest"],
    "1.5":M["wholerest"]+M["dot"],
    "0.5":M["halfrest"],
    "0.875":M["halfrest"]+M["quarterrest"]+M["8threst"],
    "0.75":M["halfrest"]+M["dot"],
    "0.25":M["quarterrest"],
    "0.375":M["quarterrest"]+M["dot"],
    "0.125":M["8threst"],
    "0.1875":M["8threst"]+M["dot"],
    "0.0625":M["16threst"],
    "0.09375":M["16threst"]+M["dot"],
    "0.03125":M["32ndrest"],
  }
  return avail(durMap[dur], M["wholerest"]+dur);
}


function fmtFingerDur(finger, h, n) {
  let dur = null;
  let num = 0;
  let denom = 0;
  if (isAvail(durationsToPlay) && isAvail(durationsToPlay[h])
        && durationsToPlay[h].length > 0) {
      dur = durationsToPlay[h][n%durationsToPlay[h].length];
      dur = durFrac(dur);
  }
  if (dur !== null) {
    const f = dur.split("/");
    num =  f[0];
    denom = f[1];
  }
  return "<div style=display:inline-block;transform:translateY(-33%);text-align:center><div style=display:flex;flex-direction:column;font-size:9px>" +
            "<div>"+ ((finger !== null)?finger:"&nbsp;") + "</div>"+
            "<div style='border-bottom:1px solid black;font-size:7px'>"+num+"</div>" +
            "<div style=font-size:8px>"+denom+"</div>"+
            "</div></div>";
}


function toggleNoteScope(event) {

  let [toss,hand,note] = event.currentTarget.id.split('_');

  if (toss === "barline") {
    toggleBarScope(event);
    return;
  }
  hand = parseInt(hand);
  note = parseInt(note);

  console.log("toggleNoteScope clicked. h="+hand+" note="+note+" toss=/"+toss+"/");

  let lastnonrest = notesToPlay[hand].length-1;
  while (notesToPlay[hand][lastnonrest] === RESTNOTE && lastnonrest > 0) {
    lastnonrest--;
  }

  if (noteScope[hand].first === 0 && noteScope[hand].last >= lastnonrest) {
    // The current scope is the entire range. So, the clicked note is now
    // going to be the entire range.
    noteScope[hand].first = noteScope[hand].last = note;
  } else if (note < noteScope[hand].first) {
    // extend the range down to note
    noteScope[hand].first = note;
  } else if (note === noteScope[hand].first) {
    // already on, so turn it off
    noteScope[hand].first++;
  } else if (note > noteScope[hand].last) {
    // extend range up to note
    noteScope[hand].last = note;
  } else if (note === noteScope[hand].last) {
    noteScope[hand].last--;
  } else {
    // the note must be inside the range. So, move the beginning or end of range to
    // note, depending on which note is closer to.
    if (noteScope[hand].last - note > note - noteScope[hand].first) {
      noteScope[hand].first = note;
    } else {
      noteScope[hand].last = note;
    }
  }

  if (noteScope[hand].last < noteScope[hand].first) {
    // there is no more scope, so whole range is on.
    noteScope[hand].first = 0;
    noteScope[hand].last = notesToPlay[hand].length-1;
  }

  removeTrailingRestsFromNoteScope();

  recolorNoteScope(hand);

  computeBeatsToPlay();

  updateToggleFavoriteButton();

  console.log("Note Scope, Left:"+noteScope[0].first+"-"+noteScope[0].last+"-nr:"+noteScope[0].firstrangenonrest+" Right:"+noteScope[1].first+"-"+noteScope[1].last+"-nr:"+noteScope[1].firstrangenonrest);

  event.stopPropagation();
}

function updateToggleFavoriteButton() {
  // See if the current notescope is actually one of the favorites and update the icon color to reflect this.
  const modeBoxes = document.querySelectorAll('#barSelectContainer .mode-box-bars');

  // Loop through the NodeList of elements and see if any one has data-notescope that matches
  // the current noteScope

  let foundit = false;

  modeBoxes.forEach(box => {
      const ns = box.getAttribute("data-notescope");

      if (ns === null) {
        return; // process next one
      }

      const [lf, ll, rf, rl] = ns.split(",");

      if (lf == noteScope[0].first && ll == noteScope[0].last &&
          rf == noteScope[1].first && rl == noteScope[1].last) {
          const pref = getHistoryPref(ns.id);
          console.log("Found bar preset matching notescope:"+box.id+" fav="+pref);
          setFavoriteIcon(pref);
          recolorBarPresets(box.id);
          displayPriorRunStats();
          foundit = true;
          return; // only one can match
      }
  });

  if (foundit === false) {
    recolorBarPresets(null); // turn them all off
    setFavoriteIcon(false);  // this can't be a favorite because it doesn't match anything
  }

}

function setFavoriteIcon(isFav) {
  const fav = document.getElementById("toggleFavoriteIcon");

  if (isFav) {
    fav.style.color = "#900"; // dark red
  } else {
    fav.style.color = "#999"; // light gray
  }
}

function toggleBarScope(event) {

  let [toss,hand,bar] = event.currentTarget.id.split('_');

  hand = parseInt(hand);
  bar = parseInt(bar);

  console.log("toggleBarScope clicked. h="+hand+" bar="+bar);

  let firstnote = null, lastnote = null;

  for (let n = 0; n < notesToPlay[hand].length; n++) {
    const curbar = 1 + Math.trunc(noteStartBeat[hand][n]/testOptions.beatsPerBar);
    if (curbar === bar) {
      if (firstnote === null) {
        firstnote = n;
      }
      lastnote = n;
    } else if (curbar > bar) {
      break;
    }
  }

  console.log("firstnote: "+firstnote+" last:"+lastnote);

  if (noteScope[hand].first === firstnote && noteScope[hand].last === lastnote) {
    // already on, turn them all off.
    noteScope[hand].first = 0;
    noteScope[hand].last = notesToPlay[hand].length-1;
  } else {
    // just turn these on
    noteScope[hand].first = firstnote;
    noteScope[hand].last = lastnote;
  }

  removeTrailingRestsFromNoteScope();

  recolorNoteScope(hand);

  computeBeatsToPlay();

  console.log("Note Scope, Left:"+noteScope[0].first+"-"+noteScope[0].last+"-nr:"+noteScope[0].firstrangenonrest+" Right:"+noteScope[1].first+"-"+noteScope[1].last+"-nr:"+noteScope[1].firstrangenonrest);

  event.stopPropagation();
}


function recolorNoteScope(hand) {
  // recolor all the notes to make them reflect reality
  for (let n = 0; n < notesToPlay[hand].length; n++) {
    const notediv = document.getElementById("ntp_"+hand+"_"+n);
    if (n >= noteScope[hand].first && n <= noteScope[hand].last &&
      (noteScope[hand].first > 0 || noteScope[hand].last < notesToPlay[hand].length-1)) {
      notediv.style.backgroundColor = "#AAAADD";
    } else {
      notediv.style.backgroundColor = "transparent";
    }
  }
}

// Create presets
console.log("pushing presets");

const A1 = 'A1', A2 = 'A2', A3 = 'A3', A4 = 'A4', A5 = 'A5', A6 = 'A6';
const B1 = 'B1', B2 = 'B2', B3 = 'B3', B4 = 'B4', B5 = 'B5', B6 = 'B6';
const C1 = 'C1', C2 = 'C2', C3 = 'C3', C4 = 'C4', C5 = 'C5', C6 = 'C6';
const D1 = 'D1', D2 = 'D2', D3 = 'D3', D4 = 'D4', D5 = 'D5', D6 = 'D6';
const E1 = 'E1', E2 = 'E2', E3 = 'E3', E4 = 'E4', E5 = 'E5', E6 = 'E6';
const F1 = 'F1', F2 = 'F2', F3 = 'F3', F4 = 'F4', F5 = 'F5', F6 = 'F6';
const G1 = 'G1', G2 = 'G2', G3 = 'G3', G4 = 'G4', G5 = 'G5', G6 = 'G6';

// Sharps
const A1s = 'A#1', C1s = 'C#1', D1s = 'D#1', F1s = 'F#1', G1s = 'G#1';
const A2s = 'A#2', C2s = 'C#2', D2s = 'D#2', F2s = 'F#2', G2s = 'G#2';
const A3s = 'A#3', C3s = 'C#3', D3s = 'D#3', F3s = 'F#3', G3s = 'G#3';
const A4s = 'A#4', C4s = 'C#4', D4s = 'D#4', F4s = 'F#4', G4s = 'G#4';
const A5s = 'A#5', C5s = 'C#5', D5s = 'D#5', F5s = 'F#5', G5s = 'G#5';
const A6s = 'A#6', C6s = 'C#6', D6s = 'D#6', F6s = 'F#6', G6s = 'G#6';

// Flats
const A1b = 'A1b', B1b = 'B1b', D1b = 'D1b', E1b = 'E1b', G1b = 'G1b';
const A2b = 'A2b', B2b = 'B2b', D2b = 'D2b', E2b = 'E2b', G2b = 'G2b';
const A3b = 'A3b', B3b = 'B3b', D3b = 'D3b', E3b = 'E3b', G3b = 'G3b';
const A4b = 'A4b', B4b = 'B4b', D4b = 'D4b', E4b = 'E4b', G4b = 'G4b';
const A5b = 'A5b', B5b = 'B5b', D5b = 'D5b', E5b = 'E5b', G5b = 'G5b';
const A6b = 'A6b', B6b = 'B6b', D6b = 'D6b', E6b = 'E6b', G6b = 'G6b';

const scalemetrics = {HTQ: true, MetQ: true, DynQ: true, LegQ: true, StaQ: false};

const bluesscalemetrics = {HTQ: true, MetQ: true, DynQ: true, LegQ: true, StaQ: false};

const bluesSwungEighths = [[1/8], [1/8], 1/8, true];

presets.push("Scales, Major");
presets.push(generateScalePreset('A', 'maj', 2, 3, null, scalemetrics));
presets.push(generateScalePreset('A#', 'maj', 2, 3, null, scalemetrics));
presets.push(generateScalePreset('B', 'maj', 2, 3, null, scalemetrics));
presets.push(generateScalePreset('C', 'maj', 2, 3, null, scalemetrics));
presets.push(generateScalePreset('C#', 'maj', 2, 3, null, scalemetrics));
presets.push(generateScalePreset('D', 'maj', 2, 3, null, scalemetrics));
presets.push(generateScalePreset('D#', 'maj', 2, 3, null, scalemetrics));
presets.push(generateScalePreset('E', 'maj', 2, 3, null, scalemetrics));
presets.push(generateScalePreset('F', 'maj', 2, 3, null, scalemetrics));
presets.push(generateScalePreset('F#', 'maj', 2, 3, null, scalemetrics));
presets.push(generateScalePreset('G', 'maj', 2, 3, null, scalemetrics));
presets.push(generateScalePreset('G#', 'maj', 2, 3, null, scalemetrics));

presets.push("Scales, Minor");
presets.push(generateScalePreset('A', 'natMin', 2, 3, null, scalemetrics));
presets.push(generateScalePreset('B', 'natMin', 2, 3, null, scalemetrics));
presets.push(generateScalePreset('C', 'natMin', 2, 3, null, scalemetrics));
presets.push(generateScalePreset('D', 'natMin', 2, 3, null, scalemetrics));
presets.push(generateScalePreset('E', 'natMin', 2, 3, null, scalemetrics));
presets.push(generateScalePreset('F', 'natMin', 2, 3, null, scalemetrics));
presets.push(generateScalePreset('G', 'natMin', 1, 3, null, scalemetrics));

presets.push(generateScalePreset('D', 'melMin', 1, 3, null, scalemetrics));
presets.push(generateScalePreset('E', 'melMin', 1, 3, null, scalemetrics));
presets.push(generateScalePreset('G', 'melMin', 1, 3, null, scalemetrics));
presets.push(generateScalePreset('D', 'harMin', 1, 3, null, scalemetrics));
presets.push(generateScalePreset('E', 'harMin', 1, 3, null, scalemetrics));
presets.push(generateScalePreset('G', 'harMin', 1, 3, null, scalemetrics));

presets.push("Scales, Other");
presets.push(generateScalePreset('A', 'minBlues', 2, 3, null, bluesscalemetrics, bluesSwungEighths));
presets.push(generateScalePreset('C', 'minBlues', 2, 3, null, bluesscalemetrics, bluesSwungEighths));
presets.push(generateScalePreset('G', 'chroma', 1, 3, null, scalemetrics));

presets.push("Arpeggios");
presets.push(generateScalePreset('C', 'majArp', 2, 3, null, scalemetrics));
presets.push(generateScalePreset('D', 'majArp', 2, 3, null, scalemetrics));
presets.push(generateScalePreset('E', 'majArp', 2, 3, null, scalemetrics));
presets.push(generateScalePreset('F', 'majArp', 2, 3, null, scalemetrics));
presets.push(generateScalePreset('G', 'majArp', 2, 3, null, scalemetrics));
presets.push(generateScalePreset('A', 'majArp', 2, 3, null, scalemetrics));
presets.push(generateScalePreset('A', 'natMinArp', 2, 3, null, scalemetrics));

presets.push("Octaves");

const octmetrics = {HTQ: false, MetQ: true, DynQ: true, LegQ: false, StaQ: true};
presets.push(generateScalePreset('C', 'maj', 1, 5, "OCTAVE-C5", octmetrics));
presets[presets.length-1].category = 'drill';
presets.push(generateScalePreset('C', 'maj', 1, 2, "OCTAVE-C2", octmetrics));
presets[presets.length-1].category = 'drill';
presets.push(generateScalePreset('G', 'maj', 1, 5, "OCTAVE-G5", octmetrics));
presets[presets.length-1].category = 'drill';
presets.push(generateScalePreset('G', 'maj', 1, 2, "OCTAVE-G2", octmetrics));
presets[presets.length-1].category = 'drill';

presets.push("Other Drills");
presets.push({
  name: 'RUN-PITPAT',
  category: 'drill',
  leftHand: [
    48, 50, 52, 55,
    -1,
    72, 74, 76, 79,
    -1,
    96, -1,
    -1,
    79, 76, 74, 72, -1,
    55, 52, 50, 48,],
   leftDur: [
     1/4, 1/4, 1/4, 1/4,
     1,
     1/4, 1/4, 1/4, 1/4,
     1,
     1/4, 3/4,
     1,
     1/4, 1/4, 1/4, 1/4, 1,
     1/4, 1/4, 1/4, 1/4
   ],
  rightHand: [ -1, 60, 62, 64, 67,
    -1,  84, 86, 88, 91,
    -1, 91, 88, 86, 84,
    -1, 67, 64, 62, 60,
    -1  ],
  rightDur: [
    1, 1/4, 1/4, 1/4, 1/4,
    1, 1/4, 1/4, 1/4, 1/4,
    1, 1/4, 1/4, 1/4, 1/4,
    1, 1/4, 1/4, 1/4, 1/4,
    1
  ],
  metrics: {HTQ: false, MetQ: false, DynQ: true, LegQ: false, StaQ: false}
});

presets.push({name: 'FGAmG-LH-IMP1',
  category: 'drill',
  beatsPerBar: 6,
  beatDur: 1/4,
  leftHand: [
              41, 48, 53, 48, 53, 48, 41, 48, 53, 48, 53, 48, // F
              43, 50, 55, 50, 55, 50, 43, 50, 55, 50, 55, 50, // G
              45, 52, 57, 52, 57, 52, 45, 52, 57, 52, 57, 52, // Am
              43, 50, 55, 50, 55, 50, 43, 50, 55, 50, 55, 50, // G
            ],
  leftDur: [1/8],
  rightHand: [
    84,83,81,76,74,72,
    84,83,81,76,74,72,
    84,83,81,76,74,72,
        84,83,81,76,74,72,
  ],
  rightDur: [1/4],
}
);

presets.push({name: 'FGAmG-LH-IMP2',
  category: 'drill',
  beatsPerBar: 6,
  beatDur: 1/4,
  leftHand: [
              41, 48, 53, 48, 53, 48, 41, 48, 53, 48, 53, 48, // F
              43, 50, 55, 50, 55, 50, 43, 50, 55, 50, 55, 50, // G
              45, 52, 57, 52, 57, 52, 45, 52, 57, 52, 57, 52, // Am
              43, 50, 55, 50, 55, 50, 43, 50, 55, 50, 55, 50, // G
            ],
  leftDur: [1/8],
  rightHand: [
    'B4', 'C5', 'B4', 'A4', 'E5', 'A4',
    'B4', 'C5', 'B4', 'A4', 'E5', 'A4',
    'B4', 'C5', 'B4', 'A4', 'E5', 'A4',
    'B4', 'C5', 'B4', 'A4', 'E5', 'A4',
  ],
  rightDur: [1/4],
}
);

presets.push({
  name: 'CAmFG Fill',
  fullName: 'Left hand chords with fill C/A minor/F/G',
  category: 'drill',
  beatsPerBar: 4,
  beatDur: 1/4,
  leftHand: [
              C3,-1,-1,-1,
              A2,-1,-1,-1,
              F2,-1,-1,-1,
              G2,-1,-1,-1
            ],
  leftDur: [1/4],
  rightHand: [
    G3, C4, D4,    G4, D4, C4,    G3, C4, D4,   G4, D4, C4,
    G3, C4, D4,    G4, D4, C4,    G3, C4, D4,   G4, D4, C4,
    G3, C4, D4,    G4, D4, C4,    G3, C4, D4,   G4, D4, C4,
    G3, C4, D4,    G4, D4, C4,    G3, C4, D4,   G4, D4, C4,
  ],
  rightDur: [1/12], // triplets
}
);


presets.push("Repertoire");

presets.push({
  name: 'F&uumlR-ELISE',
  category: 'repertoire',
  rightHand: [
    -1, 76, 75,                 //bar 1
    76, 75, 76, 71, 74, 72,
    69,  -1,  60, 64, 69,
    71,  -1,  64, 68, 71,
    72,  -1,  64, 76, 75,
    76, 75, 76, 71, 74, 72,   // bar 6
    69, -1, 60, 64, 69,
    71, -1, 62, 72, 71,
    69, -1, 71, 72, 74,       // bar 8 (marked 2.)

    76, 67, 77, 76,
    74, 65, 76, 74,
    72, 64, 74, 72,
    71, -1                   // just the first note of bar 12
  ],
  rightDur: [
    1/4, 1/16, 1/16,
    1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16,
    1/16, 1/16, 1/16, 1/16, 1/16, 1/16, // bar 6
    1/8, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, // bar 8 (2.)
    3/16, 1/16, 1/16, 1/16,
    3/16, 1/16, 1/16, 1/16,
    3/16, 1/16, 1/16, 1/16,
    1/8, 1/4 // ending on first note of bar 12 then 1/4 duration rest to fill it out
  ],

  leftHand: [
    -1, -1,
    45, 52, 57,    -1,
    40, 52, 56,    -1,
    45, 52, 57,    -1, -1,
    45, 52, 57,    -1,
    40, 52, 56,    -1,
    45, 52, 57,    -1,
    48, 55, 60,    -1,
    43, 55, 59,    -1,
    45, 52, 57,    -1,
    40, 52, 64,    -1,
  ],
  leftDur: [
    3/8, 3/8,
    1/16, 1/16, 1/16,    3/16,
    1/16, 1/16, 1/16,    3/16,
    1/16, 1/16, 1/16,    3/16, 3/8,

    1/16, 1/16, 1/16,    3/16,
    1/16, 1/16, 1/16,    3/16,
    1/16, 1/16, 1/16,    3/16,

    1/16, 1/16, 1/16,    3/16,
    1/16, 1/16, 1/16,    3/16,
    1/16, 1/16, 1/16,    3/16,
    1/16, 1/16, 1/16,    3/16,
  ],


  beatDur: 1/8,

  beatsPerBar: 3,

  targetBPM: 138,

  graphOrder: "bar", // graph bar by bar instead of note by note

  leftFingers: null,
  rightFingers: null,
  metrics: {HTQ: false, MetQ: true, DynQ: true, LegQ: true, StaQ: false}
});

presets.push({
  name: 'CSA', // Come Sail Away by Styx
  category: 'repertoire',
  fullName: "Come Sail Away, by Styx",
  beatsPerBar: 4,
  beatDur: 1/4,
  targetBPM: 114,
  maxBPM: 150,
  disconnectDur: 30, // disconnected notes, milliseconds
  graphOrder: "bar", // graph bar by bar instead of note by note
  leftHand: [60, 67, 64, 67, 64, 67, 60, 67, //C arp
             62, 69, 65, 69, 65, 69, 62, 69, // Dm arp
             64, 71, 67, 71, 67, 71, 64, 71, // Em arp
             62, 69, 65, 69, 65, 69, 62, 69, // Dm arp

             60, 67, 64, 67, 60, 64, 60, 67, //C arp, different pattern

             55, 62, 59, 62,     55, 62, 59, 62,    // G alberti
             'C4', 'G4', 'E4', 'G4', 'C4', 'G4', 'E4', 'G4',  // Confirmed. bar 7, C4 alberti bass
             'B3', 'G4', 'E4', 'G4', 'E4', 'G4', 'B3', 'G4',  // Confirmed. bar 8, Em/B
             'A3', 'E4', 'C4', 'E4', 'A3', 'E4', 'C4', 'E4',  // Confirmed. bar 9 Am
             'A3', 'E4', 'A3', 'E4', 'A3', 'E4', 'G3', 'D4',  // Confirmed. bar 10 G
             'F3', 'C4', 'A3', 'C4', 'F3', 'C4', 'A3', 'C4',  // Confirmed. bar 11 F
             'F3', 'C4', 'A3', 'C4', 'F3', 'C4', 'F3', 'C4',  // Confirmed. bar 12 F
             'G3', 'D4', 'B3', 'D4', 'B3', 'D4', 'G3', 'D4',  // Confirmed. bar 13 G
             B3, D4, G3, D4, B3, D4, G3, D4,                  // Bar 14
             C4, G4, E4, G4, C4, G4, E4, G4,                  // Bar 15 C
             B3, G4, E4, G4, B3, G4, C4, G4,                  // Bar 16 Em/B
             A3, E4, C4, E4, A3, E4, A3, E4,                  // Bar 17 Am
             A3, E4, A3, E4, A3, E4, G3, D4,                  // Bar 18 Am->G
             F3, C4, A3, C4, F3, C4, A3, C4,                  // Bar 19, F (44 alberti)
             F3, C4, A3, C4, F3, C4, A3, C4,                  // Bar 20, F (44 alberti)
             G3, D4, B3, D4, B3, D4, G3, D4,                  // Bar 21, G (62 alberti)
             B3, D4, B3, D4, G3, D4, G3, D4,                  // Bar 22, G (nonstandard, MHMHLHLH)
           ],
  leftDur: [1/8],
  rightHand: [76, 86, 84, 76,
              77, 86, 84, 77,
              79, 86, 84, 79,
              77, 86, 84, 84, 83, 81, 83, // last four are sixteenths
              84, 79, 72, 72,

              71,72,71,72,71,72,71,72,  // bar 6: trilling on B, technically could be more or fewer than this
              71, 71, 69, 71,
              'C5', 'C6', 'G5', 'E5', 'C5',      // Confirmed. bar 7, start of verse 1:  "I'm"
              'B4', 'B5', 'G5', 'E5', 'B4',  // Confirmed. bar 8 "Sail-ing   a-"
              'E5', 'C5', 'C5', 'A4',        // Confirmed. bar 9  "-way"
              'A4', 'A5', 'E5', 'D5',        // Confirmed. bar 10, instrumental
              'C5', 'A4', 'A4',              // Confirmed. bar 11, "set an o--pen" the final A4 is tied to the next bar
              /*'A4' tie,*/ 'F5', 'E5', 'C5', 'A4', 'F4',  // Confirmed. bar 12, "course ... for the"
              'G4', 'D5', 'D5',               // Confirmed. bar 13, "vir - gin sea, --" D5 is tied to next bar
              G5, G5, D5,                     // bar 14.  "... ... ... 'cause'"
              C5, C6, G5, E5, C5,             // bar 15. "I've ... ... ..."
              B4, E5, B5, G5, B4,             // bar 16. "got to ... be"
              E5, C5, C5, A5,                 // bar 17. "free"
              A5, E5, D5,                     // bar 18.
              C5, A4, A4,                     // bar 19. " ... free to face the"
              /*A4 tied*/ F5, E5, C5, A4, F4, // bar 20. "life ... that's a--"
              G4, G5, G5, D5,                 // bar 21. "--head of me"
              D5, -1, /*[*/ G5 /*,G4]*/       // bar 22.
            ],
  rightDur: [1/4, 1/4, 1/4, 1/4,
             1/4, 1/4, 1/4, 1/4,
             1/4, 1/4, 1/4, 1/4,
             1/4, 1/4, 1/4,  1/16, 1/16, 1/16, 1/16,
             3/8, 1/8, 1/4, 1/4,

             3/32,3/32,3/32,3/32,1/32,1/32,1/32,1/32,  // trills should really be faster than this, but for now 2 per LH note is good for learning it
             1/8, 1/8, 1/8, 1/8,
             1/4, 1/4, 1/4, 1/8, 1/8,     // bar 7
             1/4, 1/4, 1/4, 1/8, 1/8,     // bar 8
             3/8, 1/8, 3/8, 1/8,          // bar 9
             3/8, 1/8, 1/4, 1/4,
             3/8, 1/8, 5/8,               // bar 11, IMPLEMENT: the last note actually should be 5/8 because it ties to the next bar
                                          // however repiano cannot currently handle ties that cross bars correctly.
             1/8, 1/8, 1/8, 1/4, 1/4,
             3/8, 1/8, 5/8,               // bar 13, final note ties to next bar
             /* 1/8 tied from prior bar*/ 1/8, 1/4, 1/2,               // bar 14
             1/4, 1/4, 1/4, 1/8, 1/8,     // bar 15
             3/8, 1/8, 1/8, 1/4, 1/8,     // bar 16
             3/8, 1/8, 3/8, 1/8,          // bar 17
             1/2, 1/4, 1/4,               // bar 18
             3/8, 1/8, 5/8,               // bar 19 (final note ties to next bar)
             1/8, 1/8, 1/8, 1/4, 1/4,     // bar 20
             3/8, 1/8, 3/8, 1/8,          // bar 21
             1/2, 1/8, 3/8,               // bar 22
           ],

  barAnnotations: { "1":"Intro", "6":"(RH ABABABAB=trill)",
                    "7":"(verse 1)&nbsp;&nbsp;&nbsp;I'm",
                    "8":"&nbsp;&nbsp;sail&mdash;ing&nbsp;&nbsp;......&nbsp; a&mdash;",
                    "9":"&mdash;way,",
                    "11":"&nbsp;...............&nbsp;set an o&mdash;pen ",
                    "12":"course...............&nbsp;for the",
                    "13":"vir &mdash; gin sea, &mdash;",
                    "14":"... ... ... 'cause",
                    "15":"I've ... ... ...",
                    "16":"got to &mdash; be",
                    "17":"free, &mdash;",
                    "19":" ... ... free to face the",
                    "20":"life ... ... that's a&ndash;",
                    "21":"&ndash;head of me ...",
  },
  leftFingers: null,
  rightFingers: null,
  metrics: {HTQ: true, MetQ: false, DynQ: true, LegQ: false, StaQ: false}
});

presets.push({
  name: 'WSP',
  category: 'repertoire',
  fullName: "A Whiter Shade of Pale, by Procol Harum",
  beatsPerBar: 4,
  beatDur: 1/4,
  targetBPM: 60,
  midiVoice: 19,
  leftHand: [
    C3, -1, C3, B2, -1, B2,   // bar 1, Intro
    A2, -1, A2, G2, -1, G2,   // bar 2
    F2, -1, F2, E2, -1, E2,   // bar 3
    D2, -1, D2, C2, -1, C2,   // bar 4
    G2, -1, G2, F2, -1, F2,   // bar 5
    E2, -1, E2, D2, -1, D2,   // bar 6
    C2, E2, F2, -1, F2,       // bar 7
    G2, A2, B2,                 // bar 8 end of intro
    C3, -1, C3, B2, -1, B2,   // bar 9
    A2, -1, A2, G2, -1, G2,   // bar 10
   ],
  leftDur: [
    1/4, 1/8, 1/8, 1/4, 1/8, 1/8,     // bar 1 intro
    1/4, 1/8, 1/8, 1/4, 1/8, 1/8,     // bar 2
    1/4, 1/8, 1/8, 1/4, 1/8, 1/8,     // bar 3
    1/4, 1/8, 1/8, 1/4, 1/8, 1/8,     // bar 4
    1/4, 1/8, 1/8, 1/4, 1/8, 1/8,     // bar 5
    1/4, 1/8, 1/8, 1/4, 1/8, 1/8,     // bar 6
    1/4, 1/4, 1/4, 1/8, 1/8,          // bar 7
    1/2, 1/4, 1/4,                    // bar 8 end of intro
    1/4, 1/8, 1/8, 1/4, 1/8, 1/8,     // bar 9
    1/4, 1/8, 1/8, 1/4, 1/8, 1/8,     // bar 10
  ],
  rightHand: [
  /*[*/ E4, /* C4, G3],*/        // bar 1, intro. Note ties to next bar
        D4, C4, B3, C4, D4, E4, C4,   // bar 2
  /*[*/ A4, /* F4, C4],*/ B4, C5,     // bar 3
  /*[*/ F4, /* D4, A3],*/ E4, F4, D4, // bar 4
  /*[*/ B4, /* G4, D4],*/ C5, D5,     // bar 5
  /*[*/ G4, /* E4, B3],*/ F4, G4, F4, E4, F4,  // bar 6
  /*[*/ F4, /* C4, G3],*/ E4, D4, C4, /*[*/ C4, /* A4, F4],*/ D4, E4, F4,         // bar 7
  /*[*/ B3, /* G4],*/ C4, D4, E4, /*[*/ F4, /* B3],*/ E4, /*[*/ F4, /* G3],*/ D4, // bar 8, end of intro

  /*[*/ E4, /* C4, G3],*/ -1, G4, E5, D5, E5, D5,       // bar 9 "... We skipped the light fan--"
  D5, C5,                                               // bar 10 "--dan-go"

  ],
  rightDur: [
  /*[*/ 1.125, /* 1.25, 2, ], */  // bar 1, note ties to next bar
     1/8, 1/8, 1/8, 1/8, 1/8, 1/8, 1/8,  // bar 2
  /*[*/ 3/4, /* 1, 1, ],*/ 1/8, 1/8,     // bar 3
  /*[*/ 1/16, /* 1, 1, ],*/ 1/16, 5/8, 1/4,  // bar 4
  /*[*/ 3/4, /* 1, 1, ],*/ 1/8, 1/8,         // bar 5
  /*[*/ 1/16, /* 1/2, 1, ],*/ 1/16, 1/2, 1/8, 1/8, 1/8,  // bar 6, yeah its complicated with all the ties
  1/8, 1/8, 1/8, 1/8, 1/8, 1/8, 1/8, 1/8,    // bar 7
  1/8, 1/8, 1/8, 1/8, 1/8, 1/8, 1/8, 1/8,    // bar 8, end of intro
  1/4, 1/8, 1/8, 1/8, 1/8, 1/8, 1/8,    // bar 9 NOTE: the first 1/4 is really 1/2 sustained to the following 1/8
  1/8, 7/8,                             // bar 10
  ],

  barAnnotations: {
    "1":"Intro", "8":"End of Intro",
    "9":"&mdash; We skipped the light fan&ndash;",
    "10":"&mdash;dan-go,",
    "11":"... and turned cart-wheels 'cross the",
    "12":"floor.",
    "13":"... I was feel&ndash;ing kind of",
    "14":"sea &ndash; sick,",
  },
  graphOrder: "bar", // graph bar by bar instead of note by note
  leftFingers: null,
  rightFingers: null,
  metrics: {HTQ: true, MetQ: true, DynQ: true, LegQ: true, StaQ: false}
});

presets.push({
  name: 'MM-1',
  fullName: 'Metamorphosis 1 by Philip Glass',
  category: 'repertoire',
  beatsPerBar: 4,
  beatDur: 1/4,
  targetBPM: 110,
  midiVoice: 0,
  leftHand: [
    G3, B3, G3, B3, G3, B3, G3, B3
   ],
  leftDur: [
    1/8
  ],
  rightHand: [


  ],
  rightDur: [
    1/2
  ],

  barAnnotations: {

  },
  graphOrder: "bar", // graph bar by bar instead of note by note
  leftFingers: null,
  rightFingers: null,
  metrics: {HTQ: true, MetQ: true, DynQ: true, LegQ: true, StaQ: false}
});

presets.push({
  name: 'WTCP1', // JS Bach Well Tempered Clavier, Prelude 1 in C Major
  category: 'repertoire',
  fullName: "Prelude 1 in C Major, BWV 846 by JS Bach",
  beatsPerBar: 4,
  beatDur: 1/4,
  targetBPM: 65,
  maxBPM: 85,
  disconnectDur: 30, // disconnected notes, milliseconds
  graphOrder: "bar", // graph bar by bar instead of note by note
  leftHand: [
    C4, E4, C4, E4, // bar 1 CE
    C4, D4, C4, D4, // bar 2 CD
    B3, D4, B3, D4, // bar 3 BD
    C4, E4, C4, E4, // bar 4 CE
    C4, E4, C4, E4, // bar 5 CE
    C4, D4, C4, D4, // bar 6 CD
    B3, D4, B3, D4, // bar 7 BD
    B3, C4, B3, C4, // bar 8 BC
    A3, C4, A3, C4, // bar 9 AC
    D3, A3, D3, A3, // bar 10 DA
    G3, B3, G3, B3, // bar 11 GD
    G3, A3s, G3, A3s, // bar 12
    F3, A3, F3, A3, // bar 13
    F3, G3s, F3, G3s, // bar 14
    E3, G3, E3, G3,   // bar 15
    E3, F3, E3, F3,   // bar 16 ElF
    D3, F3, D3, F3,   // bar 17 DoF (a hat)
    G2, D3, G2, D3,   // bar 18 GooD
    C3, E3, C3, E3,   // bar 19 ColE
    C3, G3, C3, G3,   // bar 20 CaGey
    F2, F3, F2, F3,   // bar 21 FluFf
    F2s, C3, F2s, C3,  // bar 22 sharp FiCus
    G2s, F3, G2s, F3,  // bar 23 sharp GuFf
    G2, F3, G2, F3,    // bar 24 GuFf
    G2, E3, G2, E3,    // bar 25 GEE
    G2, D3, G2, D3,    // bar 26 GooD
    G2, D3, G2, D3,    // bar 27 GooD
    G2, D3s, G2, D3s,  // bar 28 GooD sharp
    G2, E3, G2, E3,    // bar 29 GEE
    G2, D3, G2, D3,    // bar 30 GooD
    G2, D3, G2, D3,    // bar 31 GooD
    C2, C3, C2, C3,    // bar 32 CooKie
    C2, C3, C2, C3,    // bar 33, CooKie IMPLEMENT: These are actually slurred
    C2, B2, C2, B2,    // bar 34, CuB    IMPLEMENT: These are actually slurred
    C2, C3             // IMPLEMENT: these are actually chorded for the whole measure although the c3 starts an eighth rest later
  ],
  leftDur: [
    1/16, 7/16, 1/16, 7/16 // all bars same (except last 3)
  ],
  leftHold: [
    1/2, 3/8, 1/2, 3/8    // all bars same (except last 3)
  ],
  rightHand: [
    -1, G4, C5, E5, G4, C5, E5, -1, G4, C5, E5, G4, C5, E5, // bar 1
    -1, A4, D5, F5, A4, D5, F5, -1, A4, D5, F5, A4, D5, F5, // bar 2
    -1, G4, D5, F5, G4, D5, F5, -1, G4, D5, F5, G4, D5, F5, // bar 3
    -1, G4, C5, E5, G4, C5, E5, -1, G4, C5, E5, G4, C5, E5, // bar 4
    -1, A4, E5, A5, A4, E5, A5, -1, A4, E5, A5, A4, E5, A5, // bar 5
    -1, F4s, A4, D5, F4s, A4, D5, -1, F4s, A4, D5, F4s, A4, D5, // bar 6 FAD
    -1, G4, D5, G5, G4, D5, G5, -1, G4, D5, G5, G4, D5, G5, // bar 7 GooDyGood
    -1, E4, G4, C5, E4, G4, C5, -1, E4, G4, C5, E4, G4, C5, // bar 8 EGgCream
    -1, E4, G4, C5, E4, G4, C5, -1, E4, G4, C5, E4, G4, C5, // bar 9 EGgCream
    -1, D4, F4s, C5, D4, F4s, C5, -1, D4, F4s, C5, D4, F4s, C5, // bar 10 DeepFaKe
    -1, D4, G4, B4, D4, G4, B4, -1, D4, G4, B4, D4, G4, B4, // bar 11 DoGBite
    -1, E4, G4, C5s, E4, G4, C5s, -1, E4, G4, C5s, E4, G4, C5s, // bar 12 EGgCream sharp
    -1, D4, A4, D5, D4, A4, D5, -1, D4, A4, D5, D4, A4, D5,   // bar 13 DAD
    -1, D4, F4, B4, D4, F4, B4, -1, D4, F4, B4, D4, F4, B4,  // bar 14 DeFiB
    -1, C4, G4, C5, C4, G4, C5, -1, C4, G4, C5, C4, G4, C5,  // bar 15 CaGeCow
    -1, A3, C4, F4, A3, C4, F4, -1, A3, C4, F4, A3, C4, F4, // bar 16 Ape CuFf
    -1, A3, C4, F4, A3, C4, F4, -1, A3, C4, F4, A3, C4, F4, // bar 17 Ape CuFf
    -1, G3, B3, F4, G3, B3, F4, -1, G3, B3, F4, G3, B3, F4, // bar 18 GruboFf
    -1, G3, C4, E4, G3, C4, E4, -1, G3, C4, E4, G3, C4, E4, // bar 19 GeCko Ear
    -1, A3s, C4, E4, A3s, C4, E4, -1, A3s, C4, E4, A3s, C4, E4, // bar 20 sharp ACE
    -1, A3, C4, E4, A3, C4, E4, -1, A3, C4, E4, A3, C4, E4,     // bar 21 ACE
    -1, A3, C4, D4s, A3, C4, D4s, -1, A3, C4, D4s, A3, C4, D4s, // bar 22 ACE flat
    -1, B3, C4, D4, B3, C4, D4, -1, B3, C4, D4, B3, C4, D4,     // bar 23 BeaKeD
    -1, G3, B3, D4, G3, B3, D4, -1, G3, B3, D4, G3, B3, D4,     // bar 24 GruBbeD
    -1, G3, C4, E4, G3, C4, E4, -1, G3, C4, E4, G3, C4, E4,     // bar 25 GeCko Ear
    -1, G3, C4, F4, G3, C4, F4, -1, G3, C4, F4, G3, C4, F4,     // bar 26 GeCko Foot
    -1, G3, B3, F4, G3, B3, F4, -1, G3, B3, F4, G3, B3, F4,     // bar 27 GruB Go
    -1, A3, C4, F4s, A3, C4, F4s, -1, A3, C4, F4s, A3, C4, F4s, // bar 28 Ape CuFf sharp
    -1, G3, C4, G4, G3, C4, G4, -1, G3, C4, G4, G3, C4, G4,     // bar 29 GeCko Goo
    -1, G3, C4, F4, G3, C4, F4, -1, G3, C4, F4, G3, C4, F4,     // bar 30 GeCko Foot
    -1, G3, B3, F4, G3, B3, F4, -1, G3, B3, F4, G3, B3, F4,     // bar 31 GruB Foot
    -1, G3, A3s, E4, G3, A3s, E4, -1, G3, A3s, E4, G3, A3s, E4, // bar 32 GrApe EEl
    // the bars below have different durations than usual
    -1, F3, A3, C4, F4, C4, F3, C4, A3, F3, A3, F3, D3, F3, D3, // bar 33
    -1, G4, B4, D5, F5, D5, B4, D5, B4, G4, B4, D4, F4, E4, D4, // bar 34
    C5   // IMPLEMENT: bar 35 is reall a chord of E4,G4,C5, i.e. c maj chord first inversion
  ],
  rightDur: [
    // the first 32 measures all have the same durations
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,

    // measures 33, 33, 35 have different durations
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1/8, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16,
    1

  ],

  barAnnotations: {
    1: "CoLe GraCE", 2: "CoD ADolF", 3:"BaD GanDolF", 4:"", 5:"",
    6:"FAD", 7:"BeD GooDyGood", 8:"BC EGgCream", 9:"AC EGgCream",
    10:"DA DeepFaKe", 11:"GooD DoGBite", 12:"GA EGgCream sharp",
    13:"FA DAD", 14:"FA# DeFiB", 15:"EGg CaGeCow", 16:"ElF Ape CuFf",
    17:"DoFf Ape CuFf", 18:"GooD GruBoFf", 19:"CElery GeCko Ear",
    20:"CaGy ACE sharp", 21:"FluFf ACE", 22:"sharp FiCus ACE flat",
  },
  leftFingers: null,
  rightFingers: null,
  metrics: {HTQ: false, MetQ: false, DynQ: true, LegQ: false, StaQ: false}
});

presets.push({
  name: 'ICHFIL', // Elvis Presley, arpeggio version
  category: 'repertoire',
  fullName: "Can't Help Falling In Love",
  beatsPerBar: 6,
  beatDur: 1/8,
  targetBPM: 205,
  maxBPM: 250,
  disconnectDur: 30, // disconnected notes, milliseconds
  graphOrder: "bar", // graph bar by bar instead of note by note

  leftHand: [
    // intro
    D2, A2, D2, -1,
    // verse
    D2,
    F2s,
    B2,
    A2,
    G2,
    D2,
    A2,
    A2,
    G2,
    A2,
    B2,
    G2,
    D2,
    A2,
    D2,
    -1, // verse outtro


// chorus:
    F2s, C2s, F2s, C2s, F2s, C2s, F2s, B1, E2, A1,

// final verse ending:
    D2,
    A2,
    D2,
    D2,
    -1, // verse outtro
    D2
  ],
  rightHand: [
    // intro
    -1, D4, F4s, A4, F4s, D4,
    -1, A3, C4s, E4, C4s, A3,
    -1, F3s, A3, D4, A3, F3s,
    F4s, D4, A3, A4, F4s, D4, // inversion ending

    // verse
    -1, D4, F4s, A4, F4s, D4,
    -1, C4s, F4s, A4, F4s, C4s,
    -1, B3, D4, F4s, D4, B3,
    -1, B3, D4, F4s, D4, B3,
    -1, B3, D4, G4, D4, B3,
    -1, A3, D4, F4s, D4, A3,
    -1, A3, C4s, E4, C4s, A3,
    -1, A3, C4s, E4, C4s, A3,
    -1, B3, D4, G4, D4, B3,
    -1, C4s, E4, G4, E4, C4s,
    -1, D4, F4s, B4, F4s, D4,
    -1, B3, D4, G4, D4, B3,
    -1, A3, D4, F4s, D4, A3,
    -1, A3, C4s, E4, C4s, A3,
    -1, F3s, A3, D4, A3, F3s,
    F4s, D4, A3, A4, F4s, D4, // normal inversion ending

    // chorus:
    -1, C4s, F4s, A4, F4s, C4s,
    -1, F4, G4s, B4, G4s, F4,
    -1, C4s, F4s, A4, F4s, C4s,
    -1, F4, G4s, B4, G4s, F4,
    -1, C4s, F4s, A4, F4s, C4s,
    -1, F4, G4s, B4, G4s, F4,
    -1, C4s, F4s, A4, F4s, C4s,
    -1, D4s, F4s, A4, F4s, D4s,
    -1, B3, E4, G4, E4, B3,
    -1, C4s, E4, G4, E4, C4s,

    // final verse ending variation:
    -1, B3, D4, G4, D4, B3,
    -1, A3, D4, F4s, D4, A3,
    -1, C4s, E4, A4, E4, C4s,
    -1, D4, F4s, A4, F4s, D4,
    D5, A4, F4s, F5s, D5, A4,
    D5, F5s, A5 // this is "rolled" in reality

  ],
  leftDur: [
    6/8,
  ],
  rightDur: [
    1/8,
  ],

  barAnnotations: {
    1: "(Intro)", 4:"(end of Intro)",
    5: "(verse 1) Wise", 6:"Men", 7:"Say", 8:"Only fools", 9:"Rush", 11:"in", 13:"But I",
    14:"Can't", 15:"Help", 16:"Falling", 17:"In love", 18:"With", 19:"you",

    21:"(Chorus) Like a river", 22:"Flows", 23:"Surely to the", 24: "Sea",
    25:"Darling so it", 26:"Goes", 27:"Some things", 29:"Were meant to", 30:"Be",

    31:"(Final verse alternative outtro)",
  },
  leftFingers: null,
  rightFingers: null,
  metrics: {HTQ: false, MetQ: false, DynQ: true, LegQ: false, StaQ: false}
});

presets.push({
  name: 'HRS', // The Animals
  category: 'repertoire',
  fullName: "House of the Rising Sun",
  beatsPerBar: 6,
  beatDur: 1/4,
  targetBPM: 220,
  maxBPM: 250,
  disconnectDur: 30, // disconnected notes, milliseconds
  graphOrder: "bar", // graph bar by bar instead of note by note

  leftHand: [
    // intro
    A2, E3, -1,   // Am
    C3, E3, -1,   // C
    D3, -1, -1,   // D
    F3, -1, -1,   // F
    A2, E3, -1,   // Am
    E2, E3, -1,   // E
    A2, E3, -1,   // Am
    E2, E3, -1,   // E

    // verse (starting at bar 9)
    A2, E3, -1,   // Am
    C3, E3, -1,   // C
    D3, -1, -1,   // D
    F3, -1, -1,   // F

    A2, E3, -1,   // Am
    C3, E3, -1,   // C
    E2, E3, -1,   // E
    E2, E3, -1,   // E

    A2, E3, -1,   // Am
    C3, E3, -1,   // C
    D3, -1, -1,   // D
    F3, -1, -1,   // F

    A2, E3, -1,   // Am
    E2, E3, -1,   // E

    A2, E3, -1,   // Am
    C3, E3, -1,   // C
    D3, -1, -1,   // D
    F3, -1, -1,   // F

    A2, E3, -1,   // Am
    E2, E3, -1,   // E
    A2, E3, -1,   // Am
    E2, E3, -1,   // E

    // outtro:

  ],
  rightHand: [
    // intro
    -1, -1, A3, C4, E4, C4, A3,   // Am
    -1, -1, G3, C4, E4, C4, G3,   // C
    -1, A3, D4, F4s, F4s, D4, A3, // D
    -1, A3, C4, F4, F4, C4, A3,   // F
    -1, -1, A3, C4, E4, C4, A3,   // Am
    -1, -1, G3s, B3, E4, B3, G3s, // E
    -1, -1, A3, C4, E4, C4, A3,   // Am
    -1, -1, G3s, B3, E4, B3, G3s, // E

    // verse

    -1, -1, A3, C4, E4, C4, A3,   // Am
    -1, -1, G3, C4, E4, C4, G3,   // C
    -1, A3, D4, F4s, F4s, D4, A3, // D
    -1, A3, C4, F4, F4, C4, A3,   // F

    -1, -1, A3, C4, E4, C4, A3,   // Am
    -1, -1, G3, C4, E4, C4, G3,   // C
    -1, -1, G3s, B3, E4, B3, G3s, // E
    -1, -1, G3s, B3, E4, B3, G3s, // E

    -1, -1, A3, C4, E4, C4, A3,   // Am
    -1, -1, G3, C4, E4, C4, G3,   // C
    -1, A3, D4, F4s, F4s, D4, A3, // D
    -1, A3, C4, F4, F4, C4, A3,   // F

    -1, -1, A3, C4, E4, C4, A3,   // Am
    -1, -1, G3s, B3, E4, B3, G3s, // E

    -1, -1, A3, C4, E4, C4, A3,   // Am
    -1, -1, G3, C4, E4, C4, G3,   // C
    -1, A3, D4, F4s, F4s, D4, A3, // D
    -1, A3, C4, F4, F4, C4, A3,   // F

    -1, -1, A3, C4, E4, C4, A3,   // Am
    -1, -1, G3s, B3, E4, B3, G3s, // E
    -1, -1, A3, C4, E4, C4, A3,   // Am
    -1, -1, G3s, B3, E4, B3, G3s, // E

    // Organ Solo (right hand only)

    E4, A4, E4, B4, E4, C5,

    D5, D5s, E5, // "crushed E5"
    D5, D5s, E5, // "crushed E5", finger sustain the second E5 using thumb

    D5, D5s, E5, // "crushed E5"
    D5, D5s, E5, // "crushed E5"

    D5s, D5, C5, A4,  // lick after crushed E's

    G4, G4s, A4, G4, A4, // the first three notes are a slide A4

    G6, G6s, A6,  // slide
    G6, G6s, A6,  // slide
    F6, F6s, G6,  // slide
    F6, F6s, G6,  // slide

    D5s, E5, G5,     D5s, E5, G5,    D5s, E5, G5,   D5s, E5, G5,
  ],
  leftDur: [
    1/4, 1/8, 9/8,
  ],
  rightDur: [
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,
    1/4, 1/8, 1/8, 1/4, 1/4, 1/4, 1/4,

    // organ solo
    1/8, 1/8, 1/8, 1/8, 1/8, 1/8, 1/8, 1/8,

    // crushed E5s:
    1/16, 1/16, 1/16,   1/16, 1/16, 1/16,  1/16, 1/16, 1/16,
    1/8, 1/8, 1/8, 1/8, 1/8, 1/8, 1/8,
        1/8, 1/8, 1/8, 1/8, 1/8, 1/8, 1/8,
            1/8, 1/8, 1/8, 1/8, 1/8, 1/8, 1/8,
                1/8, 1/8, 1/8, 1/8, 1/8, 1/8, 1/8,
                    1/8, 1/8, 1/8, 1/8, 1/8, 1/8, 1/8,
                        1/8, 1/8, 1/8, 1/8, 1/8, 1/8, 1/8,
                            1/8, 1/8, 1/8, 1/8, 1/8, 1/8, 1/8,
                                1/8, 1/8, 1/8, 1/8, 1/8, 1/8, 1/8,
                                    1/8, 1/8, 1/8, 1/8, 1/8, 1/8, 1/8,
                                        1/8, 1/8, 1/8, 1/8, 1/8, 1/8, 1/8,
  ],

  barAnnotations: {
    1: "(Intro)",
    9: "(Verse) There is",
    31: "Organ Solo",
  },
  leftFingers: null,
  rightFingers: null,
  metrics: {HTQ: false, MetQ: false, DynQ: true, LegQ: false, StaQ: false}
});

//console.log("Pushed songs");
presets.push("Free Play (non-scored)");
freePlayPresetIndex = presets.length-1;

presets.push("Debugging");

presets.push(  // a very simple pattern for debugging the software
  {
    name: 'TEST',
    category: 'test',
    leftHand: [C3, D3, E3, -1],
    rightHand: [C4, D4, E4, -1],
    leftDur: [1/4],
    rightDur: [1/4],
    beatDur: 1/4,
    beatsPerBar: 4,
    swingEighths: false,
    leftFingers: [5,4,3],
    rightFingers: [1,2,3],
    metrics: {HTQ: true, MetQ: true, DynQ: true, LegQ: true, StaQ: true},
  }
);
//console.log("Pushed test");
handlePresetSelection(presets.length-1); // this default makes it easier for me to test

presets.push(  // a trivial "scale" for debugging the software
  {
    name: 'SC.TEST',
    category: 'test',
    leftHand: [48, 50, 52, 50, 48],
    rightHand: [60, 62, 64, 62, 60],
    leftFingers: [5,4,3,4,5],
    rightFingers: [1,2,3,2,1],
    leftDur: [1/8],
    rightDur: [1/8],
    beatDur: 1/16,
    swingEighths: false,
    metrics: {HTQ: true, MetQ: true, DynQ: true, LegQ: true, StaQ: true},
    barAnnotations: {"1":"Scale-like test"},
  }
);
//console.log("Pushed sc.test");
presets.push(  // test of chords
  {
    name: 'CH.TEST',
    category: 'test',
    leftHand: [48, [50, 52, 54], 52, 48],
    rightHand: [60, 62, 64,],
    leftFingers: [5,4,3,4,5],
    rightFingers: [1,2,3,2,1],
    leftDur: [1/8, [1/8,1/2,1/4], 1/8, 1/8],
    rightDur: [1/4,1/4,1/8],
    beatDur: 1/8,
    swingEighths: false,
    metrics: {HTQ: true, MetQ: true, DynQ: true, LegQ: true, StaQ: true},
    barAnnotations: {"1":"chord test"},
  }
);


function createPresetMenu() {
    console.log("Creating Preset Menu");

    presets = presets.filter(preset => !preset.isFreePlay);

    // now add them at the freeplay index if we have an index.
    if (freePlayPresetIndex >= 0) {
      let insertplace = freePlayPresetIndex+1;
      for (let i = 0; i < freePlay.length; i++) {
        if (avail(freePlay[i].deleted, false)) {
          continue;
        }
        freePlay[i].menuValue = insertplace;
        presets.splice(insertplace, 0, freePlay[i]);
        insertplace++;
      }
    }

    const menuContainer = document.getElementById('presetMenuContainer');
    menuContainer.innerHTML = ''; // Clear existing content

    // The trigger for showing/hiding the menu
    const dropdownTrigger = document.createElement('div');
    dropdownTrigger.innerHTML = "<span style=font-size:medium>&#9660;</span>"; // Downward triangle
    dropdownTrigger.style.fontSize = "24px";
    dropdownTrigger.style.cursor = "pointer";
    dropdownTrigger.style.display = "inline-block";
    //dropdownTrigger.style.backgroundColor = "white";

    // The div to display the selected item
    const selectedItemDisplay = document.createElement('div');
    selectedItemDisplay.id = "selectedPresetDisplay";
    selectedItemDisplay.textContent = "Presets"; // Default text
    selectedItemDisplay.style.fontSize = "20px";
    selectedItemDisplay.style.minWidth = "10em";
    selectedItemDisplay.style.display = "inline-block";
    selectedItemDisplay.style.textAlign = "left";
    //selectedItemDisplay.style.backgroundColor = "white";
    selectedItemDisplay.style.marginLeft = "10px"; // Spacing between arrow and display

    // The menu itself
    const menuList = document.createElement('ul');
    menuList.style.display = 'none'; // Hidden by default
    menuList.style.listStyleType = 'none'; // No bullets
    menuList.style.margin = '0';
    menuList.style.position = 'absolute';
    menuList.style.padding = "5px";
    menuList.style.fontSize = "18px";
    menuList.style.backgroundColor = "#FFF";
    menuList.style.border = "1px solid #DDD";
    menuList.style.boxShadow = "0 8px 16px 0 rgba(0,0,0,0.2)";
    menuList.style.zIndex = "1000"; // Ensure it's above other content

    // Event listeners for showing/hiding the menu
    dropdownTrigger.addEventListener('click', presetDropdown);
    selectedItemDisplay.addEventListener('click', presetDropdown);

    function presetDropdown() {
        const rect = dropdownTrigger.getBoundingClientRect();
        menuList.style.left = `${rect.left}px`;
        menuList.style.top = `${rect.bottom}px`;
        menuList.style.display = menuList.style.display === 'none' ? 'block' : 'none';
    }

    // Hide menu when clicking anywhere outside
    document.addEventListener('click', function(e) {
        if (!dropdownTrigger.contains(e.target) && !menuList.contains(e.target)) {
            menuList.style.display = 'none';
        }
    }, true);

    let currentCategory = null;
    let indexCounter = -1; // Use this to track the index of each preset

    presets.forEach(function(preset) {
        indexCounter++; // Increment for each preset, including strings for categories
        if (typeof(preset) === "string") {
            // This is a category
            const categoryItem = document.createElement('li');
            categoryItem.style.paddingBottom = "5px";
            const toggleIndicator = document.createElement('span');
            toggleIndicator.textContent = '+';
            const catText = document.createElement('span');
            catText.textContent = " "+preset;
            categoryItem.appendChild(toggleIndicator);
            categoryItem.appendChild(catText);
            //categoryItem.style.fontWeight = "bold";
            categoryItem.style.cursor = "pointer";

            const nestedList = document.createElement('ul');
            nestedList.style.listStyleType = 'none';
            nestedList.style.paddingLeft = '20px';
            nestedList.style.paddingBottom = "10px";
            nestedList.style.display = 'none'; // Start hidden

            categoryItem.onclick = function() {
                // Toggle display of nestedList
                nestedList.style.display = nestedList.style.display === 'none' ? 'block' : 'none';
                toggleIndicator.textContent = (nestedList.style.display==='none')?"+":"-";
            };

            categoryItem.appendChild(nestedList);
            menuList.appendChild(categoryItem);
            currentCategory = nestedList;
        } else if (currentCategory) {
            // This is a preset item, which should be added to the current category
            const presetItem = document.createElement('li');
            presetItem.style.fontSize = "medium";
            presetItem.style.fontWeight = "medium";
            presetItem.style.padding = "5px";
            presetItem.innerHTML = avail(preset.menuName,preset.name);
            presetItem.style.cursor = "pointer";
            //preset.menuValue = index; // this makes it easier to go to a certain preset later and still update the menu to show that name
            // Use a closure to capture the current indexCounter value
            (function(index){
                presetItem.onclick = function() {
                    selectedItemDisplay.textContent = avail(preset.menuName,preset.name); // Update selected item display
                    menuList.style.display = 'none'; // Hide menu
                    handlePresetSelection(index); // Trigger code for preset selection, passing the index
                };
            })(indexCounter);

            currentCategory.appendChild(presetItem);
        }
    });

    menuContainer.style.backgroundColor = "white";
    menuContainer.appendChild(dropdownTrigger);
    menuContainer.appendChild(selectedItemDisplay);
    document.body.appendChild(menuList); // Append to body to ensure it overlays other elements
}

createPresetMenu(); // Initialize the menu




function resetPresetMenu() {
  presetMenu.selectedIndex = 0; // Set the selected index to the default option
}

function generateScalePreset(noteName, scaleType, numOctaves, lhOctave,
                                name = null, metrics = null, dur = [[1/4],[1/4]]) {

  const scaleIntervals = {
    maj: [0, 2, 4, 5, 7, 9, 11, 12],
    natMin: [0, 2, 3, 5, 7, 8, 10, 12],
    harMin: [0, 2, 3, 5, 7, 8, 11, 12],
    melMin: [0, 2, 3, 5, 7, 9, 11, 12], // we have to hack the fact that descending goes back to natMin
    melMinJ: [0, 2, 3, 5, 7, 9, 11, 12], // Jazz version of melodic minor doesn't change on descending
    chroma: [0,1,2,3,4,5,6,7,8,9,10,11,12],
    mixoBlues: [0, 2, 3, 4, 5, 6, 7, 9, 10, 12],
    majArp: [0,4,7],
    natMinArp: [0,3,7],
    majBlues: [0, 2, 3, 4, 7, 9, 12],
    minBlues: [0, 3, 5, 6, 7, 10, 12],
    majPent: [0, 2, 4, 7, 9, 12],
    minPent: [0, 3, 5, 7, 10, 12],
    dor: [0, 2, 3, 5, 7, 9, 10, 12],
    lyd: [0, 2, 4, 6, 7, 9, 11, 12],
    mixolyd: [0, 2, 4, 5, 7, 9, 10, 12],
    phryg: [0, 1, 3, 5, 7, 8, 10, 12],
    loc: [0, 1, 3, 5, 6, 8, 10, 12],
    aeo: [0, 2, 3, 5, 7, 8, 10, 12],
  };

  const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

  const fingerings = new Object();

  // The "standard" fingering applies to many different scales
  fingerings["C maj"] =
    fingerings["D maj"] =
    fingerings["E maj"] =
    fingerings["G maj"] =
    fingerings["A maj"] =
    fingerings["A natMin"] =
    fingerings["C natMin"] =
    fingerings["G natMin"] =
    fingerings["D natMin"] =
    fingerings["E natMin"] =
    fingerings["A harMin"] =
    fingerings["E harMin"] =
    fingerings["D harMin"] =
    fingerings["C harMin"] =
    fingerings["G harMin"] =
      [
        { start: [5,4,3,2,1], oct: [3,2,1,4,3,2,1], end: [3,2,1] },
        { start: [1,2,3], oct: [1,2,3,4,1,2,3], end: [1,2,3,4,5] }
      ];


  fingerings["B maj"] =
    fingerings["B natMin"] =
    [
      { start: [4,3,2,1], oct: [4,3,2,1,3,2,1], end: [4,3,2,1] },
      { start: [1,2,3], oct: [1,2,3,4,1,2,3], end: [1,2,3,4,5] }
    ];

  fingerings["C mixoBlues"] =
    fingerings["B natMin"] =
    [
      { start: [1,2,3,1,2,3], oct: [1,2,3,1,2,3,1,2,3], end: [1,2,3,4] },
      { start: [3,2,1,3,2,1], oct: [3,2,1,3,2,1,3,2,1], end: [3,2,1,3] }
    ];

    fingerings["C blues"] =
    [
      {start:[1,1,1,1,1,1], oct:[], end:[]},
      { start: [1,3,1,3,1,3], oct:[1,3,1,3,1,3], end:[4] }
    ]

  const label = name?name:`${noteName} ${scaleType} Scale (${numOctaves} Oct)`;
  let menuName = label.replace(/ \(\d+ Oct\)/g, '');
  menuName = menuName.replace(/Arp Scale$/g, ' Arpeggio');

  const typeMap = {
    "maj": "major scale",
    "natMin": "minor scale",
    "harMin": "harmonic minor scale",
    "melMin": "melodic minor scale",
    "majArp":"major arpeggio",
    "natMinArp":"minor arpeggio",
    "chroma":"chromatic scale",
  };

  const fullName = pronounceLetter(noteName) + avail(typeMap[scaleType], scaleType) + " " + numOctaves + " octave" +
    ((numOctaves===1)?"":"s");

  let fingers = fingerings[noteName+" "+scaleType];
  if (typeof fingers === "undefined") {
    fingers = null;
  }

  function pronounceLetter(letter) {
    letter = letter.replace("#", " sharp");
    return letter.slice(0,1)+". "+letter.slice(1);
  }

  const preset = {
    name: label,
    category: 'scaleArp',
    menuValue: -1, // not assigned yet
    menuName: menuName,
    leftHand: [],
    rightHand: [],
    leftFingers: null,
    rightFingers: null,
    metrics: {HTQ: true, MetQ: true, DynQ: true, LegQ: true, StaQ: false},
    fullName: fullName,
  };

  if (metrics !== null) {
    preset.metrics = metrics;
  }

  const arpmode = scaleType.includes("Arp");
  //console.log("arpmode="+arpmode);

  if (arpmode) {
    preset.beatsPerBar = 3;
    preset.targetBPM = 180;
  } else {
    preset.beatsPerBar = 4;
    preset.targetBPM = 240;
  }

  // Get the index of the starting note in the noteNames array
  const startNoteIndex = noteNames.indexOf(noteName);

  if (typeof scaleIntervals[scaleType] === "undefined" || scaleIntervals[scaleType] === null) {
    warning("No intervals found for scale type="+scaleType);
    return null;
  }

  // we allow the user to change the octave parameters on the fly using buttons
  // underneath the presets pulldown
  preset.allowOctaveChange = true;
  preset.octaveParams = {
    noteName:noteName,
    scaleType: scaleType,
    lhOctave: lhOctave,
    numOctaves: numOctaves
  };

  // Generate the scale notes for the specified number of octaves

  // first, ascending
  for (let octave = lhOctave; octave <= lhOctave + numOctaves - 1; octave++) {
    for (let i = ((arpmode||(octave===lhOctave))?0:1); i < scaleIntervals[scaleType].length; i++) {
      const noteIndex = (startNoteIndex + scaleIntervals[scaleType][i]);
      const noteNumber = (octave+1) * 12 + noteIndex;
      preset.leftHand.push(noteNumber);
      preset.rightHand.push(noteNumber+12);
    }
  }

  if (arpmode) {
    // arpeggios usually play the tonic one beyond the top octave
    const noteIndex = (startNoteIndex + scaleIntervals[scaleType][0]);
    const noteNumber = (lhOctave+numOctaves+1) * 12 + noteIndex;
    preset.leftHand.push(noteNumber);
    preset.rightHand.push(noteNumber+12);
  }

  // then, descending. In arpeggio mode do not include the very last note
  // because arpeggios are typically practiced by 'cycling' which does not
  // repeat the first note after the end note is played

  // Also, if this is a melodic minor scale, descending substitutes the
  // natural minor. If you don't want that, use melMinJ (Jazz version)

  if (scaleType === 'melMin') {
    scaleType = 'natMin';
  }
  for (let octave = lhOctave+numOctaves-1; octave >= lhOctave; octave--) {
    for (let i = scaleIntervals[scaleType].length-(arpmode?1:2); i >= 0; i--) {
      if (arpmode && octave === lhOctave && i === 0) {
        break; // arpeggios "cycle"
      }
      const noteIndex = (startNoteIndex + scaleIntervals[scaleType][i]);
      const noteNumber = (octave+1) * 12 + noteIndex;
      preset.leftHand.push(noteNumber);
      preset.rightHand.push(noteNumber+12);
    }
  }

  if (fingers) {
    preset.leftFingers = [];
    preset.rightFingers = [];

    // ASCENDING

    // start sequences
    for (let i = 0; i < fingers[0].start.length; i++) {
      preset.leftFingers.push(fingers[0].start[i]);
    }
    for (let i = 0; i < fingers[1].start.length; i++) {
      preset.rightFingers.push(fingers[1].start[i]);
    }

    // extra octaves
    for (let oct = numOctaves-1; oct > 0; oct--) {
      for (let i = 0; i < fingers[0].oct.length; i++) {
        preset.leftFingers.push(fingers[0].oct[i]);
      }
      for (let i = 0; i < fingers[1].oct.length; i++) {
        preset.rightFingers.push(fingers[1].oct[i]);
      }
    }

    // end sequences
    for (let i = 0; i < fingers[0].end.length; i++) {
      preset.leftFingers.push(fingers[0].end[i]);
    }
    for (let i = 0; i < fingers[1].end.length; i++) {
      preset.rightFingers.push(fingers[1].end[i]);
    }

    // DESCENDING

    // end sequences
    for (let i = fingers[0].end.length-2; i >= 0; i--) {
      preset.leftFingers.push(fingers[0].end[i]);
    }
    for (let i = fingers[1].end.length-2; i >= 0; i--) {
      preset.rightFingers.push(fingers[1].end[i]);
    }

    // extra octaves
    for (let oct = numOctaves-1; oct > 0; oct--) {
      for (let i = fingers[0].oct.length-1; i >= 0; i--) {
        preset.leftFingers.push(fingers[0].oct[i]);
      }
      for (let i = fingers[1].oct.length-1; i >= 0; i--) {
        preset.rightFingers.push(fingers[1].oct[i]);
      }
    }

    // start sequences
    for (let i = fingers[0].start.length-1; i >= 0; i--) {
      preset.leftFingers.push(fingers[0].start[i]);
    }
    for (let i = fingers[1].start.length-1; i >= 0; i--) {
      preset.rightFingers.push(fingers[1].start[i]);
    }

  }

  if (dur) {
    preset.rightDur = avail(dur[0], [1/4]);
    preset.leftDur = avail(dur[1], [1/4]);
    preset.beatDur = avail(dur[2], 1/4);
    preset.swingEighths = avail(dur[3], false);
  } else {
    // use defaults
    preset.rightDur = [1/4];
    preset.leftDur = [1/4];
    preset.beatDur = 1/4;
    preset.swingEighths = false;
  }

  //console.log("At end of preset push of "+label);
  return preset;
}


function isChord(note) {
  if (Array.isArray(note)) {
    return note.length;
  } else {
    return 0;
  }
}

    // Function to set the notes to be played
    function setNotes() {
      currentState = STATE.SETTING_NOTES;
      console.log("State: setting notes");
      notesToPlay = [[], []]; // reset
      fingersToPlay = null;

      //document.getElementById("testname").textContent = "Custom Notes";

      resetPresetMenu();

      updateSelectableHands(true, true, false);
      changeSelectedHand('right');

      // Prompt the user to play notes
      message('Play notes for later test');

      // Disable setNotes button and enable doneButton
      //document.getElementById('setNotesButton').disabled = true;
      document.getElementById('testNotesButton').disabled = true;
      //document.getElementById('doneButton').disabled = false;

      // Clear the notesToPlay on screen
      clearNotesToPlay();

      // Clear the displayed played notes to start new test
      playedNotes = [[], []];
      clearPlayedNotes();

      // Reset the wrongNotePlayed flag
      wrongNotePlayed = false;
      wrongNoteNumber = -1;
      currentHand = 'left';
    }

    // Function to test the notes repetition
    function testNotes() {
      let button = document.getElementById('testNotesButton');
      document.body.style.backgroundColor = bodyColor;

      if (currentState === STATE.TESTING_NOTES || currentState === STATE.TEST_FLUSHING) {
        currentState = STATE.WAITING_FOR_BUTTON;

        // This is really the STOP button, end the test.

        // Enable setNotes button and disable doneButton
        //document.getElementById('setNotesButton').disabled = false;
        //document.getElementById('doneButton').disabled = true;
        endTest(); // stop the timer
        button.textContent = "START";
        document.getElementById("timerPauseButton").style.display = "none";
        scrollToDataTop(false);
        playedNotes = [[], []];
        clearPlayedNotes();
        return;
      }

      if (testOptions.isFreePlay) {
        // there is no such thing as testing a freeplay item other than to start
        // the timer and occassionally update the time to the runHistory
        clearStats();
        startTest();
        currentState = STATE.TESTING_NOTES;
        //document.getElementById("PresetMenu").disabled = true; // can't change during test
        disablePresetMenu();
        return;
      }
      //document.getElementById("PresetMenu").disabled = false; // can't change during test
      disablePresetMenu();

      // if we get here we need to start a test sequence.
      clearStats();
      setNoteFilters();
      loadTodayStats();
      setFavoriteIcon(false); // there is no selection

      if (notesToPlay[0].length === 0 && notesToPlay[1].length === 0) {
        message("There are no notes to test");
        return;
      }
      currentState = STATE.TESTING_NOTES;
      console.log("State: testing");

      // document.getElementById('setNotesButton').disabled = true;
      // enable both hands mode
      updateSelectableHands(true, true, true);

      // Clear the displayed played notes during the test phase
      clearPlayedNotes();

      startTest();

      scrollToDataTop(true);

    }

    function disablePresetMenu() {
      const pm = document.getElementById("presetMenuContainer");
      pm.style.pointerEvents = "none";
      pm.style.opacity = "0.4";
      pm.title = "Presets menu disabled during test.";
    }

    function enablePresetMenu() {
      const pm = document.getElementById("presetMenuContainer");
      pm.style.pointerEvents = "auto";
      pm.style.opacity = "0.7";
      pm.title = "Select a set of test notes to play";
    }

    function historyNameModifier() {
      let hnm = "";
      if (noteScope === null) {
        return hnm;
      }
      const hand = getSelectedHand();
      let startbeat = 0;
      let endbeat = 0;
      let startbar;
      let endbar;

      if (hand === "left") {
        startbeat = noteStartBeat[0][noteScope[0].first];
        endbeat = noteStartBeat[0][noteScope[0].last];
      } else if (hand === "right") {
        startbeat = noteStartBeat[1][noteScope[1].first];
        endbeat = noteStartBeat[1][noteScope[1].last];
      } else {
        startbeat = Math.min(noteStartBeat[0][noteScope[0].first],noteStartBeat[1][noteScope[1].first]);
        endbeat = Math.max(noteStartBeat[0][noteScope[0].last],noteStartBeat[1][noteScope[1].last]);
      }
      startbar = 1+Math.trunc(startbeat/testOptions.beatsPerBar);
      endbar = 1+Math.trunc(endbeat/testOptions.beatsPerBar);

      //warning("Mod: startbar:"+startbar+" endbar:"+endbar+" maxbar:"+maxBar);

      if (isNaN(startbar) || isNaN(endbar)) {
        alert("Bar range is NaN:"+startbar+":"+endbar);
        hnm = "";
      } else if (startbar === 1 && endbar === maxBar) {
        hnm = "";  // it's everything anyway
      } else if (startbar === endbar) {
        hnm = " B"+startbar;
      } else {
        hnm = " B"+startbar+"-"+endbar;
      }
      //warning("Returning hnm='"+hnm+"'");

      if (testOptions.constDur !== false && testOptions.constDur !== testOptions.originalConstDur) {
        hnm += " C="+testOptions.constDur;
      }
      if (testOptions.beatsPerBar !== testOptions.originalBeatsPerBar) {
        hnm += " BPB="+testOptions.beatsPerBar;
      }
      if (testOptions.beatDur !== testOptions.originalBeatDur) {
        hnm += " BD="+testOptions.beatDur;
      }

      return hnm;
    }

    // show activity today (or any day in the past)

    function dayChartDate(days) {
      console.log("Adjusting dayChart Date by " + days);

      // Get 'today' but reset time to start of the day for comparison
      const today = new Date();
      today.setHours(23, 59, 59, 999);

      // Get the current date from the picker, without time
      const datePicker = document.getElementById("dayChartDatePicker");
      const currentDate = datePicker.value; // YYYY-MM-DD format

      // Create a new date object based on the current date picker value
      let current = new Date(currentDate);
      current.setHours(23, 59, 59, 999); // Ensure time is at start of day to avoid timezone issues

      // Create a new date representing the adjusted date
      let adjustedDate = new Date(current);
      adjustedDate.setDate(adjustedDate.getDate() + days);

      // Comparison to ensure adjustedDate does not exceed 'today'
      if (adjustedDate <= today) {
        datePicker.value = adjustedDate.toISOString().split('T')[0];
        computeDayChart();
      } else {
        console.log("Adjusted date exceeds the current date. No change applied.");
      }
    }

    function setDayChartNote(date) {
        const text = avail(runHistory[".PREF.DAYCHARTNOTE."+date], "");
        document.getElementById("dayChartNoteTextArea").value = text;
        document.getElementById("dayChartNoteDisplay").innerHTML = text;
    }

    function computeDayChart() {
      console.log("###computeDayChart");

      const statsTable = document.getElementById("dayChartOverviewTable");

      const today = document.getElementById("dayChartDatePicker").value; //getToday(); // in yyyy-mm-dd format

      console.log("DAY CHART FOR DAY="+today);

      setDayChartNote(today);

      if (runHistory === null) {
        loadRunHistory();
      }
      // find all the runs that happened today

      let pr = "";  // will contain all the html for the chart.
      let qualCounts = {};
      let timeCats = { // track different categories of practice time
        scaleArp: 0,
        drill: 0,
        repertoire: 0,
        freePlay: 0,
        misc: 0
      };

      let totals = {
        elapsed: 0,
        reps: 0,
        fail: 0,
        freereps: 0
      }

      for (const key in runHistory) {
        if (!runHistory.hasOwnProperty(key)) {
          continue;
        }
        if (key.startsWith(".PREF.")) {
          //console.log("Skipped PREF:"+key);
          continue;
        }

        if (runHistory[key].reps < 3 || runHistory[key].elapsed < 10000) {
          // this is usually just an error like selected wrong number of octaves and didn't realize it
          continue;
        }

        const [date, preset, hand] = key.split("|");

        //console.log("DAYCHART date=["+date+"]");

        if (date !== today) {
          continue;
        }
        //console.log("DAYCHART FOUND A RECORD");
        if (runHistory[key].isFreePlay) {
          // free play items have far less data
          pr += "<tr style=text-align:center>";
          pr += "<td style=text-align:left;background-color:beige>"+preset+"</td>";
          pr += "<td></td>";
          const elapse = Number((runHistory[key].elapsed/1000).toFixed(1));
          totals.elapsed += elapse;
          totals.freereps += runHistory[key].count;

          const fp = freePlay.find(item => item.name === preset.replace("Free Play:",""));
          console.log("Looking up freeplay item:"+preset+" result:"+fp+" "+avail(fp.category,"unknown cat"));
          if (isAvail(fp)) {
            timeCats[fp.category] += elapse;
          } else {
            timeCats.freePlay += elapse;
          }

          pr += "<td>"+(formatTime(elapse))+"</td>";
          pr += "<td></td><td></td><td>"+runHistory[key].count+
            "</td><td></td><td></td><td></td><td></td><td></td>";
          pr += "</tr>";

          continue;
        }

        const acc = Math.trunc(100*runHistory[key].success/(runHistory[key].count));
        const streak = runHistory[key].maxStreak[2];
        const streakbpm = Math.trunc(0.5+avail(runHistory[key].maxStreakBPM[2],0)/(0.001+avail(runHistory[key].maxStreak[2],1)));
        const avgbpm = Math.trunc(runHistory[key].sumBPM/runHistory[key].count);
        const maxbpm = Math.trunc(runHistory[key].maxBPM);
        const bestbpm = Math.trunc(runHistory[key].bestBPM);
        const targetbpm = avail(runHistory[key].targetBPM, findTargetBPM(preset));

        totals.reps += runHistory[key].success;
        totals.fail += runHistory[key].notefail;

        let presetNoOct = preset;
        if (presetNoOct.endsWith(' Oct)')) {
          presetNoOct = presetNoOct.slice(0,-8);
        }
        presetNoOct = presetNoOct.replace(/ B[0-9]+(-[0-9]+)?$/, '');
        let pcat = presets.find(item =>
                typeof item !== 'string' && item.name && item.name.startsWith(presetNoOct));
        let cat = pcat?avail(pcat.category,"misc"):"misc";
        console.log("PRESETFIND: initial cat="+cat+" for preset=/"+presetNoOct+"/");

        const schedule = avail(runHistory[".PREF.LEARNINGSCHEDULE."+stripPresetModifiers(preset)], "begin");

        let evals = evaluateSessionStats(acc, streak, streakbpm,
                      avgbpm, maxbpm, bestbpm, targetbpm,
                      0, schedule, avail(runHistory[key].maxStreakAtEnd[2],false));

        pr += "<tr style=text-align:center>";
        pr += "<td style=text-align:left;color:"+evals.overallColor+
                ";background-color:"+evals.overallBGColor+";font-weight:"+evals.overallEmph+">"+
                evals.overallSymbol+preset+"</td>";
        pr += "<td>"+hand+"</td>";

        let elapse = Number((runHistory[key].elapsed/1000).toFixed(1));
        // To be fair as far as estimated effective practice time, you have to give the learner
        // a reasonable amount of rest time between runs. We will estimate this as 3 beats (per run) and use
        // averageBPM as the measure of the length of these beats.
        if (avail(avgbpm,0) > 0) {
          console.log("Elapse before rest:"+elapse);
          elapse += 3*Number(runHistory[key].count)*(60/avgbpm); // rest time allowed between runs
          console.log("Added rest time:"+elapse);
        }
        elapse = Number(elapse);
        totals.elapsed += elapse;

        if (!isAvail(timeCats[cat])) {
          timeCats[cat] = 0;
        }
        timeCats[cat] += elapse;
        //console.log("PRESETFIND: timecat using:"+cat+" timeCats[cat]="+timeCats[cat]);

        pr += "<td>"+(formatTime(elapse))+"</td>";
        pr += "<td style=color:"+evals.accColor+">"+acc+"%</td>";
        pr += "<td style=color:"+evals.streakColor+">"+runHistory[key].maxStreak[2]+" @ ";
        pr += "<span style=color:"+evals.streakbpmColor+">"+streakbpm+"</span></td>";
        pr += "<td>"+runHistory[key].success+"</td>";
        pr += "<td>"+runHistory[key].notefail+"</td>";
        pr += "<td><span style=color:"+evals.avgbpmColor+">"+avgbpm+"</span></td>";
        pr += "<td><span style=color:"+evals.maxbpmColor+">"+runHistory[key].maxBPM+"</span></td>";
        pr += "<td><span style=color:"+evals.bestbpmColor+">"+runHistory[key].bestBPM+"</span></td>";
        pr += "<td>"+targetbpm+"</td>";

        pr += "</tr>";

        if (!isAvail(qualCounts[evals.overallColor])) {
          qualCounts[evals.overallColor] = {
            count: 0,
            strikes: evals.overallStrikes,
            symbol: evals.overallSymbol,
            label: evals.overallLabel
          }
        }
        qualCounts[evals.overallColor].count++;

      }  // end of for key in runHistory

      if (totals.elapsed == 0) {
        pr = "<tr><td colspan=11><div style=padding:20px;font-size:x-large><em>There is no practice data on the chosen date.</em></div></td></tr>";
      } else {
        // totals row
        pr += "<tr style=font-weight:bold;text-align:center;background-color:beige><td colspan=2 style=text-align:left>Totals:</td><td>"+formatTime(avail(totals.elapsed,0))+"</td>";

        if (totals.reps === 0 && totals.freereps > 0) {
          pr += "<td style=border:none></td>";
          pr += "<td style=border:none></td><td>"+(totals.freereps)+"</td><td colspan=5 style=border:none></td>";
        } else {
          pr += "<td>"+Math.trunc(0.5+100*totals.reps/(totals.reps+totals.fail+0.000001))+"%</td>";
          pr += "<td style=border:none></td><td>"+(totals.reps+totals.freereps)+"</td><td>"+totals.fail+"</td><td colspan=4 style=border:none></td>";
        }

        pr += "<tr>";
      }

      document.getElementById("dayChartTbody").innerHTML = pr;

      const timesum = document.getElementById("dayChartTimeSummaryDiv");

      if (totals.elapsed != 0) {
        pr = "<strong>Total&nbsp;Time: "+formatTime(totals.elapsed)+"</strong><br><br>";
        pr += "<table id=dayChartTimeSummary border=1 >";
        pr += "<tr style=border:none><th colspan=2>Time Breakdown</th></tr>";
        if (timeCats['scaleArp'] !== 0) {
          pr += "<tr style=border:none><td style=border:none>Scales/Arps:</td><td style=border:none;text-align:right>"+formatTime(timeCats['scaleArp'])+"</td></tr>";
        }
        if (timeCats['drill'] !== 0) {
          pr += "<tr style=border:none><td style=border:none>Other Drills:</td><td style=border:none;text-align:right>"+formatTime(timeCats['drill'])+"</td></tr>";
        }
        if (timeCats['repertoire'] !== 0) {
          pr += "<tr style=border:none><td style=border:none>Repertoire:</td><td style=border:none;text-align:right>"+formatTime(timeCats['repertoire'])+"</td></tr>";
        }
        if (timeCats['freePlay'] !== 0) {
          pr +=   "<tr style=border:none><td style=border:none>Misc. Free Play:</td><td style=border:none;text-align:right>"+formatTime(timeCats['freePlay'])+"</td></tr>";
        }
        if (timeCats['misc'] !== 0) {
          pr += "<tr style=border:none><td style=border:none>Misc:</td><td style=border:none;text-align:right>"+formatTime(timeCats['misc'])+"</td></tr>";
        }
        //pr += "<tr style=border:none><th style=border:none>Total Time:</th><th style=border:none;text-align:right>"+formatTime(totals.elapsed)+"</th></tr>"+
        pr += "</table>";
        timesum.innerHTML = pr;
      } else {
        if (timesum) {
          timesum.innerHTML = '';
        }
      }

      pr = "<tr>";
      let totqual = 0;
      for (const key in qualCounts) {
        if (qualCounts.hasOwnProperty(key)) {
          totqual += qualCounts[key].count;
        }
      }
      //console.log("Totqual="+totqual);

      const arr = Object.keys(qualCounts).map(key => {
        return {
          key:key,
          count: qualCounts[key].count,
          strikes: qualCounts[key].strikes,
          symbol: qualCounts[key].symbol,
          label: qualCounts[key].label
        };
      });

      arr.sort((a,b) => a.strikes-b.strikes);

      const piedata = {
        datasets: [
          {
            data: [],
            backgroundColor: []
          }
        ]
      };

      for (let i = 0; i < arr.length; i++) {
        if (arr[i].count == 0) {
          continue;
        }

        piedata.datasets[0].data.push(arr[i].count);

        pr += "<tr style=border:none><td style=border:none;background-color:"+arr[i].key+";width:1.5em;text-align:center><span style=color:white>"+ arr[i].symbol + "</span></td>"+
              "<td style=border:none;color:"+arr[i].key+">"+arr[i].label+"</td>"+
              "<td style=border:none>"+arr[i].count+"</td>"+
              "<td style=border:none>("+
              Math.trunc(100*arr[i].count/totqual)+
              "%)</td></tr>";

        piedata.datasets[0].backgroundColor.push(arr[i].key);

      }
      statsTable.innerHTML = pr;

      // pie chart of results

      const piecanvas = document.getElementById("dayChartPieCanvas");
      const ctx = piecanvas.getContext("2d");

      if (dayChartPie !== null) {
        dayChartPie.destroy();
      }

      console.log("Creating daychart pie");
      dayChartPie = new Chart(ctx, {
        type: 'pie',
        data: piedata,
      });



    } // end of computeDayChart()


    function evaluateSessionStats(acc, streak, streakbpm, avgbpm, maxbpm, bestbpm, targetbpm, age=0, schedule="begin", maxStreakAtEnd=false) {
      // this structure shows colors and "strikes" to display on the
      // daychart and skillmap pages.
      const evalColors = {
        "Superb!": "#005500",
        "Excellent":"green",
        "Good":"blue",
        "Defficient":"orange",
        "Fail":"red",
      };

      const evals = {
        overallStrikes: 0,
        overallColor: "",
        overallBGColor: "transparent",
        overallSymbol: "",
        overallEmph: "medium",
        overallLabel: "",
        accStrikes: 0,
        accColor: "",
        streakStrikes: 0,
        streakColor: "",
        streakbpmColor: 0,
        avgbpmColor: "",
        maxbpmColor: "",
        ageStrikes: 0,
        ageColor: ""
      };

      evals.streakbpmColor = bpmcolor(streakbpm, targetbpm);
      evals.avgbpmColor = bpmcolor(avgbpm, targetbpm);
      evals.maxbpmColor = bpmcolor(maxbpm, targetbpm);
      evals.bestbpmColor = bpmcolor(bestbpm, targetbpm);

      if (acc === 100) {
        evals.accStrikes = 0;
        evals.accColor = evalColors["Superb!"]; // very dark green
      } else if (acc > 90) {
        evals.accStrikes = 1;
        evals.accColor = evalColors["Excellent"];
      } else if (acc >= 85) {
        evals.accStrikes = 2;
        evals.accColor = evalColors["Good"];
      } else if (acc >= 80) {
        evals.accStrikes = 3;
        evals.accColor = evalColors["Defficient"];
      } else {
        evals.accStrikes = 4;
        evals.accColor = evalColors["Fail"];
      }

      if (acc === 100) {
        // with 100% accuracy we are more lenient with the streaks, allowing the learner to
        // do a quick refresh with fewer streaks as long as they make no errors.
        if (streak > 9) {
          evals.streakStrikes = 0; // this allows a "star"
          evals.streakColor = evalColors["Excellent"];
        } else if (streak > 6) {
          evals.streakStrikes = 1;
          evals.streakColor = evalColors["Excellent"];
        } else if (streak >= 5) {
          evals.streakStrikes = 2;
          evals.streakColor = evalColors["Good"];
        } else {
          evals.streakStrikes = 3;
          evals.streakColor = evalColors["Defficient"]; // it would be hard to say that any day of 100% accuracy is "Fail" so the worst is defficient
        }
      } else {
        // if accuracy is under 100% we're more strict with streaks, encouraging learner to
        // continue practicing a bit longer
        if (streak > 9) {
          evals.streakStrikes = 0;
          evals.streakColor = evalColors["Excellent"];
        } else if (streak > 8) {
          evals.streakStrikes = 1;
          evals.streakColor = evalColors["Good"];
        } else if (streak >= 7) {
          evals.streakStrikes = 2;
          evals.streakColor = evalColors["Defficient"];
        } else {
          evals.streakStrikes = 3;
          evals.streakColor = evalColors["Fail"];
        }
      }

      // IMPLEMENT: when extended for skillmap we will add eval of age in days, which will depend on
      // the learning schedule

      const lsched = avail(learningScheduleDayParams[schedule], [4, 7, 14]);

      if (age < lsched[0]) {
        evals.ageStrikes = 0;
        evals.ageColor = evalColors["Excellent"];
      } else if (age <= lsched[1]) {
        evals.ageStrikes = 1;
        evals.ageColor = evalColors["Good"];
      } else if (age < lsched[2]) {
        evals.ageStrikes = 2;
        evals.ageColor = evalColors["Defficient"];
      } else {
        evals.ageStrikes = 3;
        evals.ageColor = "red";
      }

      // compute an overall evaluation
      let strikes = evals.streakStrikes + evals.accStrikes;

      if (streak > 19 && maxStreakAtEnd) {
        // credit back one strike if there is a very long streak that ended the session.
        strikes -= 1;
        if (strikes < 0) {
          strikes = 0;
        }
      }

      evals.overallStrikes = strikes;
      if (strikes === 0) {
        evals.overallColor = "#005500"; // very dark green
        evals.overallBGColor = "#DDFBDD";
        evals.overallSymbol = "&starf;";
        evals.overallEmph = "bold";
        evals.overallLabel = "Superb!";
      } else if (strikes === 1) {
        evals.overallColor = "green";
        evals.overallLabel = "Good";
      } else if (strikes === 2) {
        evals.overallColor = "blue";
        evals.overallLabel = "Passing";
      } else if (strikes === 3) {
        evals.overallColor = "orange";
        evals.overallLabel = "Defficient";
      } else {
        evals.overallColor = "red";
        evals.overallBGColor = "#FBDDDD"; // pale red
        evals.overallSymbol = "&#9888;";  // warning sign, exclamation point inside a triangle
        evals.overallEmph = "bold";
        evals.overallLabel = "Fail";
      }

      return evals;

      function bpmcolor(bpm, target) {
          bpm = Number(bpm);
          target = Number(target);
          //console.log("BPMCOLOR: bpm:"+bpm+" targ:"+target);

          if (bpm == 0) {
            return "black";
          }
          if (bpm > target*1.1) {
            return "darkgreen";
          } else if (bpm >= target) {
            return "green";
          } else if (bpm/target > 0.85) {
            return "blue";
          } else if (bpm/target > 0.65) {
            return "orange";
          } else {
            return "red";
          }
        } // end of bpmcolor
    } // end of evaluateSessionStats

    function findTargetBPM(name) {
      for (let i = 0; i < presets.length; i++) {
        //console.log("Comparing preset name:"+name+" to "+presets[i].name);
        // IMPLEMENT: The comparison below isn't quite right, we should really pattern match for
        // name plus a possible trailing bar range (like B3-8) or hand specifier (like both or left)
        // The code below works as long as no preset name is a leading substring of another, which is
        // currently true but may not always be.
        if (name.startsWith(presets[i].name)) {
          //console.log("MATCH");
          return avail(presets[i].targetBPM,120);
        }
      }
      return 120; // this is just a default
    }

    function generateSkillMap() {
      console.log("####generateSkillMap");

      const recentHistory = []; // will hold last 30 days of stats organized by date
      const scaleData = [];
      const repData = {};
      const drillData = {};
      const freeplayData = {};
      const count = {}; // count which scales/arps were actually practiced

      if (runHistory === null) {
        loadRunHistory();
      }
      // generate a hash of recent dates data only (past 30 days)
      // this will speed things up considerably and allows looking at most recent
      // days first.
      //const date30 = todayDate(30); // a formatted string for 30 days ago in the format that runHistory keys use
      const latestDate = {}; // keep track of the latest date data found

      for (const key in runHistory) {
        if (!runHistory.hasOwnProperty(key)) {
          continue;
        }
        if (key.startsWith(".PREF.")) {
          //console.log("Skipped PREF:"+key);
          continue;
        }

        const [date, preset, hand] = key.split("|");

        let datekey = preset;
        if (datekey.endsWith(' Oct)')) {
          datekey = datekey.slice(0,-7);
        }

        /*************
        if (date < date30) {
          // date too old to matter for skill map
          continue;
        }
        *************/

        let needdatewipe = false;

        if (avail(latestDate[datekey],"2000-01-01") > date) {
          // already have a later date
          continue;
        } else if (avail(latestDate[datekey],"2000-01-01") < date) {
          // in this case you have to wipe out any prior octave based data for
          // this preset as they are all earlier dates.
          //console.log("Latest preset date:"+latestDate[datekey]+" for preset:/"+preset+"/ is less than "+date)
          needdatewipe = true;
        } else {
          // the current date is equal to prior dates for the current preset so
          // if it's a different octave that's ok, they're the same date
        }

        latestDate[datekey] = date;

        const p = "^(.*?)( B([0-9]+)(-([0-9]+))?)?$";
        const pattern = new RegExp(p);

        // IMPLEMENT: for now we'll just hard code some common ones, but a better method would be to
        // go through all the possible scales and find the ones that exist in the runhistory, then suppress
        // rows for ones that have no examples.
        if (preset.includes(" maj Scale ") || preset.includes(" natMin Scale ")
            || preset.includes(" chroma Scale ") || preset.includes(" minBlues Scale")
            || preset.includes(" majArp ") || preset.includes(" natMinArp ")) {

            let [tonic, sctype, scale, numoct, oct] = preset.split(" ");
            numoct = Number(numoct.substr(1));

            //console.log(date+" Found "+sctype+" Scale:"+tonic+" oct:"+numoct);

            if (!isAvail(scaleData[sctype])) {
              scaleData[sctype] = [];
              needdatewipe = false; // it's new anyway, there's no prior data
              //console.log("NEW: Scale:"+tonic+" oct:"+numoct)
            }
            if (!isAvail(scaleData[sctype][tonic]) || !isAvail(scaleData[sctype][tonic][numoct]) ||
                date > scaleData[sctype][tonic][numoct].date) {
              //console.log("Found later data for Scale:"+tonic+" "+sctype+" oct:"+numoct+" needwipe:"+needdatewipe);
              if (!isAvail(scaleData[sctype][tonic]) || needdatewipe) {
                //console.log("Wiping data Scale:"+tonic);
                scaleData[sctype][tonic] = [];
              }
              //console.log("Adding octave:"+numoct+" Scale:"+tonic);
              if (isAvail(scaleData[sctype][tonic][numoct]) && hand !== 'both') {
                continue; // we already have data with both hands for this octave
              }
              console.log("Adding scale/arp"+preset);
              scaleData[sctype][tonic][numoct] = {
                preset: preset,
                date: date,
                octaves: numoct,
                hand: hand,
                days: daysSince(date),
                hist: runHistory[key]
              };
            }

          } else if (runHistory[key].isFreePlay === true) {
            console.log("Adding freeplay "+preset);
            freeplayData[preset] = {
              preset: preset,
              description: freePlayDescription(preset.replace(/^Free Play:/,'')),
              name: preset.replace(/^Free Play:/,''),
              noteScopeList: "-1,-1,-1,-1",
              date: date,
              prefname: ".PREF." + preset,
              days: daysSince(date),
              hist: runHistory[key]
            };

          } else { // not a scale or arp

            // repertoire items and drills
            let m = preset.match(pattern);
            if (m) {
              //console.log("Found repertoire item:"+preset+"match="+m+"="+m.length+"/0="+m[0]+"/1="+m[1]+"/2="+m[2]+"/3="+m[3]+"/4="+m[4]);
              if (runHistory[key].count < 5) {
                // too few reps to count as a practice session
                continue;
              }
              if (!isAvail(repData[m[1]])) {
                repData[m[1]] = {};
              }
              //console.log("M1=/"+m[1]+"/");
              if (m[1].startsWith("TEST")) {
                // don't display programming tests
                //console.log("M1 SKIPPED, TEST");
                continue;
              }

              const precat = presetCategory(m[1]);

              if (precat !== "repertoire") {
                console.log("Adding drill "+preset+" cat:"+precat);
                const dayssince = daysSince(date);
                //console.log("Logging M1");
                if (isAvail(drillData[preset]) && drillData[preset].hand === 'both' &&
                    drillData[preset].days === daysSince && hand !== 'both') {
                  continue;  // already have a both-hands version of this drill
                }
                drillData[preset] = {
                  preset: preset,
                  name: preset,
                  hand: hand,
                  barRange: "", // drills are considered things generally practiced as a unit, at least mostly
                  noteScopeList: "-1,-1,-1,-1",
                  date: date,
                  prefname: ".PREF." + preset,
                  days: daysSince(date),
                  hist: runHistory[key]
                };
                continue;
              }

              if (isAvail(repData[m[1]][m[2]]) && hand !== 'both') {
                continue; // already have a both hands version of this item
              }

              console.log("Adding repertoire "+preset);
              let ns = runHistory[key].noteScope;
              if (!isAvail(ns)) {
                ns = [{first:-1, last:-1}, {first:-1, last:-1}];
              }
              //console.log("Logging M1");
              repData[m[1]][m[2]] = {
                preset: preset,
                name: m[1],
                hand: hand,
                barRange: (isAvail(m[2])?m[2].substring(1):null), // strip off the leading space
                noteScopeList: ns[0].first+","+
                                ns[0].last+","+
                                ns[1].first+","+
                                ns[1].last,
                date: date,
                prefname: ".PREF." + m[1] + " " + m[2],
                days: daysSince(date),
                hist: runHistory[key]
              };
            } // end of: if (m)
          }
        }

        // load data into the table
        const sctab = document.getElementById("skillMapTable");
        const tonics = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
        const scales = ["maj", "natMin", "chroma", "minBlues", "majArp", "natMinArp"];
        const rows = {};

        // IMPLEMENT: This should really drive off a table, preferably one of the tables that are already
        // in repiano that list different kinds of scales and arps

        rows["maj"] = "<tr style=font-size:small><th style=background-color:darkgray;color:white;text-align:left>Major</th>";
        rows["natMin"] = "<tr style=font-size:small><th style=background-color:darkgray;color:white;text-align:left>Minor</th>";
        rows["chroma"] = "<tr style=font-size:small><th style=background-color:darkgray;color:white;text-align:left>Chromatic</th>";
        rows["minBlues"] = "<tr style=font-size:small><th style=background-color:darkgray;color:white;text-align:left>Minor Blues</th>";
        rows["majArp"] = "<tr style=font-size:small><th style=background-color:darkgray;color:white;text-align:left>Major</th>";
        rows["natMinArp"] = "<tr style=font-size:small><th style=background-color:darkgray;color:white;text-align:left>Minor</th>";
        rows["header"] = "<tr style=background-color:darkgray;color:white;font-size:small><td></td>";
        rows["repertoire"] = "";
        rows["freeplay"] = "";
        rows["drill"] = "";

        for (let s = 0; s < scales.length; s++) {
          count[scales[s]] = 0; // this will determine whether there is anything to show for a particular kind of scale
        }

        for (let i = 0; i < tonics.length; i++) {

          rows["header"] += "<th style=width:6.6vw;>"+ tonics[i] + "</th>";

          for (let s = 0; s < scales.length; s++) {

            if (!isAvail(scaleData[scales[s]])) {
              continue;
            }
            const alldata = scaleData[scales[s]][tonics[i]];
            if (!isAvail(alldata)) {
              rows[scales[s]] += "<td></td>";
              continue;
            }

            // for now just take the largest one, but should really display all by dividing up the cell somehow
            let dataocts = 1;
            let uninum = "";
            let uninumfmt = "";
            for (let octs = 1; octs <= 4; octs++) {
              let octcolor = "white";

              if (isAvail(scaleData[scales[s]][tonics[i]][octs])) {
                if (scaleData[scales[s]][tonics[i]][octs].hand !== 'both') {
                  octcolor = "yellow";
                }
                uninum = "&#x"+(2460+octs-1)+";";
                uninumfmt += "<span style=color:"+octcolor+">"+uninum+"</span>";
                dataocts = octs;
                count[scales[s]]++;  // we found at least one of these kinds of scale.
              }
            }
            const data = scaleData[scales[s]][tonics[i]][dataocts];

            let streakbpm = 0;
            let streak = 0;

            if (isAvail(data.hist.maxStreakBPM) && isAvail(data.hist.maxStreakBPM[2]) &&
                isAvail(data.hist.maxStreak) && isAvail(data.hist.maxStreak[2])) {
                  streak = data.hist.maxStreak[2];
                  streakbpm = Math.trunc(0.5+avail(data.hist.maxStreakBPM[2],0)/(0.001+avail(data.hist.maxStreak[2],1)));
            }

            const acc = Math.trunc(100*data.hist.success/(data.hist.count));
            const avgbpm = Math.trunc(data.hist.sumBPM/data.hist.count);
            const maxbpm = Math.trunc(data.hist.maxBPM);
            const bestbpm = Math.trunc(data.hist.bestBPM);
            const targetbpm = 0; // avail(data.hist.targetBPM, findTargetBPM(preset));

            const schedule = avail(runHistory[".PREF.LEARNINGSCHEDULE."+stripPresetModifiers(data.preset)], "begin");

            let evals = evaluateSessionStats(acc, streak, streakbpm, avgbpm, maxbpm, bestbpm, targetbpm,
                          data.days, schedule, avail(data.hist.maxStreakAtEnd[2], false));

            let color = evals.overallColor;
            let dayscolor = evals.ageColor;

            rows[scales[s]] += "<td onclick=\"gotoPreset('"+
            data.preset + "', document.getElementById('skillMapContainer'), null, 0, 0, 0, 0);\" "+
            "style=text-align:center;color:white;background-color:"+color+
            " title='Octaves: "+uninum+", Hand: "+data.hand+", Acc: "+acc+"%, Streak: "+streak+"@"+streakbpm+", Age: "+data.days+" day"+(data.days===1?"":"s")+"'>"+
              `<i id=learningScheduleIcon class="${learningScheduleIconName[schedule]}" style=font-size:10px></i>`+
              "<span style=font-weight:bold;>"+uninumfmt+"</span>&nbsp;"+
              "<span style=background-color:"+dayscolor+">"+
              data.days+"d</span></td>";
          }
        }

        // Add repertoire items and drills

        // Iterate over all keys in repData
        const repkeys = Object.keys(repData);
        const barprecount = {};

        const needRowSpan = {};

        for (let k = 0; k < repkeys.length; k++) {
            if (!repData.hasOwnProperty(repkeys[k]) || repkeys[k].startsWith("TEST")) {
                continue;
            }

            const precat = presetCategory(repkeys[k]);

            if (precat !== "repertoire") {
              continue;
            }

            //console.log("K:"+k+" repkeys[k]:/"+repkeys[k]);

            const schedule = avail(runHistory[".PREF.LEARNINGSCHEDULE."+
                                stripPresetModifiers(repkeys[k])], "begin");

            rows["repertoire"] += "<tr style=font-size:small><th id='SKILL_" + repkeys[k] +
              "' style=background-color:darkgray;color:white;text-align:left>" +
              `<i id=learningScheduleIcon class="${learningScheduleIconName[schedule]}"
                style=font-size:10px aria-hidden="true"></i> ` +
              repkeys[k] + "</th>";

            // Convert repData for the current key into an array of [key, value] pairs, and sort it
            // Adjusted sorting logic to handle single-bar formats
            const sortedRepDataArray = Object.entries(repData[repkeys[k]])
                .sort((a, b) => {
                    //console.log("NUMPARTS BEFORE:/"+a+"/"+a[0]+"/"+String(a[0]).substring(1));
                    // Extract numerical parts from the keys, e.g., "B2-8" becomes [2, 8] and "B3" becomes [3, 3] for sorting consistency
                    const numPartsA = String(a[0]).substring(2).split("-");
                    if (numPartsA.length === 1) numPartsA.push(numPartsA[0]); // Duplicate if only one part is found
                    //console.log("NUMPARTS A /"+a+"/"+numPartsA[0]+"/"+numPartsA[1]);

                    const numPartsB = String(b[0]).substring(2).split("-");
                    if (numPartsB.length === 1) numPartsB.push(numPartsB[0]); // Duplicate if only one part is found
                    //console.log("NUMPARTS B /"+b+"/"+numPartsB[0]+"/"+numPartsB[1]);

                    // Compare the starting bars first
                    if (Number(numPartsA[0]) !== Number(numPartsB[0])) {
                        return numPartsA[0] - numPartsB[0];
                    }
                    // If starting bars are the same, compare the ending bars
                    return Number(numPartsA[1]) - Number(numPartsB[1]);
                });


            // Now iterate over the sorted array
            sortedRepDataArray.forEach(([key, value]) => {
                const fullkey = repkeys[k] + key;
                const p = avail(runHistory[".PREF." + fullkey], {favorite: false});
                if (!p.favorite) {
                    return;
                }

                if (isAvail(barprecount[repkeys[k]])) {
                    barprecount[repkeys[k]]++;
                } else {
                    barprecount[repkeys[k]] = 1;
                }

                if (barprecount[repkeys[k]] > 1 && (barprecount[repkeys[k]] % 12) === 1) {
                  rows["repertoire"] += "</tr><tr>"; // +"<th style=text-align:right;background-color:darkgray;color:white;font-size:x-small>continued:</th>";
                  const skillkey = "SKILL_"+repkeys[k];
                  if (!isAvail(needRowSpan[skillkey])) {
                    needRowSpan[skillkey] = 1;
                  }
                  needRowSpan[skillkey]++;
                }

                const acc = Math.trunc(100*value.hist.success/(value.hist.count));

                let streakbpm = 0;
                let streak = 0;

                if (isAvail(value.hist.maxStreakBPM) && isAvail(value.hist.maxStreakBPM[2]) &&
                    isAvail(value.hist.maxStreak) && isAvail(value.hist.maxStreak[2])) {
                      streak = value.hist.maxStreak[2];
                      streakbpm = Math.trunc(0.5+avail(value.hist.maxStreakBPM[2],0)/(0.001+avail(value.hist.maxStreak[2],1)));
                }

                const avgbpm = Math.trunc(value.hist.sumBPM/value.hist.count);
                const maxbpm = Math.trunc(value.hist.maxBPM);
                const bestbpm = Math.trunc(value.hist.bestBPM);
                const targetbpm = 0; // avail(data.hist.targetBPM, findTargetBPM(preset));

                let evals = evaluateSessionStats(acc, streak, streakbpm, avgbpm, maxbpm, bestbpm, targetbpm,
                              value.days, schedule, avail(value.hist.maxStreakAtEnd[2]));

                let color = evals.overallColor;
                let dayscolor = evals.ageColor;

                rows["repertoire"] += "<td onclick=\"gotoPreset('"+
                    value.name+ "',document.getElementById('skillMapContainer'),'"+
                    value.barRange+"',"+value.noteScopeList+
                    ")\" style=text-align:center;font-size:small;background-color:" +
                    color + ";color:white;width:6.6vw title='Acc: "+acc+"%, Streak: "+streak+"@"+streakbpm+", Age: "+value.days+
                    " day"+(value.days===1?"":"s")+"'>" + key + "<br>" +
                    "<span style=color:white;background-color:" + dayscolor + ">" +
                    value.days + "d</span></td>";
            });
        }

        // drills

        // Iterate over all keys in drillData
        const drillArray = Object.values(drillData);
        drillArray.sort((a,b) => a.name.localeCompare(b.name));
        rows["drill"] += "<tr style=font-size:small><th id='SKILL_DRILLS' style=background-color:darkgray;color:white;text-align:left>Drills:</th>";

        for (let k = 0; k < drillArray.length; k++) {
            if (drillArray[k].preset.startsWith("TEST")) {
                continue;
            }

            const precat = presetCategory(drillArray[k].preset);

            if (precat !== "drill") {
              console.log("OTHER ITEM FOUND IN SKILL MAP, CAT="+precat+" for "+drillArray[k].preset);
              continue;
            }

            const value = drillArray[k];

            const acc = Math.trunc(100*value.hist.success/(value.hist.count));
            let streakbpm = 0;
            let streak = 0;

            if (isAvail(value.hist.maxStreakBPM) && isAvail(value.hist.maxStreakBPM[2]) &&
                isAvail(value.hist.maxStreak) && isAvail(value.hist.maxStreak[2])) {
                  streak = value.hist.maxStreak[2];
                  streakbpm = Math.trunc(0.5+avail(value.hist.maxStreakBPM[2],0)/(0.001+avail(value.hist.maxStreak[2],1)));
            }
            const avgbpm = Math.trunc(value.hist.sumBPM/value.hist.count);
            const maxbpm = Math.trunc(value.hist.maxBPM);
            const bestbpm = Math.trunc(value.hist.bestBPM);
            const targetbpm = 0; // avail(data.hist.targetBPM, findTargetBPM(preset));

            const schedule = avail(runHistory[".PREF.LEARNINGSCHEDULE."+stripPresetModifiers(value.preset)], "begin");

            let evals = evaluateSessionStats(acc, streak, streakbpm, avgbpm, maxbpm, bestbpm, targetbpm,
                          value.days, schedule, avail(value.hist.maxStreakAtEnd[2]));

            let color = evals.overallColor;
            let dayscolor = evals.ageColor;

            rows["drill"] += "<td onclick=\"gotoPreset('"+
                value.name+ "',document.getElementById('skillMapContainer'),null)\" style=text-align:center;font-size:x-small;background-color:" +
                color + ";color:white;width:6.6vw title='Acc: "+acc+"%, Streak: "+streak+"@"+streakbpm+", Age: "+value.days+
                " day"+(value.days===1?"":"s")+"'>" +
                `<i id=learningScheduleIcon class="${learningScheduleIconName[schedule]}" style=font-size:10px aria-hidden="true"></i>&nbsp;`+
                value.name + "<br>" +
                "<span style=color:white;background-color:" + dayscolor + ">" +
                value.days + "d</span></td>";
        }

        // Free Play

        // Iterate over all keys in freeplayData
        const freeplayArray = Object.values(freeplayData);
        freeplayArray.sort((a,b) => a.name.localeCompare(b.name));
        rows["freeplay"] += "<tr style=font-size:small><th id='SKILL_FREEPLAY' style=background-color:darkgray;color:white;text-align:left>Free Play:</th>";

        for (let k = 0; k < freeplayArray.length; k++) {
            if (freeplayArray[k].preset.startsWith("TEST")) {
                continue;
            }

            const precat = presetCategory(freeplayArray[k].preset);

            const value = freeplayArray[k];

            const schedule = avail(runHistory[".PREF.LEARNINGSCHEDULE."+stripPresetModifiers(value.preset)], "begin");

            let evals = evaluateSessionStats(0, 0, 0, 0, 0, 0, 0, value.days, schedule, false);

            let color = "gray";
            let dayscolor = evals.ageColor;

            rows["freeplay"] += "<td onclick=\"gotoPreset('"+
                value.name+ "',document.getElementById('skillMapContainer'),null)\" style=text-align:center;font-size:x-small;background-color:" +
                color + ";color:white;width:6.6vw title='Free play. Age: "+value.days+
                " day"+(value.days===1?"":"s")+". Description: "+value.description+"'>" +
                `<i id=learningScheduleIcon class="${learningScheduleIconName[schedule]}" style=font-size:10px aria-hidden="true"></i>&nbsp;`+
                value.name + "<br>" +
                "<span style=color:white;background-color:" + dayscolor + ">" +
                value.days + "d</span></td>";
        }

        sctab.innerHTML =  `<tbody>
          <tr id=skillmap_scales style=background-color:lightblue>
            <th colspan=13 style=text-align:center;padding-top:5px;padding-bottom:5px>
              <div style=display:flex;justify-content:center;align-items:center;width:100%>
                <div id=skillmap_scales_collapse_icon onclick='toggleSkillMapSection("scales")'
                  style=float:left;margin-right:auto;color:gray><i class="fa-solid fa-minimize"></i>
                </div>
                <span style=flex:1;text-align:center><i class=\"fa-solid fa-stairs\"></i> SCALES</span>
              </div>
            </th>
          </tr>` +
          rows["header"] + "</tr>" +
          (count["maj"]?rows["maj"]:"<tr>") + "</tr>" +
          (count["natMin"]?rows["natMin"]:"<tr>") + "</tr>" +
          (count["chroma"]?rows["chroma"]:"<tr>") + "</tr>" +
          (count["minBlues"]?rows["minBlues"]:"<tr>") + "</tr>" +
          `<tr id=skillmap_arps style=background-color:lightblue>
            <th colspan=13 style=text-align:center;padding-top:5px;padding-bottom:5px>
              <div style=display:flex;justify-content:center;align-items:center;width:100%>
                <div id=skillmap_arps_collapse_icon onclick='toggleSkillMapSection("arps")'
                  style=float:left;margin-right:auto;color:gray><i class="fa-solid fa-minimize"></i>
                </div>
                <span style=flex:1;text-align:center><i class=\"fa-solid fa-wave-square\"></i> ARPEGGIOS</span>
              </div>
            </th>
          </tr>` +
          rows["header"] + "</tr>" +
          rows["majArp"] + "</tr>" +
          rows["natMinArp"] + "</tr>" +
          `<tr id=skillmap_drills style=background-color:lightblue>
             <th colspan=13 style=text-align:center;padding-top:5px;padding-bottom:5px>
               <div style=display:flex;justify-content:center;align-items:center;width:100%>
                 <div id=skillmap_drills_collapse_icon onclick='toggleSkillMapSection("drills")'
                   style=float:left;margin-right:auto;color:gray><i class="fa-solid fa-minimize"></i>
                 </div>
                 <span style=flex:1;text-align:center>
                   <i class=\"fa-solid fa-screwdriver-wrench\"></i> OTHER DRILLS</span>
               </div>
             </th>
           </tr>` +
          rows["drill"] + "</tr>"+
          `<tr id=skillmap_freeplay style=background-color:lightblue>
             <th colspan=13 style=text-align:center;padding-top:5px;padding-bottom:5px>
               <div style=display:flex;justify-content:center;align-items:center;width:100%>
                 <div id=skillmap_freeplay_collapse_icon onclick='toggleSkillMapSection("freeplay")'
                   style=float:left;margin-right:auto;color:gray><i class="fa-solid fa-minimize"></i>
                 </div>
                 <span style=flex:1;text-align:center>
                   <i class=\"fa-solid fa-music\"></i> FREE PLAY</span>
               </div>
             </th>
           </tr>` +
          rows["freeplay"] + "</tr>"+
            `<tr id=skillmap_repertoire style=background-color:lightblue>
             <th colspan=13 style=text-align:center;padding-top:5px;padding-bottom:5px>
               <div style=display:flex;justify-content:center;align-items:center;width:100%>
                 <div id=skillmap_repertoire_collapse_icon onclick='toggleSkillMapSection("repertoire")'
                   style=float:left;margin-right:auto;color:gray><i class="fa-solid fa-minimize"></i>
                 </div>
                 <span style=flex:1;text-align:center>
                   <i class=\"fa-solid fa-book-open\"></i> REPERTOIRE
               </div>
             </th>
           </tr>` +
         rows["repertoire"] + "</tr>"+

         "</tbody>";

        setTimeout(function() {
          skillMapDisplaySection("scales");
          skillMapDisplaySection("arps");
          skillMapDisplaySection("drills");
          skillMapDisplaySection("freeplay");
          skillMapDisplaySection("repertoire");
        }, 0);

        setTimeout(function() {
          for (const key in needRowSpan) {
            if (needRowSpan.hasOwnProperty(key)) {
              //console.log("SETTING ROWSPAN ON "+key);
              document.getElementById(key).setAttribute("rowspan", String(needRowSpan[key]));
            }
          }

          hideEmptyRows("skillMapTable");
        },200);
    }

    function hideEmptyRows(table) {
        var table = document.getElementById(table);
        if (table) {
            var rows = table.getElementsByTagName('tr');
            for (var i = 0; i < rows.length; i++) {
                var ths = rows[i].getElementsByTagName('th');
                var tds = rows[i].getElementsByTagName('td');

                // Check if the row has only one TH and no TDs
                if (ths.length === 1 && tds.length === 0) {
                    // Check if the TH does not have a colspan or colspan less than 2
                    if (!ths[0].hasAttribute('colspan') || ths[0].getAttribute('colspan') < 2) {
                        rows[i].style.display = 'none';
                    }
                }
            }
        }
    }

    function toggleSkillMapSection(section) {
      skillMapSectionCollapsed[section] = !avail(skillMapSectionCollapsed[section], false);
      localStorage.setItem("skillMapSectionCollapsed_"+section, String(skillMapSectionCollapsed[section]));
      console.log("Set skillmapsection "+section+" to "+skillMapSectionCollapsed[section]);
      skillMapDisplaySection(section);
    }

    function skillMapDisplaySection(section) {
      skillMapSectionCollapsed[section] = (localStorage.getItem("skillMapSectionCollapsed_"+section) === "true")?true:false;
      //console.log("Got skillmapsection from local storage: "+section+"="+skillMapSectionCollapsed[section]);
      const status = avail(skillMapSectionCollapsed[section],false)?"none":"table-row";
      const icon = avail(skillMapSectionCollapsed[section],false)?"maximize":"minimize";

      // Find the starting section by ID
      const startSection = document.getElementById(`skillmap_${section}`);
      const collapseIcon = document.getElementById(`skillmap_${section}_collapse_icon`);
      collapseIcon.innerHTML = "<i class=\"fa-solid fa-"+icon+"\"></i>";

      if (!startSection) {
        console.error("Section not found:", section);
        return;
      }

      let isHiding = false; // Flag to start hiding rows
      // Get all rows in the table to ensure we only iterate over relevant elements
      const rows = document.querySelectorAll('table tr');

      rows.forEach(row => {
        // Check if this row is a section header
        if (row.id && row.id.startsWith('skillmap_')) {
          // If we've reached the next section, stop hiding rows
          if (isHiding) {
            isHiding = false;
            return;
          }
          // If this is our start section, start hiding the following rows
          if (row === startSection) {
            isHiding = true;
            return;
          }
        }

        // Hide this row if we are in hiding mode
        if (isHiding) {
          row.style.display = status;
        }
      });
    }

    function loadTodayStats() {

      console.log("######### LoadTodayStats");

      if (runHistory === null) {
        loadRunHistory();
      }
      const runName = todayDate() + "|" + curPresetName + historyNameModifier() + "|" + getSelectedHand();

      if (isAvail(runHistory[runName]) && runHistory.hasOwnProperty(runName)) {
        console.log("Found today stats for "+runName);
        if ( isAvail(runHistory[runName].noteScope) &&
          isAvail(noteScope) && isAvail(noteScope[0]) && isAvail(noteScope[1]) &&
          noteScope[0].first == runHistory[runName].noteScope[0].first &&
          noteScope[0].last == runHistory[runName].noteScope[0].last &&
          noteScope[1].first == runHistory[runName].noteScope[1].first &&
          noteScope[1].last == runHistory[runName].noteScope[1].last
        ) {
          console.log("Matches notescope");
        } else {
          console.log("Does not match notescope, skipping update.");
          return;
        }

        // if we get here we have a complete match

        averageBPM = Math.trunc(avail(runHistory[runName].sumBPM,0)/(avail(runHistory[runName].success,0)+0.001));
        maxBPM = runHistory[runName].maxBPM;
        bestBPM = runHistory[runName].bestBPM;
        successCount = runHistory[runName].success;

        failCount = runHistory[runName].notefail;    // a fail could include soft fails depending on prefs
        softFailCount = avail(runHistory[runName].softFailCount,0);
        noteFailCount = runHistory[runName].notefail;
        repCount = 0;
        totalDuration = 0;
        startTime = null;
        wrongNotePlayed = false;
        wrongNoteNumber = -1;
        numQBPM = avail(runHistory[runName].numQBPM.slice(), [0,0,0,0]);
        sumQBPM = avail(runHistory[runName].sumQBPM.slice(), [0,0,0,0]);
        midiNotes = [];
        curStreak = [0,0,0,0]; // Implement: technically we could save this in runHistory so streaks could span sessions.
        curStreakBPM = [0,0,0,0];
        maxStreak = runHistory[runName].maxStreak.slice();
        maxStreakBPM = runHistory[runName].maxStreakBPM.slice();
        for (let q = 0; q < 4; q++) {
          if (isAvail(runHistory[runName].maxStreakAtEnd) &&
              avail(runHistory[runName].maxStreakAtEnd[q], false)) {
            curStreak[q] = runHistory[runName].maxStreak[q];
            curStreakBPM[q] = runHistory[runName].maxStreakBPM[q];
          }
        }
        nnAccuracy = avail(runHistory[runName].nnAccuracy, {success:0,fail:0});

        console.log("DISPLAYING TODAY STATS");
        displayTestStats(null, "reset");
      }

    }

    function computePriorStreakData() {

      console.log("######### Computepriorstreakdata");

      if (runHistory === null) {
        loadRunHistory();
      }
      const currentHand = getSelectedHand();
      const hnm = historyNameModifier();
      const currentBars = hnm.substr(1);  // the substr removes the leading space

      const name = curPresetName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // escape regex symbols in preset name
      const p = "^"+name+"( B([0-9]+)(-([0-9]+))?)?$";
      console.log("Computing prior streak with pattern:"+p);
      const pattern = new RegExp(p);

      let latestStreak = null;
      let latestDate = "0000-00-00";
      let latestBPM = 0;
      let latestAccuracy = 0;

      let barPresetList = [];

      for (const key in runHistory) {
        if (key.startsWith(".PREF.")) {
          //console.log("Skipped PREF:"+key);
          continue;
        }
        if (runHistory.hasOwnProperty(key)) {

            const [date, preset, hand] = key.split("|");

            if (!preset.startsWith(curPresetName)) {
              // not the right one
              continue;
            }

            if (runHistory[key].count < 5) {
              continue; // skip days where there were not a significant number of runs
            }

            const matches = preset.match(pattern);

            let barSuffix = "";

            if (matches === null) {
              console.log("no match:"+key);
              continue;
            } else {
              if (matches[2]) {
                //console.log(`Start Bar: ${matches[2]}`);
                barSuffix = " B"+matches[2];
                if (matches[4]) {
                  barSuffix += "-"+matches[4];
                }

                if (isAvail(runHistory[key].noteScope)) {
                  if (date <= "2024-02-19") {
                    // there was a bug before 2024-02-20 where notescope was not deep-copied and therefore was incorrect
                    runHistory[key].noteScope = null; // blank it out, it's wrong anyway
                  } else {

                    const s = avail(runHistory[key].maxStreak, null);
                    const b = avail(runHistory[key].maxStreakBPM, null);
                    const fail = avail(runHistory[key].notefail,0);
                    const suc = avail(runHistory[key].success,0);
                    const accuracy = Math.trunc(0.5+100*suc/(suc+fail+0.001));

                    const index = barPresetList.findIndex(obj => obj.key === barSuffix);

                    const newPreset = {
                      key:barSuffix,
                      noteScope: runHistory[key].noteScope,
                      date: date,
                      days: daysSince(date),
                      accuracy: accuracy,
                      streak: s[2],
                      bpm: Math.trunc(b[2]/(s[2]?s[2]:1))
                    };

                    if (index === -1) {
                      barPresetList.push(newPreset);
                    } else {
                      barPresetList[index] = newPreset;
                    }
                    //console.log("BAR SUFFIX FOUND WITH NOTESCOPE:"+barSuffix+" ns:"+runHistory[key].noteScope[0].first+" "+runHistory[key].noteScope[0].last+" "+runHistory[key].noteScope[1].first+" "+runHistory[key].noteScope[1].last+" date:"+date+" strk:"+s[2]+" acc:"+accuracy);
                  }
                }
              }
              // if this scope does not match the current barscope then skip further processing.
              // IMPLEMENT: currently this does not account for extra modifiers like constant
              // duration or changes in time

              if (barSuffix !== hnm) {
                //console.log("Skipping incorrect history modifier. Barsuf=/"+barSuffix+"/ hnm=/"+hnm+"/");
                continue;
              } else {
                //console.log("Matched history modifier. Barsuf=/"+barSuffix+"/ hnm=/"+hnm+"/");
              }
            }

            if (hand !== currentHand) {
              console.log("not current hand:"+hand+" cur="+currentHand);
              continue;
            }

            if (date < latestDate) {
              console.log("we already have a later date");
              continue;
            }

            const s = avail(runHistory[key].maxStreak, null);
            const b = avail(runHistory[key].maxStreakBPM, null);
            const fail = avail(runHistory[key].notefail,0);
            const suc = avail(runHistory[key].success,0);
            const accuracy = Math.trunc(0.5+100*suc/(suc+fail+0.001));

            // only consider streaks of at least 3 length, if a day had a
            // streak less than that then consider it not an acceptable preset
            if (s !== null && s[3] > 2 && b !== null && b[3] > 0) {
              latestStreak = s[3];
              latestBPM = Math.trunc(b[3]/(s[3]>0?s[3]:1));
              latestDate = date;
              latestAccuracy = accuracy;
              console.log("Found streak for preset=/"+preset+"/ barsuf:/"+barSuffix+"/ hand="+hand+" date="+date+" strk="+latestStreak+" acc:"+latestAccuracy);
            } else {
              console.log("no streak");
            }
          }
        }

        // set up bar presets

        const favsetting = (preferences["barPresetAll"]?"<i class=\"fa-solid fa-arrow-rotate-right\"></i>All":"<i class=\"fa-solid fa-arrow-rotate-right\"></i>Fav");
        console.log("barPreset pref ="+preferences["barPresetAll"]+" favsetting="+favsetting);

        let barpresets = '<div id=toggleBarSelect onclick="togglePref(\'barPresetAll\');" '+
                    ' class=mode-box-bars style=vertical-align:top;border-radius:5px ' +
                    'title="Toggle display of All versus just Favorite bar range presets">' +
                    (favsetting)+"</div>";

        barPresetList.sort((a, b) => {
            // Extract the first and second numbers from each string
            const newa = a.key.substring(2);
            const newb = b.key.substring(2);
            const [aRange1, aRange2] = newa.split('-').map(Number);
            const [bRange1, bRange2] = newb.split('-').map(Number);

            //console.log("Comparing /"+aRange1+"/,/"+aRange2+"/"+bRange1+"/,/"+bRange2+"/");

            // Compare the first numbers
            if (aRange1 != bRange1) {
                return aRange1 - bRange1;
            } else {
                // If the first numbers are equal, compare the second numbers
                return aRange2 - bRange2;
            }
        });

        let n = 0;
        for (let i = 0; i < barPresetList.length; i++) {
          const item = barPresetList[i];
          const noteranges = item.noteScope[0].first+","+item.noteScope[0].last+","+
            item.noteScope[1].first+","+item.noteScope[1].last;

          const endstreak = isAvail(item.maxStreakAtEnd)?avail(item.maxStreakAtEnd[2],false):false;

          const schedule = avail(runHistory[".PREF.LEARNINGSCHEDULE."+stripPresetModifiers(curPresetName)], "begin");

          let evals = evaluateSessionStats(item.accuracy, item.streak, item.bpm, 0, 0, 0, 0,
                        item.days, schedule, endstreak);

          //console.log("Adding BarPreset:" +barkey+" "+ typeof barPresetList[barkey]);
          const prefbar = getHistoryPref(null, ".PREF."+curPresetName+item.key);
          if (!prefbar.favorite && avail(preferences["barPresetAll"],true) == false) {
            console.log("Skipping non-favorite pref button for "+item.key);
            continue;
          }

          n++;

          const [aRange1, aRange2] = item.key.substr(2).split('-').map(String);

          const anno1 = (barAnnotations!==null)?avail(barAnnotations[aRange1], ""):"";
          const anno2 = ""; //avail(barAnnotations[aRange2], "");  // preset button got too wide with this in place

          let anno = "<br>&nbsp;";

          if (anno1 !== "") {
            if (anno2 !== "") {
              anno = "<br>"+anno1+" ... "+anno2;
            } else {
              anno = "<br>"+anno1;
            }
          } else if (anno2 !== "") {
            //anno = "<br>"+anno2;
          }

          //if (anno !== "") {
            anno = "<span style=font-size:8px>"+anno+"</span>";
          //}

          let accColor = evals.accColor;

          let strkColor = evals.streakColor;

          let daysColor = evals.ageColor;

          let stats = "&nbsp;<div style=display:inline-block;font-size:9px;line-height:1>" +
                        "<span style=color:white;background-color:"+accColor+">"+
                        item.accuracy+"%</span><br>"+
                        "<span style=color:white;background-color:"+strkColor+">"+
                        item.streak+"@"+item.bpm+"</span><br>"+
                        "<span style=color:white;background-color:"+daysColor+">"+
                        item.days+
                        ((item.days==1)?" day":" days")+"</span>"+
                        "</div>";

          let outlines = "";
          //outlines += "outline:3px solid " + daysColor + ";";

          outlines += "border:3px solid " + evals.overallColor + ";";

          let heart = "";
          if (prefbar.favorite) {
            heart = "<span class=mfs style=color:silver;font-size:xx-small>&#x2764;</span><br>";
          }

          barpresets += "<div class=mode-box-bars id="+
            item.key+" style='display:inline-block;line-height:0.7;user-select:none;white-space:nowrap;"+outlines+"'"+
            " title='Preset to quickly select bars previously practiced'"+
            " onclick=\"changeBarScope('"+item.key.substr(1)+"',"+noteranges+");\""+ // clip off the leading space
            " data-notescope='"+noteranges+"'"+
            "><div style=display:inline-block;text-align:left;line-height:0.9>"+
            heart+evals.overallSymbol+item.key.substr(1)+"</div>"+stats+anno+"</div>";

        } // end of: for (const item in barPresetList)

        let barcon = document.getElementById("barSelectContainer");
        barcon.innerHTML = barpresets;

        if (n === 0) {
          barcon.style.display = "none";
        } else {
          barcon.style.display = "block";
        }

        if (latestStreak > 0) {
          console.log("Found most recent streak data: "+latestDate+" "+latestStreak+" "+latestBPM+" "+latestAccuracy);

          PriorStreak = [latestStreak,latestBPM,latestDate,latestAccuracy];

          if (latestAccuracy >= 98) {
            // accuracy was 98% or more so allowed to go faster if desired as long as it's not faster than
            // this test's maximum allowed BPM
            BPMRecommendedRange = [Math.trunc(latestBPM*0.85), Math.min(Math.trunc(latestBPM*1.05), testOptions.maxBPM)];
            practiceStrategy = "push";
          } else if (latestAccuracy > 89) {
            // accuracy was slightly low so hold prior speed.
            BPMRecommendedRange = [Math.trunc(latestBPM*0.65), Math.min(Math.trunc(latestBPM), testOptions.maxBPM)];
            practiceStrategy = "hold";
          } else if (latestAccuracy > 75) {
            // accuracy was clearly too low last time so slow down
            BPMRecommendedRange = [Math.trunc(latestBPM*0.75), Math.trunc(latestBPM*0.95)];
            practiceStrategy = "caution";
          } else {
            // accuracy was disasterously low last time, slow way down
            BPMRecommendedRange = [Math.trunc(latestBPM*0.6), Math.trunc(latestBPM*0.8)];
            practiceStrategy = "slower";
          }

        } else {
          console.log("There is no prior streak data");
          PriorStreak = [0,0,0,0];
          BPMRecommendedRange = [0, 10000];
          practiceStrategy = "";
          clearPriorAndRec();
        }
    }  // end of computePriorStreakData()



    function toggleFavoriteBarSelection() {

      console.log("===ToggleFavBar: ns="+noteScope+" ns0="+noteScope[0]+" ns1="+noteScope[1]+" ns0f="+noteScope[0].first+" ns0l="+noteScope[0].last+" ns0nr="+noteScope[0].lastNonrest+
        " ns1f="+noteScope[1].first+" ns0l="+noteScope[1].last+" ns1nr="+noteScope[1].lastNonrest);

      removeTrailingRestsFromNoteScope();

      if (noteScope === null || noteScope[0] === null || noteScope[1] === null) {
        // there is no notescope so don't do anything
        console.log("No notescope (NULL) so not toggling favorite selection ns="+noteScope+" ns0="+noteScope[0]+" ns1="+noteScope[1]);
        setFavoriteIcon(false);
        return;
      }

/*************************
      if (
        (
          noteScope[0].first == 0 && noteScope[0].last == avail(noteScope[0].lastnonrest,-1) &&
          noteScope[1].first == 0 && noteScope[1].last == avail(noteScope[1].lastnonrest,-1)
        )
      ) {
        // there is no notescope so dont do anything
        console.log("No notescope (values span) so not toggling favorite selection ns="+noteScope+" ns0="+noteScope[0]+" ns1="+noteScope[1]);
        console.log("ns0f="+noteScope[0].first+" ns0l="+noteScope[0].last+" ns1f="+noteScope[1].first+" ns1l="+noteScope[1].last);
        setFavoriteIcon(false);
        return;
      }
      ***********************************/

      const pref = getHistoryPref();

      console.log("toggleFav: Found history pref:"+pref.favorite);

      if (isAvail(pref.favorite)) {
        pref.favorite = !pref.favorite;
        setFavoriteIcon(pref.favorite);
      } else {
        pref.favorite = true; // default is true for new ranges created
        setFavoriteIcon(true);
      }
      console.log("ToggleFav: final value is:"+pref.favorite);

      saveRunHistory();

      computePriorStreakData(); // redraw which ones are displayed

      // highlight this one if its still showing.
    }

    function computeBarReps() {
      if (runHistory === null) {
        loadRunHistory();
      }
      const name = curPresetName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // escape regex symbols in preset name
      const p = "^[0-9-]+\\|"+name;
      //console.log("BARREPS: name pattern="+p);
      const pattern = new RegExp(p);
      const barpattern = new RegExp("^"+name+" B([0-9]+)-?([0-9]+)?$");

      barReps = [];

      maxBar = avail(maxBar,1);
      console.log("Maxbar:"+maxBar);
      // init to all 0
      for (let i = 1; i <= maxBar; i++) {
        barReps[i] = [0,0,0];
      }

      const handmap = {"left":0, "right":1, "both":2};

      for (const key in runHistory) {
        if (key.startsWith(".PREF.")) {
          //console.log("Skipped PREF:"+key);
          continue;
        }
        if (runHistory.hasOwnProperty(key) && pattern.test(key)) {
            //console.log("Got matching key:"+key);
            const [date, preset, hand] = key.split("|");

            if (! preset.startsWith(curPresetName)) {
              console.log("No actual match, skipping");
              continue;
            }
            const reps = parseInt(avail(runHistory[key].success, 0));

            let barrange = preset.match(barpattern);

            //console.log("BarData: barrange len="+((barrange===null)?"NULL!":barrange.length));

            if (barrange === null || barrange.length === 1) {
              barrange = [];
              barrange[0] = 1;
              barrange[1] = parseInt(avail(runHistory[key].maxBar, avail(maxBar,1)));
              //console.log("Barrange is null, setting to range 1-maxBar:"+maxBar);
            } else if (barrange.length === 2) {
              //console.log("Barrange items:"+barrange[1]+":"+barrange[2]+":");
              barrange[0] = parseInt(barrange[1]); // the key was like B1, meaning range 1 to 1
              barrange[1] = parseInt(barrange[1]);
            } else if (barrange.length === 3) {
              //console.log("Barrange items:"+barrange[0]+":"+barrange[1]+":"+barrange[2]);
              // zero item is just whole pattern. 1 will be first number in range but 2 could be undefined.
              barrange[0] = parseInt(barrange[1]);
              barrange[1] = parseInt(avail(barrange[2], barrange[1]));
            }

            //console.log("BarData: for key '"+key+"' adding "+reps+" to bars '"+barrange[0]+"' to '"+barrange[1]+"' hand="+hand+" handmap:"+handmap[hand]);
            for (let b = barrange[0]; b <= barrange[1]; b++) {
              if (!isAvail(barReps[b])) {
                barReps[b] = [0,0,0];
              }
              barReps[b][handmap[hand]] += reps;
              //console.log("B"+b+" "+handmap[hand]+"="+barReps[b][handmap[hand]]);
            }
        }
      }
      //let repstr = "reps: ";
      //for (let b = 1; b <= maxBar; b++) {
        //repstr += "B"+b+":"+barReps[b][0]+","+barReps[b][1]+","+barReps[b][2]+" ";
      //}
      //console.log("BARREPDATA: "+repstr);
      return barReps;
    }

    function loadRunHistory(force=false) {

      if (!force && runHistory !== null) {
        return;
      }
      runHistory = localStorage.getItem("runHistory");

      if (runHistory === null) {
        runHistory = {};
      } else {
        // Parse 'runHistory' from JSON if it exists

        // do some transition substituions here
        // freeplay items
        runHistory = runHistory.replace(/Aural training, single/g, 'AURAL-1');
        runHistory = runHistory.replace(/Arps, various/g, 'ARP-MSC');
        runHistory = runHistory.replace(/CSA large sections/g, 'CSA-FP');
        runHistory = runHistory.replace(/ICHFIL backing track/g, 'ICHFIL-BT');
        runHistory = runHistory.replace(/WTC Prelude 1 full/g, 'WTCP1-FP');
        runHistory = runHistory.replace(/HRS large sections/g, 'HRS-BT');
        runHistory = runHistory.replace(/FormPat2 CG/g, 'FRMPAT-2');
        runHistory = runHistory.replace(/Scales3/g, 'SCALE3');
        runHistory = runHistory.replace(/Scales4/g, 'SCALE4');
        // drills
        runHistory = runHistory.replace(/FGAmG LH impr pattern/g, 'FGAmG-LH-IMP1');
        runHistory = runHistory.replace(/FGAmG LH impr #2/g, 'FGAmG-LH-IMP2');
        runHistory = runHistory.replace(/Pitter-patter/g, 'RUN-PITPAT');
        runHistory = runHistory.replace(/LH Octave C2/g, 'OCTAVE-C2');
        runHistory = runHistory.replace(/RH Octave C5/g, 'OCTAVE-C5');
        // repertoire
        runHistory = runHistory.replace(/WTC Prelude 1/g, 'WTCP1');
        runHistory = runHistory.replace(/Meta1 theme B/g, 'MM-1');
        runHistory = runHistory.replace(/F\&uml;r Elise A Loop/g, 'FE');

        runHistory = JSON.parse(runHistory);
      }

      // fix a prior bug.
      let badcount = 0;
      let goodcount = 0;
      let madeMods = false;
      for (let key in runHistory) {
        if (!runHistory.hasOwnProperty(key)) {
          continue;
        }
        if (true) {
          let newkey = key.replace("I.C.H.F.I.L", "ICHFIL");
          newkey = newkey.replace("W.T.C.", "WTC");
          newkey = newkey.replace("H.R.S.", "HRS");
          newkey = newkey.replace("C.S.A","CSA");
          newkey = newkey.replace("W.S.P.","WSP");

          if (newkey !== key) {
            runHistory[newkey] = deepcopy(runHistory[key]);
            delete runHistory[key];
            key = newkey;
          }
        }
        if (key.startsWith(".PREF.")) {
          // translate the old menuValueBarPreset to the new favorite field.
          if (isAvail(runHistory[key].noAutoBarPreset)) {
            runHistory[key].favorite = (! runHistory[key].noAutoBarPreset);
            delete runHistory[key].noAutoBarPreset;
            console.log("TRANSLATED NOAUTOBARPRESET TO FAV: /"+key+"/ val:"+runHistory[key].favorite);
            madeMods = true;
          }
          continue;
        }
        if (runHistory[key].count === 1) {
          //console.log("UNITARY KEY:"+key);
          badcount++;
        } else {
          goodcount++;
        }

        // Add new fields here initialized appropriately
        if (!isAvail(runHistory[key].maxStreakAtEnd)) {
          runHistory[key].maxStreakAtEnd = [false,false,false,false];
        }

      }
      //console.log("UNITARY COUNT:"+badcount+" good:"+goodcount);

      if (madeMods) {
        // there were modifications made to transition to a newer version of runhistory
        console.log("SAVING RUN HISTORY: MODS MADE");
        saveRunHistory();
      }

      loadFreePlay();

    }

    function deepcopy(obj) {
      return JSON.parse(JSON.stringify(obj));
    }

    function saveFreePlay() {
      console.log("SAVING FREEPLAY IN HISTORY, records:"+freePlay.length);
      runHistory[".PREF.FREEPLAY"] = deepcopy(freePlay); // deep copy
      for (let i = 0; i < runHistory[".PREF.FREEPLAY"].length; i++) {
        console.log(runHistory[".PREF.FREEPLAY"][i].name);
      }
      saveRunHistory();
    }

    function loadFreePlay() {
      if (runHistory === null) {
        loadRunHistory();
      }
      // load free play items
      let key = ".PREF.FREEPLAY";
      if (runHistory.hasOwnProperty(key) && runHistory[key] !== null && runHistory[key].length !== 0) {
        freePlay = deepcopy(runHistory[key]); // deep copy for safety
        //console.log("LOADED FREEPLAY FROM RUNHISTORY LEN="+freePlay.length);
        //console.log("FP0="+freePlay[0].name+" FP="+freePlay);
      } else {
        console.log("NO FREEPLAY IN RUNHISTORY:"+runHistory[key]);
      }

      for (let i = 0; i < freePlay.length; i++) {
        if (!isAvail(freePlay[i].category)) {
          freePlay[i].category = 'misc';
        }
      }
      // whether or not we found it in history it has to be loaded into the presets menu
      // first delete any old ones already there

      createPresetMenu();
    }

    function getTodayFreePlayElapsed() {
      const runName = todayDate() + "|" + "Free Play:"+testOptions.shortName + "|" + "NA";

      if (runHistory === null) {
        // hasn't been read yet
        loadRunHistory();
      }

      return(runHistory[runName].elapsed/1000);
    }

    function logFreePlay(elapsed, replace=false) {
      if (!testOptions.isFreePlay) {
        alert("Can't log freeplay, not in effect");
        return;
      }
      const runName = todayDate() + "|" + "Free Play:"+testOptions.shortName + "|" + "NA";

      if (runHistory === null) {
        // hasn't been read yet
        loadRunHistory();
      }

      if (typeof runHistory[runName] === "undefined") {
        runHistory[runName] = {};
        runHistory[runName].count = 0;
        runHistory[runName].elapsed = 0;
        runHistory[runName].isFreePlay = true;
      }

      if (replace) {
        runHistory[runName].elapsed = elapsed;
      } else {
        runHistory[runName].elapsed += elapsed;
        runHistory[runName].count += 1;
      }

      runHistory[runName].description = testOptions.fullName;

      saveRunHistory();
    }

    function logOneRun(elapsed, notefail, strikes, bpm) {
      const runName = todayDate() + "|" + curPresetName + historyNameModifier() + "|" + getSelectedHand();

      if (runHistory === null) {
        // hasn't been read yet
        loadRunHistory();
      }
      if (typeof runHistory[runName] === "undefined") {
        runHistory[runName] = {};
        runHistory[runName].count = 0;
        runHistory[runName].elapsed = 0;
        runHistory[runName].sumBPM = 0;
        runHistory[runName].notefail = 0;
        runHistory[runName].success = 0;
        runHistory[runName].maxBPM = 0;
        runHistory[runName].bestBPM = 0;
        runHistory[runName].sumStrikes = 0;
        runHistory[runName].maxStreak = [0,0,0,0];
        runHistory[runName].maxStreakBPM = [0,0,0,0];
        runHistory[runName].maxStreakAtEnd = [false,false,false,false];
        runHistory[runName].goodNotes = 0;
        runHistory[runName].maxBar = maxBar;
        runHistory[runName].targetBPM = avail(testOptions.targetBPM,0);
        runHistory[runName].isFreePlay = false;

        if (noteScope === null || !isAvail(noteScope[0].first) || !isAvail(noteScope[1].first)) {
          runHistory[runName].noteScope = [{},{}];
        } else {
          runHistory[runName].noteScope = [
            // this is a deep copy of notescope. we had a bug originally where runhistory notescopes got corrupted
            // when notescope changed, as a pointer was being used.
            {
              first: noteScope[0].first,
              last: noteScope[0].last,
              firstrangenonrest: noteScope[0].firstrangenonrest,
              lastnonrest: noteScope[0].lastnonrest
            },
            {
              first: noteScope[1].first,
              last: noteScope[1].last,
              firstrangenonrest: noteScope[1].firstrangenonrest,
              lastnonrest: noteScope[1].lastnonrest
            },
          ];
        }

      }

      if (!isAvail(runHistory[runName].maxStreak)) {
        runHistory[runName].maxStreak = [0,0,0,0];
      }

      if (!isAvail(runHistory[runName].maxStreakBPM)) {
        runHistory[runName].maxStreakBPM = [0,0,0,0];
      }

      if (!isAvail(runHistory[runName].isFreePlay)) {
        runHistory[runName].isFreePlay = false;
      }

      for (let q = 0; q < 4; q++) {
        if (maxStreak[q] > runHistory[runName].maxStreak[q]) {
          runHistory[runName].maxStreak[q] = maxStreak[q];
          runHistory[runName].maxStreakBPM[q] = maxStreakBPM[q];
        }
        if (curStreak[q] === runHistory[runName].maxStreak[q] &&
            curStreakBPM[q] === runHistory[runName].maxStreakBPM[q]) {
              runHistory[runName].maxStreakAtEnd[q] = true;
        } else {
            runHistory[runName].maxStreakAtEnd[q] = false;
        }
      }

      if (!isAvail(runHistory[runName].numQBPM)) {
          runHistory[runName].numQBPM = [0,0,0,0];
      }
      if (!isAvail(runHistory[runName].sumQBPM)) {
        runHistory[runName].sumQBPM = [0,0,0,0];
      }

      runHistory[runName].count++;
      runHistory[runName].elapsed += elapsed;

      if (!isAvail(runHistory[runName].goodNotes)) {
        runHistory[runName].goodNotes = 0;
      }
      runHistory[runName].goodNotes += goodNotes;
      goodNotes = 0; // this is a global right now

      runHistory[runName].maxBar = maxBar; // so we can tally reps per bar
      if (notefail) {
        runHistory[runName].notefail++;

        if (!isAvail(runHistory[runName].errorNotes)) {
          runHistory[runName].errorNotes = [[],[]];
        }
        if (!isAvail(runHistory[runName].errorNotes[currentErrorNote.hand][currentErrorNote.noteIndex])) {
          runHistory[runName].errorNotes[currentErrorNote.hand][currentErrorNote.noteIndex] = 0;
        }
        runHistory[runName].errorNotes[currentErrorNote.hand][currentErrorNote.noteIndex]++;
      } else {
        runHistory[runName].success++;
        runHistory[runName].sumStrikes += strikes;
        runHistory[runName].sumBPM += bpm;
        if (bpm > runHistory[runName].maxBPM) {
          runHistory[runName].maxBPM = bpm;
        }
        if (strikes === 0 && bpm > runHistory[runName].bestBPM) {
          runHistory[runName].bestBPM = bpm;
        }
        if (!runHistory[runName].numQBPM[strikes]) {
          runHistory[runName].numQBPM[strikes] = 0;
          runHistory[runName].sumQBPM[strikes] = 0;
        }

        runHistory[runName].numQBPM[strikes] += 1;
        runHistory[runName].sumQBPM[strikes] += bpm;
      }

      saveRunHistory();

    }

    function saveRunHistory() {
      localStorage.setItem("runHistory", JSON.stringify(runHistory));
    }

    function displayStreaks() {
      // for now hard code passing quality, but this should be a preference
      const streakbpm = Math.trunc(curStreakBPM[2]/(curStreak[2]?curStreak[2]:1));
      const maxstreakbpm = Math.trunc(maxStreakBPM[2]/(maxStreak[2]?maxStreak[2]:1));
      document.getElementById("curStreakDiv").innerHTML =
        "Streak:<br><span class=bigstat>"+curStreak[2]+"</span><sub>"+streakbpm+"</sub><br><span style=font-size:small>Cur</span>";
      document.getElementById("maxStreakDiv").innerHTML =
        "<br><span class=bigstat>"+maxStreak[2]+"</span><sub>"+maxstreakbpm+"<br><span style=font-size:small>Max</span>";

      if ((curStreak[2]%5) === 0 && curStreak[2] !== 0) {
        say("Streak "+curStreak[2]);
      }
    }

    function daysSince(date) {
      const past = new Date(date);
      const today = new Date();
      today.setHours(0,0,0,0);
      const millis = today - past;
      const days = Math.trunc(millis/(1000*60*60*24));
      return days;
    }

    // get the current date in yyyy-mm-dd format
    function todayDate(offsetDays = 0) {
      const currentDate = new Date(Date.now()-offsetDays*60*60*24*1000);
      const year = currentDate.getFullYear();
      const month = String(currentDate.getMonth() + 1).padStart(2, '0'); // Month is zero-based, so we add 1 and pad with '0' if needed.
      const day = String(currentDate.getDate()).padStart(2, '0');

      return `${year}-${month}-${day}`;
    }

    // Function to handle the "Done" button click
    function done() {
      if (currentState === STATE.SETTING_NOTES) {
        currentState = STATE.WAITING_FOR_BUTTON;

        // Enable the "Set Notes" button and disable the "Done" button
        //document.getElementById('setNotesButton').disabled = false;
        document.getElementById('testNotesButton').disabled = false;
        //document.getElementById('doneButton').disabled = true;

        // create a string to make it easy to create presets
        let preset = "{name: 'new', leftHand: [";
        for (let i = 0; i < notesToPlay[0].length; i++) {
          preset += notesToPlay[0][i] + ", ";
        }
        preset += "], rightHand: [";
        for (let i = 0; i < notesToPlay[1].length; i++) {
          preset += notesToPlay[1][i] + ", ";
        }
        preset += "]};";
        message(preset);
        message("(Copied to clipboard)");
        copyToClipboard(preset);

        if (notesToPlay[0].length && notesToPlay[1].length) {
            changeSelectedHand('both');
        } else if (notesToPlay[0].length) {
            changeSelectedHand('left');
        } else {
            changeSelectedHand('right');
        }

        setNoteFilters();

      }
    }

    document.addEventListener('fullscreenchange', function() {
      document.getElementById("fullscreenButton").innerHTML = document.fullscreenElement ? "<i class=\"fa-regular fa-rectangle-xmark\"></i>&nbsp;Full" : " <i class=\"fa-solid fa-expand\"></i> Full&nbsp;Screen";
    });

    function exitFullscreen() {
      document.exitFullscreen ? document.exitFullscreen() : document.webkitExitFullscreen();
      document.getElementById("fullscreenButton").innerHTML = "<i class=\"fa-solid fa-expand\"></i> Full Screen";
    }

    function fullscreen(force=false) {

      if (document.fullscreenElement && !force) {
        // already full screen so exit
        // because we were already full screen we know one of the two apis below are in effect
        document.exitFullscreen ? document.exitFullscreen() : document.webkitExitFullscreen();
        document.getElementById("fullscreenButton").innerHTML = "<i class=\"fa-solid fa-expand\"></i>  Full Screen";
        return;
      }

      // if we get here the browser was not already full screen
      //console.log("fullscreen() is going into fullscreen mode");
      // Check if the browser supports the Fullscreen API
      if (document.documentElement.requestFullscreen) {
        // Request full-screen mode on the document element
        document.documentElement.requestFullscreen();
      } else if (document.documentElement.webkitRequestFullscreen) {
        // For older versions of Chrome, use the webkitRequestFullscreen method
        document.documentElement.webkitRequestFullscreen();
      } else {
        // Full-screen API is not supported
        alert('Fullscreen mode is not supported in this browser.');
        return;
      }
      document.getElementById("fullscreenButton").innerHTML = "<i class=\"fa-regular fa-rectangle-xmark\"></i> Full";
    }

    // Function to display a message in the console
    function message(text) {
      let consoleDiv = document.getElementById('console');
      let messageP = document.createElement('p');
      messageP.innerHTML = text;
      consoleDiv.appendChild(messageP);
      consoleDiv.scrollTop = consoleDiv.scrollHeight;
    }


    // Function to display a warning message in the console
    function warning(text) {
      let consoleDiv = document.getElementById('console');
      let messageP = document.createElement('p');
      messageP.style.color = 'red';
      messageP.textContent = text;
      consoleDiv.appendChild(messageP);
      consoleDiv.scrollTop = consoleDiv.scrollHeight;
    }

    // Function to display a message in the console
    function messageStats(text) {
      let statsDiv = document.getElementById('statsDiv');
      statsDiv.innerHTML = text;
    }

    function errorStats(error) {
      let statsDiv = document.getElementById('statsDiv');
      let consoleDiv = document.getElementById('console');

      if (error) {
        document.body.style.backgroundColor = bodyAlertColor;
      } else {
        document.body.style.backgroundColor = bodyColor;
      }
    }


    const handmodes = ['lh', 'rh', 'ht'];
    const selmodes = {lh:'left', rh:'right', ht:'both'};
    const modesels = {left:'lh', right:'rh', both:'ht'};

    // Function to get the selected hand from the pulldown menu
    function getSelectedHand() {
      const handmodes = ['lh', 'rh', 'ht'];
      const selmodes = {lh:'left', rh:'right', ht:'both'};
      const modesels = {left:'lh', right:'rh', both:'ht'};
      for (const mode of handmodes) {
        if (document.getElementById(mode).classList.contains('selected')) {
          return selmodes[mode];
        }
      }
      return null; // No mode selected
    }

    function changeBarScope(barscope, lfirst, llast, rfirst, rlast) {

      if (typeof lfirst === "number") {
        if (noteScope[0].first == lfirst && noteScope[0].last == llast &&
          noteScope[1].first == rfirst && noteScope[1].last == rlast) {
            // this one is already selected, so desect them all
            clearNotesToPlaySelection();
            return;
        }
      }

      noteScope[0].first = lfirst;
      noteScope[0].last = llast;
      noteScope[1].first = rfirst;
      noteScope[1].last = rlast;

      // now make adjustments and display the new scope
      removeTrailingRestsFromNoteScope();
      recolorNoteScope(0);
      recolorNoteScope(1);
      computeBeatsToPlay();
      scrollToFirstNote();
      computePriorStreakData();
      displayPriorRunStats();

      // cycle through all the barmode divs and add "selected" class only to the one that matches
      // the incoming scope.
      recolorBarPresets(barscope);

      const fav = document.getElementById("toggleFavoriteIcon");
      fav.style.display = "inline";
      const histpref = getHistoryPref(barscope);
      if (histpref.favorite) {
        fav.style.color = "red";
      } else {
        fav.style.color = "silver";
      }

      clearStats(); // when changing the selection clear the stats automatically

      loadTodayStats(); // if there are other runs from the current day, display them in the stats area.

    }

    function recolorBarPresets(boxid) {
      const modeBoxes = document.querySelectorAll('#barSelectContainer .mode-box-bars');

      modeBoxes.forEach(box => {
          if (boxid === box.id) {
            box.classList.add('mode-box-bars-selected');
            console.log("Selected:"+box.id);
          } else {
            box.classList.remove('mode-box-bars-selected');
            console.log("UNSelected:"+box.id);
          }
      });
    }

    function getHistoryPref(barscope=null, prefname=null) {
      if (barscope === null) {
        barscope = historyNameModifier();
      }
      if (barscope.startsWith(" ")) {
        barscope = barscope.substr(1);
      }

      if (prefname === null) {
        prefname = ".PREF."+curPresetName+" "+barscope;
      }
      console.log("getHistoryPref looking for /"+barscope+"/ prefname=/"+prefname+"/");
      if (isAvail(runHistory[prefname])) {
        if (!isAvail(runHistory[prefname].favorite)) {
          runHistory[prefname].favorite = true; // default is true for new ranges
          console.log("Created new favorite pref for /"+barscope+"/=true");
        }
      } else {
        runHistory[prefname] = {};
        runHistory[prefname].favorite = true;
        console.log("Creating new favorate pref for /"+barscope+"/=true");
      }
      console.log("getHistoryPref /"+prefname+"/="+runHistory[prefname].favorite);

      return runHistory[prefname];
    }

    function clearAllBarPresetButtons() {
      const modeBoxes = document.querySelectorAll('#barSelectContainer .mode-box-bars');
      // Loop through the NodeList of elements and print their IDs
      modeBoxes.forEach(box => {
        box.classList.remove('mode-box-bars-selected');
      });
    }

    // Function to change the selected hand in the pulldown menu
    function changeSelectedHand(hand, announce=false) {
      const handmodes = ['lh', 'rh', 'ht'];
      const selmodes = {lh:'left', rh:'right', ht:'both'};
      const modesels = {left:'lh', right:'rh', both:'ht'};

      handmodes.forEach(m => {
        const modeBox = document.getElementById(m);
        if (m === modesels[hand]) {
          modeBox.classList.add('selected');
        } else {
          modeBox.classList.remove('selected');
        }
      });

      setNoteFilters(); // when hand changes this needs to be updated immediately
      const s = computePriorStreakData(); // streak data is hand dependent
      displayPriorRunStats();

      if (s === null) {
        BPMRecommendedRange = [0, 10000];
        PriorStreak = [0,0,0];
        practiceStrategy = "";
      }
      if (announce) {
        sayTestParameters(true);
        displayTestStats(null,"reset");
      }

      clearStats(); // when changing hand, clear the stats

      loadTodayStats(); // reload any stats from current date for this hand
    }

    // Function to update the availability of selectable options in the pulldown menu
    function updateSelectableHands(leftAvailable, rightAvailable, bothAvailable) {

      return;  // for now do nothing
      let selHT = document.getElementById('ht');
      let selLH = document.getElementById('lh');
      let selRH = document.getElementById('rh');

      for (let i = 0; i < options.length; i++) {
        let option = options[i];
        let value = option.value;

        if ((value === 'left' && leftAvailable !== null) ||
            (value === 'right' && rightAvailable !== null) ||
            (value === 'both' && bothAvailable !== null)) {
          option.disabled = !(value === 'left' && leftAvailable) &&
                            !(value === 'right' && rightAvailable) &&
                            !(value === 'both' && bothAvailable);
        }
      }

      // Enable the pulldown menu
      handSelect.disabled = false;
    }


    function displayTestStats(notes, displayType) {
      let alerts = []; // alert structures for graph annotations
      let metmean = 0;
      let suppressBestBPM = false;

      if (wrongNotePlayed && preferences['enableTones'] && preferences['toneOnNoteFail'] !== 'none') {
          playMIDINote(preferences['toneOnNoteFail'],
          preferences['toneDuration']*2, preferences['toneVelocity'],
          preferences['toneFailVoice']);
      }

      // Increment the repetition count
      repCount++;

      // Calculate average BPM
      let duration = 1;
      let beatCount = 1;
      if (notes !== null && !wrongNotePlayed) {
        let stime = 0;
        let etime = 0;
        const hand = getSelectedHand();

        if (hand === 'both') {
          stime = Math.min(notes[0][0].sTime, notes[1][0].sTime);
          etime = Math.max(notes[0][notes[0].length-1].eTime, notes[1][notes[1].length-1].eTime);
          beatCount = Math.max(beatsToPlay[0], beatsToPlay[1]);
        } else if (hand === 'left') {
          stime = notes[0][0].sTime;
          etime = notes[0][notes[0].length-1].eTime;
          beatCount = beatsToPlay[0];
        } else {
          stime = notes[1][0].sTime;
          etime = notes[1][notes[1].length-1].eTime;
          beatCount = beatsToPlay[1];
        }
        duration = etime - stime;
        totalDuration += duration;
      }

      averageBPM = totalDuration === 0 ? 0 : Math.trunc((beatCount) * successCount / (totalDuration / 60000));
      let currentBPM = 0;
      if (notes !== null && !wrongNotePlayed) { // don't update currentBPM if we're in error state

        currentBPM = Math.trunc((beatCount) / (duration / 60000));
        if (typeof currentBPM !== "number") {
          warning("currentBPM is not a number. beatCount="+beatCount+" duration="+duration+
            " dur/60k="+duration/60000+" beatstoplay[0]="+beatsToPlay[0]+" beatsToPlay[1]="+beatsToPlay[1]+
            " stime="+stime+" etime="+etime);
            currentBPM = 0;
        }
        if (currentBPM >= maxBPM) {
          if (maxBPM != 0) {
            say("top speed "+ spokenNumber(currentBPM));
            suppressBestBPM = true;
          }
          maxBPM = currentBPM;
        }
      } else {
        currentBPM = 0;
      }

      const curAccuracy = Math.trunc(100 * successCount / ((successCount + failCount)?(successCount+failCount):1));

      // advise if outside of suggested range
      // Early in a streak (up to 3) we won't warn as this may be a "warmup".
      // Also, we will not warn about dragging if the current session accuracy is low
      // since the user may be slowing down to try to get back on track for accuracy.
      const maxSpeedWarning = 5;

      if (draggingWarning < maxSpeedWarning && currentBPM !== 0 && currentBPM < BPMRecommendedRange[0] && curStreak[2] > 3 && curAccuracy > 85) {
        say("dragging");
        draggingWarning++;
      }
      if (draggingWarning === maxSpeedWarning) {
        say("Dragging warnings suppressed");
        draggingWarning++;
      }
      if (rushingWarning < maxSpeedWarning && currentBPM > BPMRecommendedRange[1]) {
        say("rushing");
        rushingWarning++;
      }
      if (rushingWarning === maxSpeedWarning) {
        say("Rushing warnings suppressed");
        rushingWarning++;
      }

      const s = avail(testOptions.beatDur, 1/4);
      if (s === 1) {
        currentBPMNote = M["whole"];
      } else if (s === 1/2) {
        currentBPMNote = M["half"];
      } else if (s === 1/4) {
        currentBPMNote = M["quarter"];
      } else if (s === 1/8) {
        currentBPMNote = M["8th"];
      } else if (s === 1/16) {
        currentBPMNote = M["16th"];
      } else if (s === 1/32) {
        currentBPMNote = M["32nd"];
      } else {
        currentBPMNote = s; // just use a fraction
      }

      // Print repetition and BPM details
      console.log("Displaying success:"+successCount+" fail:"+failCount);
      let stats = "<table><tr style='border-bottom:1px solid black'>";
      stats += '<td style=vertical-align:top;border:none;padding-right:10px title="number of successful repetitions">REPS:<br><span class=bigstat style="color:green">' +
        successCount +
        '</span>&nbsp;' + curAccuracy + '%</td>';

      stats += '<td style=vertical-align:top;border:none title="number of note failures">NFail<br><span class=smallstat style="color:red">' +
        failCount + '</span></td>';
      stats += '<td style=vertical-align:top;border:none title="number of quality failures">QFail<br><span class="smallstat" style="color:red">' +
        softFailCount + '</span></td>';

      stats += '<td style=vertical-align:top;border:none;padding-right:10px title="speed of the most recent successful repetition" '+
                'onclick="setMetroBPM('+(currentBPM?Math.trunc(currentBPM):metroBPM)+', true)">BPM:&nbsp;'+currentBPMNote+'<br><span class=bigstat>' +
        (currentBPM?Math.trunc(currentBPM):"&nbsp;") + '</span></td>';
      stats += '<td style=vertical-align:top;border:none;padding-right:10px title="average speed over all REPS">Avg:<br><span class=smallstat>' +
        Math.trunc(averageBPM) + "</span></td>";
      stats += '<td style=vertical-align:top;border:none;padding-right:10px title="highest speed over all REPS">Max:<br><span class=smallstat>' +
        Math.trunc(maxBPM) + "</span></td>";
      stats += '<td style=vertical-align:top;border:none;padding-right:10px; title="highest speed with a score of EXCELLENT">Best:<br><span class=smallstat>' +
          Math.trunc(bestBPM) + "</span></td>";
      stats += '<td style=vertical-align:top;border:none;padding-right:10px title="average speed of EXCELLENT REPS">AvgHQ:<br><span class=smallstat>' +
          (numQBPM[0]?Math.trunc(sumQBPM[0]/numQBPM[0]):0) + "</span> <span style=font-size:small>("+numQBPM[0]+")</span></td>";
      stats += '<td style=vertical-align:top;border:none;padding-right:10px title="average speed of GOOD REPS">AvgMQ:<br><span class=smallstat>' +
          (numQBPM[1]?Math.trunc(sumQBPM[1]/numQBPM[1]):0) + "</span> <span style=font-size:small>("+numQBPM[1]+")</span></td>";
      stats += '<td style=vertical-align:top;border:none;padding-right:10px title="average speed of PASSING REPS">AvgLQ:<br><span class=smallstat>' +
              ((numQBPM[2])?Math.trunc((sumQBPM[2])/(numQBPM[2])):0) +
              "</span> <span style=font-size:small>("+(numQBPM[2])+")</span></td>";
      stats += '<td style=vertical-align:top;border:none;padding-right:10px title="average speed of QFAIL REPS (SLOW DOWN)">AvgQF:<br><span class=smallstat>' +
              ((numQBPM[3])?Math.trunc((sumQBPM[3])/(numQBPM[3])):0) +
              "</span> <span style=font-size:small>("+(numQBPM[3])+")</span></td>";
              let nonzero = (nnAccuracy.success+nnAccuracy.fail)?0:1;
              if (nonzero === 0 && nnAccuracy.fail === 0) {
                // never give 100% accuracy, if for no other reason that if there are only a small
                // number of runs our estimated accuracy can't be very certain.
                // we will estimate that there is a 0.5/numsuccess probability of error that we just
                // haven't been lucky enough to detect.
                nonzero = 1/(nnAccuracy.success+0.001);
              }
              //console.log("NONZERO="+nonzero);
              let displaynacc = (100*(nnAccuracy.success/(nnAccuracy.success+nnAccuracy.fail+nonzero)).toFixed(4)).toFixed(2);
              if (parseFloat(displaynacc) > 99.99) {
                displaynacc = 99.99;
              }
      stats += '<td style=vertical-align:top;border:none;padding-right:10px title="Note to note accuracy, what percentage of actual notes did you get right">NNAcc:<br><span class=smallstat>' +
              displaynacc +
              "</span><br><span style=font-size:x-small>("+nnAccuracy.success+":"+nnAccuracy.fail+")</td>";

      stats += '<td style=vertical-align:top;border:none;padding-right:10px;color:blue><span id=priorRunStatsTD title="Streak data from your prior session (before today)">PriorStrk:</span></td>';
      stats += '<td style=vertical-align:top;border:none;padding-right:10px;color:blue><span id=recommendedBPMTD title="Recommended practice speed of this preset today">RecBPM:</span></td>';

      stats += "</tr>";
      // compute quality metrics, hands togetherness
      // but only compute this if testing in hands together mode, and if
      // both sets of notes are the same length

      let strikes = 0; // three strikes gets you a slow down message

      stats += "<tr style='border:none'>";
      if (notes !== null && !wrongNotePlayed && getSelectedHand() === 'both' &&
          notes[0].length === notes[1].length && testOptions.constDur !== false) {

        let together = 0;
        let apart = 0;
        let htStat = new StatTracker();

        for (let i = 0; i < notes[0].length; i++) {
          apart += Math.abs(notes[0][i].sTime - notes[1][i].sTime);
          apart += Math.abs(notes[0][i].eTime - notes[0][i].eTime);

          let overlap = Math.min(notes[0][i].eTime, notes[0][i].eTime)
                - Math.max(notes[0][i].sTime, notes[1][i].sTime);
          htStat.addDataPoint(Math.trunc(100*overlap/(apart+overlap)));

          if (overlap < 0) overlap = 0;
          together += overlap;
        }

        const htqmerit = Math.trunc(100*(together/(together+apart)));
        stats += tdPreferenceDisplay("scoreHTQ", "HTQ", htqmerit, "", "Hands Together Quality Metric");

        if (preferences['scoreHTQ']) {
          strikes += strikeScore(htqmerit);
        }

      } else {
        stats += tdPreferenceDisplay("scoreHTQ", "HTQ", 0, "(na)", "Hands Together Quality Metric");
      }

      if (notes !== null && !wrongNotePlayed) {
        // Metric quality: were notes played for the correct amount of time?
        // Could track for left and right independently to find trouble spots.

        let metStat = new StatTracker();

        for (let h = 0; h < 2; h++) {
          for (let i = 0; i < notes[h].length; i++) {
            if (notes[h][i].eTime === null) {
              continue; // don't count notes that are not yet released.
            }

            let d = calcDur(h,i+noteScope[h].first);

            let std = avail(testOptions.beatDur, 1/4);

            const data = (notes[h][i].eTime - notes[h][i].sTime) * (parseFloat(std) / parseFloat(d));

            //console.log("METQ DP: h="+h+"i="+i+" data="+data+" d:"+d+" std:"+std+" et:"+notes[h][i].eTime+" st:"+notes[h][i].sTime);

            metStat.addDataPoint(
              data,
              [h,i]
            );
          }
        }
        metmean = metStat.calculateMean();
        const metsd = metStat.calculateStandardDeviation();
        let metmerit = metmean?Math.trunc(100*(1 - (metsd/metmean))):0;
        if (metmerit < 0) metmerit = 0;
        //console.log("Generating MetQ, prefs="+preferences['scoreMetQ']);
        stats += tdPreferenceDisplay('scoreMetQ', "MetQ", metmerit, "(" +
          Math.trunc(metmean)+"&plusmn;"+Math.trunc(metsd)+")", "Metric Quality, measures whether note durations are consistent with score");

        metStat.findOutliers("SHORT", "LONG", alerts);

        if (preferences['scoreMetQ']) {
          strikes += strikeScore(metmerit);
        }

        // Dynamic quality: were notes played at approximately the same loudness?
        // Could track this separately for left and right hands as well to see if one is overpowering

        let dynStat = new StatTracker();
        let minVelocity = 1000;
        let maxVelocity = 0;
        let noteMinVelocity = -1;
        let noteMaxVelocity = -1;

        for (let h = 0; h < 2; h++) {
          for (let i = 0; i < notes[h].length; i++) {
            if (notes[h][i].note.number === RESTNOTE) {
              // obviously rest notes have no velocity and shouldn't enter
              // into this metric
              continue;
            }
            const v = 100*notes[h][i].velocity;
            dynStat.addDataPoint(v, [h,i]);
            if (v > maxVelocity) {
              maxVelocity = v;
              noteMaxVelocity = [h,i];
            }
            if (v < minVelocity) {
              minVelocity = v;
              noteMinVelocity = [h,i];
            }
          }
        }
        const dynmean = dynStat.calculateMean();
        const dynsd = dynStat.calculateStandardDeviation();
        let dynmerit = Math.trunc(100*(1 - (dynsd/dynmean)));
        if (dynmerit < 0) dynmerit = 0;

        if (minVelocity < dynmean*0.6) {
          alerts.push({
            name: "QUIET",
            note: noteMinVelocity
          })
        }

        if (maxVelocity > dynmean*1.4) {
          alerts.push({
            name: "LOUD",
            note: noteMaxVelocity
          })
        }

        if (preferences['scoreDynQ']) {
          strikes += strikeScore(dynmerit);
        }
        stats += tdPreferenceDisplay('scoreDynQ', "DynQ", dynmerit, "("+Math.trunc(dynmean)+"&plusmn;"+Math.trunc(dynsd)+")", "Dynamic Quality metric, measures if loudness of notes is consistent with score.");

        // Legato quality: were consecutive notes in the same hand played with
        // little or no gap and little or no overlap?
        // Could track this separately for left and right hands as well to see
        // if one is better or worse

        let legSum = 0; // sum of all note durations
        let legError = 0; // sum of end/start gap or overlap errors
        let legNum = 0; // number of data points
        let gap = 0;
        let overlap = 0;
        let numgap = 0;
        let numoverlap = 0;
        let staccattoSum = 0;
        let noteMaxOverlap = -1;
        let maxOverlap = 0;

        for (let h = 0; h < 2; h++) {
          for (let i = 0; i < notes[h].length-1; i++) {
            // we will consider perfect to be 0 gap and 0 overlap, so take the absolute value
            // of the end of first note minus start of the next and accumulate this.
            legNum++;
            const notedur = notes[h][i].eTime - notes[h][i].sTime;
            legSum += notedur;
            let diff = notes[h][i].eTime - notes[h][i+1].sTime;
            if (diff > 0) {
              overlap += diff;
              numoverlap++;
              if (diff > maxOverlap) {
                maxOverlap = diff;
                noteMaxOverlap = [h,i];
              }
              // we allow up to 10% overlap of the second note's duration to
              // not be an error at all.
              // ENHANCEMENT: It might be a good idea to let the user determine
              // this percentage as a preference, because there is disagreement among teachers about
              // how much overlap, if any, is permissible.
              const tenpercent = 0.1*(notes[h][i+1].eTime - notes[h][i+1].sTime);
              diff -= tenpercent; // reduce diff by this amount
              if (diff < 0) diff = 0; // but don't let it go below zero

              // add nothing to staccatto sum because any overlap for staccatto is
              // a fail.

            } else if (diff < 0) {
              gap -= diff;
              numgap++;

              if ((1-diff) > notedur) {
                staccattoSum += 100;
              } else {
                staccattoSum += 100*(-diff/notedur);
              }
            }

            legError += Math.abs(diff);
          }
        }
        let legMerit = legSum?Math.trunc(100 - 100*(legError/legSum)):0;
        if (legMerit < 0) legMerit = 0;

        const avggap = numgap?Math.trunc(gap/numgap):0;
        const avgoverlap = numoverlap?Math.trunc(overlap/numoverlap):0;

        //console.log("maxOverlap="+maxOverlap+" avgoverlap="+avgoverlap+" avgdur="+duration/beatCount);
        if (noteMaxOverlap != -1 && maxOverlap > avgoverlap*2 &&
          maxOverlap > (0.1*(duration/beatCount))) {
            // we will always allow up to 10% of average note duration for overlap
            // because some teachers say that lagato has some overlap
          alerts.push( {
            name: "OVLP "+Math.trunc(100*maxOverlap/avgoverlap)+"%",
            note: noteMaxOverlap
          });
          //console.log("Pushed alert");
        }
        stats += tdPreferenceDisplay('scoreLegQ', "LegQ", legMerit, "(g:" + avggap + " o:" + avgoverlap + ")");

        // staccatto quality
        // staccatto quality will be considered 100% for a note that has a gap after it plays
        // that is greater than the notes duration. if gap is less than that, then quality is 100*gap/duration
        // if this is negative (i.e. overlap) then it's also 0 quality. The average quality of all notes is
        // then computed.
        const stacMerit = legNum?Math.trunc(staccattoSum/legNum):0;

        stats += tdPreferenceDisplay('scoreStaQ', "StaQ", stacMerit, "");

        // if both legQ and staQ are being scored, we will score strikes based
        // on which one is better. This allows the user to turn both metrics on
        // and then practice legatto vs. staccato at will. Presumably they're trying
        // to do one or the other if they have both turned on.

        if (preferences['scoreStaQ'] && preferences['scoreLegQ']) {
          if (stacMerit > legMerit) {
            strikes += strikeScore(stacMerit);
          } else {
            strikes += strikeScore(legMerit);
          }
        } else if (preferences['scoreStaQ']) {
            strikes += strikeScore(stacMerit);
        } else if (preferences['scoreLegQ']) {
            strikes += strikeScore(legMerit);
        }

      } else {
        // no stats due to error
        stats += tdPreferenceDisplay('scoreMetQ', "MetQ", 0, "(na)");
        stats += tdPreferenceDisplay('scoreDynQ', "DynQ", 0, "(na)");
        stats += tdPreferenceDisplay('scoreLegQ', "LegQ", 0, "(na)");
        stats += tdPreferenceDisplay('scoreStaQ', "StaQ", 0, "(na)");
      }

      // draw simple graph of number of runs with hq, mq, lq result.
      stats += "<td style=border:none><div id=curStreakDiv></div></td><td style=border:none><div id=maxStreakDiv></div></td>";
      let totqbpm = numQBPM[0]+numQBPM[1]+numQBPM[2]+numQBPM[3];
      if (totqbpm === 0) totqbpm = 1; // avoid div by 0 errors

      // draw a simple bargraph showing relative number of high, medium, low, qfail runs
      stats += "<td style=border:none><div style=position:relative;width:100%;height:50px;><div style='background-color:green;position:absolute;bottom:0;left:20%;right:20%;height:" +
        100*numQBPM[0]/totqbpm + "%'></div></td>";
      stats += "<td style=border:none><div style=position:relative;width:100%;height:50px;><div style='background-color:blue;position:absolute;bottom:0;left:20%;right:20%;height:" +
        100*numQBPM[1]/totqbpm + "%'></div></td>";
      stats += "<td style=border:none><div style=position:relative;width:100%;height:50px;><div style='background-color:yellow;position:absolute;bottom:0;left:20%;right:20%;height:" +
        100*numQBPM[2]/totqbpm + "%'></div></td>";
      stats += "<td style=border:none><div style=position:relative;width:100%;height:50px;display:block><div style='background-color:red;position:absolute;bottom:0;left:20%;right:20%;height:" +
        100*numQBPM[3]/totqbpm + "%'></div></td>";

      stats += "<td colspan=4 style=border:none;vertical-align:middle;>"+
        "<div style='border:1px solid green;border-radius:5px;padding-left:4px'>"+
          "<div style=display:flex;flex-direction:row;>"+
            "<div id=metronomeIcon onclick='startMetronome();' "+
                    "style='cursor:pointer;background-color:transparent;align-self:center;border:1px solid black;border-radius:4px;padding-top:3px;padding-left:3px;'>"+
                    metronomeIconSVG()+
            "</div>"+
            "<div  id=metronomeDiv style=display:flex;flex-direction:row>"+
            "</div>"+
          "</div>"+
          "<div id=smartMetronomeDiv onclick=cycleSmartMetronome()><i class=\"fa-solid fa-arrow-rotate-right\"></i>FIXED</div>"+
        "</div>"+
      "</td>";

      stats += "</tr>";

      if (strikes > 2) { // sloppy play! warn user
        softFailCount++;
        // IMPLEMENT: if preferences say that a softFail is a fail, that logic should be here
        // for example this would cause a soft fail to cancel this as a REP
      }
      stats += "</table>";

      if (strikes > 3) {
        strikes = 3;
      }
      //console.log("Final Strikes="+strikes);

      // keep track of high, medium, and low quality runs
      // high quality is 0 strikes, medium is 1 strike, low is
      // 2 or 3 strikes
      if (currentBPM > 0 && !wrongNotePlayed) {
        sumQBPM[strikes] += currentBPM;
        numQBPM[strikes]++;

        if (strikes === 0 && !wrongNotePlayed && currentBPM > bestBPM) {
          if (bestBPM != 0 && !suppressBestBPM) {
            // we used to report bestbpm but it got to be too much talking.

            //const words = new SpeechSynthesisUtterance("Best BPM "+currentBPM);
            //setTimeout(function(){window.speechSynthesis.speak(words);}, 1000);
          }
            bestBPM = currentBPM;
        }
      }

      messageStats(stats);
      updateMetronome();

      // update streaks
      if (displayType !== "reset") { // we don't update streaks if this is just a repaint
        if (!wrongNotePlayed) {
          for (let q = 0; q < strikes; q++) {
            curStreak[q] = 0; // too many strikes for this streak
            curStreakBPM[q] = 0;
          }
          for (let q = strikes; q <= 3; q++) {
            // All streaks greater than or equal to strikes are extended.
            // for example if strikes == 1 (medium quality) then both
            // medium and low quality streaks are extended
            curStreak[q]++
            curStreakBPM[q] += currentBPM;
            if (curStreak[q] > maxStreak[q]) {
              maxStreak[q] = curStreak[q];
              maxStreakBPM[q] = curStreakBPM[q];
            }
          }
        } else {
          // on notefail, all streaks end
          curStreak = [0,0,0,0];
          curStreakBPM = [0,0,0,0];

          if (metroSmart) {
            console.log("RESETTING metroSmartExtra");
            metroSmartExtra = 0;
            updateMetronome();
          }
        }
      }
      displayStreaks();
      displayPriorRunStats();

      if (displayType !== "reset") { // don't log a run on a simple reset of the stats screen
        if (!wrongNotePlayed) {
          drawNoteBarGraph(notes, strikes, alerts, metmean);
          logOneRun(duration, false, strikes, currentBPM);
          scrollToFirstNote();
        } else {
          logOneRun(0, true, 0, 0); // wrong note was played, log a notefail.
        }
      }

      function tdPreferenceDisplay(pref, tag, score, details, helpline="") {
        //console.log("Generating td for pref:/"+pref+"/ val="+preferences[pref]+" tag="+tag+" score="+score+" deets="+details);
        return "<td id=td"+pref+" style='vertical-align:top;border:none;padding-right:15px;" +
        "background-color:" + (preferences[pref]?statsColor:togglePrefColor) +
        ";opacity:" + (preferences[pref]?"1":"0.3") + "' " +
        "ontap=\"togglePref('" +pref+ "', null, 'prefIconToggle"+pref+"');\" " +
        "onclick=\"togglePref('" +pref+ "', null, 'prefIconToggle"+pref+"');\" " +
        "title=\""+helpline+"\""+
        "><i id='prefIconToggle"+pref+"' class=\"fa fa-toggle-"+(preferences[pref]?"on":"off")+"\"></i>"+ tag +
        ":<br><span class=bigstat style='color:" + colorcode(score) + "'>" + score + "</span>" +
        "<br>"+details+"</td>";
        ;
      }
    }

    function displayPriorRunStats() {

      const priorRun = document.getElementById("priorRunStatsTD");
      const rec = document.getElementById("recommendedBPMTD");

      if (priorRun !== null) {
        if (PriorStreak[0] > 0) {
          priorRun.innerHTML = '<span onclick=setMetroBPM('+PriorStreak[1]+',true)>PriorStrk:<br>' + PriorStreak[0]+"@"+PriorStreak[1]+"<br>"+avail(PriorStreak[3],"NA")+"%<br><span style=font-size:smaller>"+avail(PriorStreak[2],"")+"</span></span>";
        } else {
          priorRun.innerHTML = "PriorStrk:<br>NA</span>";
        }

      } else {
        console.log("PriorRun div is null");
      }

      if (rec != null) {
        if (BPMRecommendedRange[0] > 0) {
          rec.innerHTML = 'RecBPM:<br><span onclick=setMetroBPM('+BPMRecommendedRange[1]+',true)>'+
                   BPMRecommendedRange[0]+"-"+BPMRecommendedRange[1]+
                   "<br>("+practiceStrategy+")</span>";
        } else {
          rec.innerHTML = 'RecBPM:<br>NA';
        }
      } else {
        console.log("REC div is null");
      }
    }

    function setNoteFilters() {
      let hand = getSelectedHand();

      if (preferences['noteFilter'] === -1) {
        // do not use notefilters
        noteFilterHigh = -1;
        noteFilterLow = 1000;
        return;
      }
      let f = parseInt(preferences['noteFilter']);
      if (hand === 'both') {
        noteFilterHigh = Math.max(...notesToPlay.flat()) + f;
        noteFilterLow = Math.min(...notesToPlay.flat()) - f;
      } else if (hand === 'left') {
        noteFilterHigh = Math.max(...notesToPlay[0]) + f;
        noteFilterLow = Math.min(...notesToPlay[0]) - f;
      } else {
        noteFilterHigh = Math.max(...notesToPlay[1]) + f;
        noteFilterLow = Math.min(...notesToPlay[1]) - f;
      }
    }

    function spokenNumber(n) {
      n = Math.trunc(Number(n));
      if (n < 100) {
        return n;
      } else {
        const h = Math.trunc(n/100);
        const r = n%100;
        if (r === 0) {
          return h+" hundred";
        } else if (r < 10) {
          return String(h) + " oh " + String(r);
        } else {
          return String(h) + " " + String(r);
        }
      }
    }

    function colorcode(merit) {
      if (merit > 84) {
        return "green";
      } else if (merit > 69) {
        return "orange";
      } else {
        return "red";
      }
    }

    function strikeScore(merit) {
      if (merit > 84) {
        return 0;
      } else if (merit > 69) {
        return 1;
      } else if (merit > 50) {
        return 2;
      } else {
        return 3;
      }
    }

    function StatTracker() {
      // Internal variables
      let data = [];
      let notes = [];
      let sum = 0;
      let squaredSum = 0;

      // Function to reset the statistics
      this.reset = function() {
        data = [];
        sum = 0;
        squaredSum = 0;
        notes = [];
      };

      // Function to add a data point
      this.addDataPoint = function(value, note) {
        data.push(value);
        notes.push(note);
        sum += value;
        squaredSum += value * value;
      };

      // Function to calculate the mean
      this.calculateMean = function() {
        if (data.length === 0) {
          return 0;
        }
        return sum / data.length;
      };

      // Function to calculate the standard deviation
      this.calculateStandardDeviation = function() {
        if (data.length <= 1) {
          return 0;
        }
        let mean = this.calculateMean();
        let variance = squaredSum / data.length - mean * mean;
        return Math.sqrt(variance);
      };

      // Function to find outliers using IQR method
        this.findOutliers = function(messagelow, messagehigh, alerts) {
          if (data.length === 0) {
            return { outliers: [], outlierNotes: [] };
          }

          // Step 1: Create an array of objects containing value and note information
          let dataWithNotes = data.map((value, index) => ({ value, note: notes[index] }));

          // Step 2: Sort the dataWithNotes array based on values in ascending order
          dataWithNotes.sort((a, b) => a.value - b.value);

          // Step 3: Calculate Q1 and Q3
          const q1Index = Math.floor(dataWithNotes.length * 0.25);
          const q3Index = Math.floor(dataWithNotes.length * 0.75);
          const q1 = dataWithNotes[q1Index].value;
          const q3 = dataWithNotes[q3Index].value;

          // Step 4: Calculate IQR
          const iqr = q3 - q1;

          // Step 5: Define lower and upper bounds for outliers
          const lowerBound = q1 - 1.5 * iqr;
          const upperBound = q3 + 1.5 * iqr;

          // Step 6: Identify outliers and their corresponding notes
          const outliers = [];
          const outlierNotes = [];
          dataWithNotes.forEach((dataPoint) => {
            if (dataPoint.value < lowerBound || dataPoint.value > upperBound) {
              outliers.push(dataPoint.value);
              outlierNotes.push(dataPoint.note);
            }
          });

          for (let i = 0; i < outlierNotes.length; i++) {
            alerts.push({
              name: ((outliers[i]<lowerBound) ? messagelow : messagehigh),
              data: outliers[i],
              note: outlierNotes[i]
            })
          }

          return { outliers, outlierNotes };
        };

    }

    function calcDur(h, i) {
      let d = parseFloat(avail(testOptions.beatDur, 1/4));

      if (isAvail(durationsToPlay) && isAvail(durationsToPlay[h]) && durationsToPlay[h].length > 0) {
        d = parseFloat(durationsToPlay[h][i%(durationsToPlay[h].length)]); // durations array wraps
        //console.log("calcDur found wrapping d="+d+" for h="+h+" i="+i);
      }

      if (testOptions.swingEighths && d === 1/8) {
        const msg = "Graph SW8 orig="+d;
        if ( (i%2) === 1) {
          // short swung note
          d = d*2/3;
        } else {
          // long swung note
          d = d*4/3;
        }
        //console.log(msg+" adj="+d+" i="+i);
      } else {
        //console.log("Graph NOT SW8. sw8="+testOptions.swingEighths+" d="+d);
      }
      return parseFloat(d);
    }

    function clearStats() {
      //currentBPM = 0;
      averageBPM = 0;
      maxBPM = 0;
      bestBPM = 0;
      successCount = 0;
      failCount = 0;    // a fail could include soft fails depending on prefs
      softFailCount = 0;
      noteFailCount = 0;
      repCount = 0;
      totalDuration = 0;
      startTime = null;
      wrongNotePlayed = false;
      wrongNoteNumber = -1;
      numQBPM = [0,0,0,0];
      sumQBPM = [0,0,0,0];
      midiNotes = [];
      curStreak = [0,0,0,0];
      curStreakBPM = [0,0,0,0];
      maxStreak = [0,0,0,0];
      maxStreakBPM = [0,0,0,0];
      errorNotes = [[],[]];
      nnAccuracy = {success:0, fail:0};
      draggingWarning = 0;
      rushingWarning = 0;

      displayTestStats(null, "reset");
    }


     function clearPriorAndRec() {
       let ps = document.getElementById("priorRunStatsTD");
       if (ps !== null) {
         ps.innerHTML = "";
       }
       let rb = document.getElementById("recommendedBPMTD");
       if (rb !== null) {
         rb.innerHTML = "";
       }
     }

    let patternCanvas = null;
    let stripePattern = null;

    function createPattern() {
      // Create a pattern for the diagonal stripes
      patternCanvas = document.createElement('canvas');
      let patternCtx = patternCanvas.getContext('2d');
      patternCanvas.width = 20;
      patternCanvas.height = 20;

      patternCtx.clearRect(0, 0, patternCanvas.width, patternCanvas.height);

      patternCtx.strokeStyle = 'white';
      patternCtx.lineWidth = 6;
      patternCtx.beginPath();
      patternCtx.moveTo(0, patternCanvas.height);
      patternCtx.lineTo(patternCanvas.width, 0);
      patternCtx.stroke();
    }

    let priorOptions = null;

    function redrawNoteBarGraph() {
      if (priorOptions !== null) {
        drawNoteBarGraph(priorOptions[0].slice(), priorOptions[1], priorOptions[2].slice(), priorOptions[3]);
      } else {
        console.log("No prior options, not redrawing graph");
      }
    }

    function drawNoteBarGraph(notes, strikes, alerts, metmean) {
      if (notes === null) {
        return;
      }

      priorOptions = [notes.slice(), strikes, (alerts!==null)?alerts.slice():null, metmean];

      midiNotes = []; // we'll fill this in as we traverse the note data

      //console.log("Drawing graph notes="+notes);
      const graphCanvas = document.getElementById('graphCanvas');
      const s = getComputedStyle(graphCanvas);
      graphCanvas.width = parseInt(s.width);
      graphCanvas.height = parseInt(s.height);
      console.log("Graph w="+graphCanvas.width+" h="+graphCanvas.height);

      if (canvasLarge === null) {
        canvasLarge = document.createElement("canvas");
        canvasLarge.width = Math.trunc(parseInt(s.width)*MAXGRAPHMAG);
        canvasLarge.height = parseInt(s.height)*MAXGRAPHMAG;
        canvasLarge.style.display = "none";
        document.body.appendChild(canvasLarge);
      }
      canvasLarge.width = parseInt(s.width)*MAXGRAPHMAG;
      canvasLarge.height = parseInt(s.height)*MAXGRAPHMAG;

      // reset magnification and offset.
      graphMag = DEFAULTGRAPHMAG;
      graphOffset = {x:0, y:0};

      const ctx = canvasLarge.getContext('2d');

      if (patternCanvas === null) {
        createPattern();
        // Create the fill pattern from the patternCanvas
        stripePattern = ctx.createPattern(patternCanvas, 'repeat');
      }

      // Clear the canvas
      ctx.fillStyle = "rgba(255,255,255,0.1)";
      ctx.fillRect(0, 0, canvasLarge.width, canvasLarge.height);

      // Define the bar dimensions
      const hand = getSelectedHand();
      let numnotes = 0;
      if (hand === 'both') {
        numnotes = notes[0].length+notes[1].length;
      } else if (hand === 'right') {
        numnotes = notes[1].length;
      } else {
        numnotes = notes[0].length;
      }
      const barSpacing = 5;
      const barHeight = Math.trunc(canvasLarge.height/(numnotes))-barSpacing;
      const noteSpacing = (barHeight+barSpacing);

      // Compute the scaling factor for the horizontal axis
      let totNotes;
      let earlySTime;
      let lateETime;

      if (hand === 'left') {
        totNotes = notes[0].length - 1;
        earlySTime = notes[0][0].sTime;
        lateETime = notes[0][notes[0].length-1].eTime;
      } else if (hand === 'right') {
        totNotes = notes[1].length - 1;
        earlySTime = notes[1][0].sTime;
        lateETime = notes[1][notes[1].length-1].eTime;
      } else {
        totNotes = notes[0].length-1 + notes[1].length-1
        earlySTime = Math.min(notes[1][0].sTime, notes[0][0].sTime);
        lateETime = Math.max(notes[1][notes[1].length-1].eTime, notes[0][notes[0].length-1].eTime);
      }

      const hmargin = 50*MAXGRAPHMAG; // horizontal margin on both left and right.

      const maxDuration = lateETime - earlySTime;
      const scaleFactor = (maxDuration === 0) ? 1 : (canvasLarge.width-2*hmargin) / maxDuration;

      // Draw scale
      const scaleMarkerWidth = 10; // Width of the scale marker line
      const scaleMarkerHeight = 5; // Height of the scale marker line

      ctx.fillStyle = "black";
      ctx.font = "40px Arial";
      let fontHeight = 40;
      ctx.textAlign = "left";
      ctx.textBaseline = "bottom";
      ctx.lineWidth = 3;

      // Calculate the length of the scale marker line
      const scaleMarkerLength = 100 * scaleFactor; // 100ms scaled to the current scaleFactor

      const scaleX = 20; // canvasLarge.width-scaleMarkerLength-40;
      const scaleY = canvasLarge.height/2;
      ctx.fillText("100 ms", scaleX, scaleY-5); // Draw the scale label above the marker

      // Draw the scale marker line
      ctx.beginPath();
      ctx.moveTo(scaleX, scaleY); // Move to the starting position of the scale marker
      ctx.lineTo(scaleX + scaleMarkerLength, scaleY); // Draw the line
      ctx.stroke();

      // Draw the two vertical ticks at the ends of the scale marker line
      ctx.beginPath();
      ctx.moveTo(scaleX, scaleY-10); // Top vertical tick
      ctx.lineTo(scaleX, scaleY+10);
      ctx.moveTo(scaleX + scaleMarkerLength, scaleY-10); // Bottom vertical tick
      ctx.lineTo(scaleX + scaleMarkerLength, scaleY+10);
      ctx.stroke();

      // Draw the length of one beat
      const beatLength = metmean*scaleFactor;
      const beatY = scaleY+70;
      ctx.fillText("beat = "+Math.trunc(metmean)+" ms", scaleX, beatY-10); // Draw the beat label above the marker

      // Draw the scale marker line
      ctx.beginPath();
      ctx.moveTo(scaleX, beatY); // Move to the starting position of the scale marker
      ctx.lineTo(scaleX + beatLength, beatY); // Draw the line
      ctx.stroke();

      // Draw the two vertical ticks at the ends of the scale marker line
      ctx.beginPath();
      ctx.moveTo(scaleX, beatY-10); // Top vertical tick
      ctx.lineTo(scaleX, beatY+10);
      ctx.moveTo(scaleX + beatLength, beatY-10); // Bottom vertical tick
      ctx.lineTo(scaleX + beatLength, beatY+10);
      ctx.stroke();

      // Draw the note bars
      const barcolors = ["rgba(0,0,255,255)", "rgba(255,0,0,255)"];

      let nextnote = [0,0];  // next notes for left and right hand
      let h = 0; // which hand to graph next
      let i = 0; // which note to graph next
      let totgraphed = 0;

      //
      // Main Loop that Draws Note Bars on Graph
      //
      while (true) {
        // find out which hand plays next
        if (nextnote[0] >= notes[0].length && nextnote[1] >= notes[1].length) {
          break; // we're out of notes.
        }
        if (hand === 'right') {
          h = 1;
        } else if (hand === 'left') {
          h = 0;
        } else {
          h = -1; // have not chosen yet
          if (nextnote[0] >= notes[0].length) {
            h = 1; // we ran out of lefthand notes so right hand wins
          } else if (nextnote[1] >= notes[1].length) {
            h = 0;
          }

          if (h === -1) {
            //console.log("Choosing hand");
            // we failed to find a hand based on just running out of notes.
            // that means both hands have notes.
            // Whichever note has an earlier bar number (or note number) wins. If they're tied, left hand wins.
            let leftbeat;
            let rightbeat;
            if (testOptions !== null && avail(testOptions.graphOrder, null) === "bar") {
              // go bar-by-bar. This is better for songs that have differing notes/durations
              // for the left and right hands.
              leftbeat = Math.trunc((noteStartBeat[0][nextnote[0]+noteScope[0].first])/testOptions.beatsPerBar);
              rightbeat = Math.trunc((noteStartBeat[1][nextnote[1]+noteScope[1].first])/testOptions.beatsPerBar);
            } else if (testOptions !== null && avail(testOptions.graphOrder, null) === "beat") {
              // go beat-by-beat. This is sometimes better looking depending on the song.
              leftbeat = noteStartBeat[0][nextnote[0]+noteScope[0].first];
              rightbeat = noteStartBeat[1][nextnote[1]+noteScope[1].first];
            } else {
              // go by note number. This is better for tests that have a 1:1 correspondence of notes
              // between the left and right hands, such as scales and arpeggios.
              leftbeat = nextnote[0];
              rightbeat = nextnote[1];
            }
            //console.log("LeftBeat:"+leftbeat+" Right:"+rightbeat);
            if (rightbeat <= leftbeat) { // ties go to right hand.
              h = 1;
            } else {
              h = 0;
            }
          }
        }

        if (nextnote[h] >= notes[h].length) {
          break; // oops we ran out of notes in both hands, we're done
        }
        i = nextnote[h];
        nextnote[h]++; // increment for next iteration

        //console.log("graphing note hand:"+h+" noteindex:"+i+" len:"+notes[h].length);

        const n = notes[h][i];
        const sTime = n.sTime - earlySTime;
        const eTime = n.eTime - earlySTime;
        const w = (eTime - sTime) * scaleFactor;

        // take into account note durations here

        const d = calcDur(h,i+noteScope[h].first);
        //console.log("d:"+d+" metmean="+metmean);
        const adjmetmean = metmean*d/avail(testOptions.beatDur, 1/4);
        //console.log("Duration of note h="+h+"i="+(i+noteScope[h].first)+":dur="+d+" metmean:"+adjmetmean+" beatdur:"+testOptions.beatDur);
        const wmean = adjmetmean * scaleFactor;

        // we conveniently have everything we need to set up the midi replay
        // data structure right here. So, although it doesn't have much to do
        // with the graph, go ahead and grab the data.
        //console.log("New note:"+n.note);

        if (n.note.number !== RESTNOTE) {
          const tt = "+"+(sTime).toString();
          //console.log("Pushing new note:"+n.note.number+" et:"+n.eTime+" st:"+n.sTime+" v:"+n.velocity+" tt:"+tt);
          const nn = new Note(n.note.number);
          nn.options = {
            duration:   n.eTime - n.sTime,
            attack:     n.velocity,
            time:       tt
          }
          midiNotes.push(nn);
        }

        // Draw bar
        //console.log("Drawing bar, flushright="+flushRight);
        const x = (!flushRight)?(sTime * scaleFactor+hmargin):40;

        const y = totgraphed * noteSpacing;

        // Draw rectangular outline with 100% opacity
        ctx.strokeStyle = `rgba(${h === 0 ? 0 : 255}, 0, ${h === 1 ? 0 : 255}, 1)`;
        ctx.strokeRect(x, y, w, barHeight);

        // fill in the rectangle proportional to square of loudness (works better if squared)
        let speed = Math.trunc(100*notes[h][i].velocity);
        // Set opacity based on velocity (loudness)
        ctx.fillStyle = `rgba(${h === 0 ? 0 : 255}, 0, ${h === 1 ? 0 : 255}, ${(speed/100)*(speed/100)})`;

        // Fill the bar with adjusted opacity
        ctx.fillRect(x, y, w, barHeight);

          // see if there is an alert for this note
          let numalertsfound = 0;
          for (let a = 0; a < alerts.length; a++) {
            //console.log("Alerts["+a+"]="+alerts[a].name+" n="+alerts[a].note);
            if (alerts[a].note && alerts[a].note[0] === h && alerts[a].note[1] === i) {
              // found an alert for this note, highlight it
              //console.log("Found an alert on note:"+alerts[a].note);

              if (alerts[a].name.startsWith("LONG") || alerts[a].name.startsWith("SHORT")) {
                ctx.textAlign = "left";
                ctx.textBaseline = "middle";
                ctx.fillStyle = barcolors[h];
                ctx.font = fontHeight+"px Arial";
                console.log("ADDED ALERT:"+alerts[a].name+" at x="+(x+wmean)+" y="+y+barHeight/2)
                ctx.fillText(alerts[a].name, x+wmean+10, y+barHeight/2);
              } else if (alerts[a].name.startsWith("OVLP")) {
                // draw a striped rectangle showing the overlap visually
                const nextstart = notes[h][i+1].sTime - earlySTime;
                const x2 = nextstart * scaleFactor + hmargin;

                //ctx.strokeRect(x2,y,w-(x2-x),barHeight*2);
                ctx.setLineDash([]);  // turn of dashes
                ctx.fillStyle = stripePattern;
                ctx.fillRect(x2,y,w-(x2-x),barHeight*2);
                ctx.textAlign = "left";
                ctx.textBaseline = "middle";
                ctx.fillStyle = barcolors[h];
                ctx.font = fontHeight+"px Arial";
                console.log("ADDED ALERT:"+alerts[a].name+" at x="+(x+wmean)+" y="+y+barHeight/2)
                ctx.fillText(alerts[a].name, x+wmean+10, y+barHeight/2);
                //console.log("ADDED ALERT OVERLAP x="+x+" x2="+x2);
              }

              ctx.setLineDash([]);  // turn of dashes

              numalertsfound++;
            }
          }

          // Show a dashed line of
          // the "correct" length of this note given its duration and BPM figures.
          // So the steps are: (1) take the BPM figure computed by stats and then figure out
          // the number of milliseconds that implies for beatDur. Then scale that to the dur of
          // this note. Then draw a dashed line starting where this note started and ending
          // at the "ideal" length figure. Cap it off with a vertical stroke at the end of the dashed
          // line. Dashed lines are color coded depending on how good or bad the actual duration was
          // compared to the ideal duration, with worse durations getting thicker and redder lines.
          // Takes into account swung eighths too.

          ctx.save();

          // draw different emphasis depending on how close the expected duration was
          // the played duration
          let err = adjmetmean/(eTime - sTime);
          if (err > 1) { // short note
            err = 1/err; // gives us value between 0 and 1 where 1 === perfect
          }

          if (err > 0.9) { // good match
            ctx.strokeStyle = "green";
            ctx.setLineDash([4,12]);
            ctx.lineWidth = 4;
          } else if (err > 0.70) { // not so good
            ctx.strokeStyle = "orange";
            ctx.setLineDash([12,12]);
            ctx.lineWidth = 6;
          } else { // bad
            ctx.strokeStyle = "red";
            ctx.setLineDash([12,4]);
            ctx.lineWidth = 9;
          }

          ctx.fillStyle = "black";

          // draw the ideal duration dashed line
          const adj = barHeight/2;
          ctx.beginPath();
          ctx.moveTo(x, y+adj);
          ctx.lineTo(x+wmean, y+adj);
          ctx.stroke();
          // cap it off with a solid line
          ctx.beginPath();
          ctx.moveTo(x+wmean, y+adj-adj/2);
          ctx.lineTo(x+wmean, y+adj+adj/2);
          ctx.setLineDash([]);
          ctx.stroke();
          ctx.restore();


          if (barHeight < 18) {
            fontHeight = 11;
          } else {
            fontHeight = Math.trunc(barHeight*0.7);
            if (fontHeight > 50) {
              fontHeight = 50;
            }
          }
          // need a smaller font for the speed data because it's stacked
          ctx.font = fontHeight + "px Arial";

          // find finger, if any available
          let finger = "";
          if (isAvail(fingersToPlay) && isAvail(fingersToPlay[h])) {
                if (isAvail(fingersToPlay[h][i+noteScope[h].first]) && fingersToPlay[h][i+noteScope[h].first] !== -1) { // -1 means rest note which of course has no "finger"
                  finger = fingersToPlay[h][i+noteScope[h].first];
                }
          }

          // find duration, if any available
          let dur = "";
          let note = prnote(notes[h][i].note);
          if (notes[h][i].note.number === RESTNOTE) {
            dur = restWithDur(h, i);
            note = "";
            ctx.font = 1.5*fontHeight + "px Arial";
            finger = "";
          } else {
            dur = prDur(h, i);
          }

          // draw the note name to left of bar
          ctx.fillStyle = barcolors[h];
          ctx.textAlign = "right";
          ctx.textBaseline = "top";

          ctx.fillText(note+dur+"  ", x, y+barHeight/5);
          ctx.font = Math.trunc(fontHeight*.6) + "px Arial";
          ctx.fillText(finger+" ", x, y+barHeight/5);

          // Show velocity
          if (speed < 70) {
            ctx.fillStyle = "black"; // easier to see if low opacity
          } else {
            ctx.fillStyle = "white";
          }

          ctx.textAlign = "left";
          ctx.textBaseline = "bottom";

          let speednotation = "";
          if (notes[h][i].note.number === RESTNOTE) {
            speednotation = "";
            speed = "rest";
          } else if (speed < 25) {
            speednotation = M["piano"]+M["piano"]+M["piano"];
          } else if (speed < 33) {
            speednotation = M["piano"]+M["piano"];
          } else if (speed < 42) {
            speednotation = M["piano"];
          } else if (speed < 51) {
            speednotation = M["mezzo"]+M["piano"];
          } else if (speed < 63) {
            speednotation = M["mezzo"]+M["forte"];
          } else if (speed < 75) {
            speednotation = M["forte"];
          } else if (speed < 88 ) {
            speednotation = M["forte"]+M["forte"];
          } else {
            speednotation = M["forte"]+M["forte"]+M["forte"];
          }

          // need smaller font for speed data because it's stacked
          ctx.font = fontHeight + "px Arial";

          ctx.fillText(speed, x+3, y+barHeight+1);
          if (speednotation !== "(rest)") {
            ctx.font = 2*fontHeight + "px 'Noto Music'";
          }
          ctx.fillText(speednotation, x+3, y+barHeight+1-fontHeight);
          totgraphed++; // increment total notes graphed, this is used to find y coordinate
    }

    if (!flushRight) {
      const evalarea = document.getElementById("runEvalArea");
      ctx.font = "120px Arial";
      if (strikes > 2) {
        ctx.fillStyle = "red";
        ctx.textBaseline = "bottom";
        ctx.textAlign = "left";
        //ctx.fillText("SLOW DOWN!", 10, canvasLarge.height-30*MAXGRAPHMAG);
        evalarea.innerHTML = "QFAIL";
        evalarea.style.color = "red";
      } else if (strikes === 2) {
        ctx.fillStyle = "orange";
        ctx.textBaseline = "bottom";
        ctx.textAlign = "left";
        //ctx.fillText("PASSING", 10, canvasLarge.height-30*MAXGRAPHMAG);
        evalarea.innerHTML = "PASSING";
        evalarea.style.color = "ORANGE";
      } else if (strikes === 1) {
        ctx.fillStyle = "blue";
        ctx.textBaseline = "bottom";
        ctx.textAlign = "left";
        //ctx.fillText("GOOD", 10, canvasLarge.height-30*MAXGRAPHMAG);
        evalarea.innerHTML = "GOOD";
        evalarea.style.color = "blue";
      } else {
        ctx.fillStyle = "green";
        ctx.textBaseline = "bottom";
        ctx.textAlign = "left";
        //ctx.fillText("EXCELLENT", 10, canvasLarge.height-30*MAXGRAPHMAG);
        evalarea.innerHTML = "EXCELLENT!";
        evalarea.style.color = "green";
      }
    }

    if (metroSmart) {
      console.log("Updating smart metronome. strikes:"+strikes+" incstr:"+preferences.metroSmartIncStrikes+" inc:"+preferences.metroSmartInc);

      if (strikes <= preferences.metroSmartIncStrikes) {
        metroSmartExtra += preferences.metroSmartInc;
        if (metroSmartExtra > preferences.metroSmartExtraMax) {
          metroSmartExtra = preferences.metroSmartExtraMax;
        }
        updateMetronome();
      } else if (strikes >= preferences.metroSmartResetStrikes || wrongNotePlayed) {
        console.log("RESETTING metroSmartExtra");
        metroSmartExtra = 0;
        updateMetronome();
      }
    }

    let delay = 300; // used to schedule various tones out into the future
    if (!wrongNotePlayed && preferences['enableTones']) {
      if (strikes > 2) {
        if (preferences['toneOnQFail'] !== 'none') {
          playMIDINote(preferences['toneOnQFail'],
            preferences['toneDuration'], preferences['toneVelocity'],
            preferences['toneFailVoice']);
            delay = preferences['toneDuration'];
        }
      } else if (strikes === 2) {
        if (preferences['toneOnPassing'] !== 'none') {
          playMIDINote(preferences['toneOnPassing'],
            preferences['toneDuration'], preferences['toneVelocity'],
            preferences['toneSuccessVoice']);
            delay = preferences['toneDuration'];
        }
      } else if (strikes == 1) {
        // play both the passing and good tones one after the other
        if (preferences['toneOnGood'] !== 'none') {
          playMIDINote(preferences['toneOnPassing'],
            preferences['toneDuration'], preferences['toneVelocity'],
            preferences['toneSuccessVoice']);

          playMIDINote(preferences['toneOnGood'],
            preferences['toneDuration'], preferences['toneVelocity'],
            preferences['toneSuccessVoice'], 1.2*preferences['toneDuration']);

          delay = 2.5*preferences['toneDuration'];
        }
      } else {
        // play passing, good, and excellent tones
        if (preferences['toneOnExcellent'] !== 'none') {
          playMIDINote(preferences['toneOnPassing'],
            preferences['toneDuration'], preferences['toneVelocity'],
            preferences['toneSuccessVoice']);
          setTimeout( function() {
            playMIDINote(preferences['toneOnGood'],
              preferences['toneDuration'], preferences['toneVelocity'],
              preferences['toneSuccessVoice']);
          }, 1.2*preferences['toneDuration']);
          setTimeout(function() {
            playMIDINote(preferences['toneOnExcellent'],
              preferences['toneDuration'], preferences['toneVelocity'],
              preferences['toneSuccessVoice']);
          }, 2.4*preferences['toneDuration'])

          delay = 3.5*preferences['toneDuration'];
        }
      }

      // play an indication if reps is a multiple of 10
      if (successCount > 0 && (successCount%10) === 0) {
        let sc = successCount;
        // first a lower tone if multiples of 50
        for (let i = 0; Math.trunc(sc/50) > 0; i++) {
          setTimeout(function() {
              playMIDINote("C6", 120, 127, preferences['toneFailVoice']);
          }, delay + i*200);
          sc -= 50;
          delay += 250;
        }
        for (let i = 0; i < sc/10; i++) {
          setTimeout(function() {
              playMIDINote("C7", 120, 127, preferences['toneFailVoice']);
          }, delay + i*200);
        }
        say(successCount + " Reps");
      }
    }
    if (!wrongNotePlayed) {
      graphShow();
    } else {
      if (metroSmart) {
        metroSmartExtra = 0;
        updateMetronome();
      }
    }
  }

  function graphShow() {
    const graphCanvas = document.getElementById('graphCanvas');
    const ctx = graphCanvas.getContext("2d");

    if (canvasLarge === null) {
      return; // no graph yet
    }
    const ctxLarge = canvasLarge.getContext("2d");

    ctxLarge.setLineDash([7,7]);
    //ctxLarge.strokeRect(0,0,canvasLarge.width,canvasLarge.height);

    ctx.clearRect(0,0,graphCanvas.width,graphCanvas.height);

    console.log("ShowGraph: cw="+canvasLarge.width+" ch="+canvasLarge.height+" gw="+graphCanvas.width+" gh="+graphCanvas.height);
    ctx.drawImage(canvasLarge, graphOffset.x, graphOffset.y, canvasLarge.width, canvasLarge.height,
                          0, 0, Math.trunc(canvasLarge.width*graphMag), Math.trunc(canvasLarge.height*graphMag));
    ctx.save();
    ctx.setLineDash([2,2]);
    ctx.strokeStyle = "orange";
    ctx.strokeRect(0,0,graphCanvas.width,graphCanvas.height);

    ctx.restore();
  }

  function prDur(h, i) {
    let dur = "";
    if (isAvail(durationsToPlay) && isAvail(durationsToPlay[h])
          && durationsToPlay[h].length > 0) {
        dur = durationsToPlay[h][i%durationsToPlay[h].length];
        dur = durUnicode(dur);
    }
    return dur;
  }

  function durFrac(dur) {
    dur = dur.toString();
    const durmap = { "1":"1/1", "1.5": "1.5/1",
      "0.5":"1/2", "0.75":"3/4", "0.25":"1/4", "0.375":"3/8",
      "0.125":"1/8", "0.0625":"1/16", "0.1875":"3/16", "0.5625":"9/16",
      "0.03125":"1/32", "0.09375":"3/32"
    };
    if (isAvail(durmap[dur])) {
      dur = durmap[dur];  //"<span style=font-size:10px>"+durmap[dur]+"</span>";
    }
    return dur;
  }

  function graphTap(event) {
    const canvas = document.getElementById('graphCanvas');
    const rect = canvas.getBoundingClientRect();
    const tapX = event.clientX - rect.left; // X-coordinate of the tap relative to the canvas
    const tapY = event.clientY - rect.top;

    // Calculate the center of the canvas
    const centerX = canvas.width / 2;
    const oneHalfY = canvas.height / 2;

    // Set flushRight based on the tap position
    if (tapY > oneHalfY) {
          // don't count it close to the top of the canvas because there are other controls there and the user's
          // finger could touch the top of the canvas sometimes.
          flushRight = tapX < centerX;
          redrawNoteBarGraph();
    }
  }

  function noteDisplayAreaMenuShow() {
    console.log("Showing noteDisplayAreaMenu");
    const menu = document.getElementById("noteDisplayAreaMenuDiv");
    const button = document.getElementById("noteDisplayAreaMenuButton");

    // Get the position and dimensions of the button
    const buttonRect = button.getBoundingClientRect();

    // Calculate the position for the menu
    const menuLeft = buttonRect.left;
    const menuTop = buttonRect.top; //buttonRect.top + buttonRect.height / 2 - menu.clientHeight / 2;

    console.log("left:"+menuLeft+" top:"+menuTop);

    // Set the menu's position
    menu.style.left = menuLeft + "px";
    menu.style.top = menuTop + "px";

    // Display the menu
    menu.style.display = "block";

  }


// Attach the graphTap function to the onload event of the window
// and initialized a bunch of other things.

window.addEventListener('load', function () {

  redirectConsole();

  // Attach event listeners to the canvas for tap and click events
  const canvas = document.getElementById('graphCanvas');
  canvas.addEventListener('mousedown', graphDragStart);
  canvas.addEventListener('mousemove', graphDragMove);
  canvas.addEventListener('mouseup', graphDragEnd);

  canvas.addEventListener('touchstart', graphDragStart);
  canvas.addEventListener('touchmove', graphDragMove);
  canvas.addEventListener('touchend', graphDragEnd);

  //warning("loading prefs");
  //loadPrefs();

  loadPrefs();

  //warning("displaying empty results");
  displayTestStats(null, "reset");

  document.getElementById('pedalSymbolDiv').innerHTML = M["pedal"];
  setTimeout(function() {
    document.getElementById('pedalSymbolDiv').innerHTML = M["pedalup"];
  }, 2000);

  // set up the START/STOP button so a long tap both stops the current test and goes right
  // to the skills map

  setupLongPressStart();

});

function setupLongPressStart() {
  const button = document.getElementById('testNotesButton');
  let pressTimer = null;

  function longPressStart() {
    // on a long press we will both finish the current test and go to the skill map
    testNotes();
    setTimeout(showSkillMap, 1000); // do this a bit in the future so the user sees the test end.
  }

  button.addEventListener('mousedown', function(e) {
    // Prevent firing in case of right click
    if (e.button === 2) return;

    if (currentState === STATE.TESTING_NOTES) {
      pressTimer = window.setTimeout(function() { longPressStart(); }, 800); // 800ms for long press
    }

  });

  button.addEventListener('mouseup', function() {
    if (pressTimer !== null) {
      clearTimeout(pressTimer); // Prevent long press action if the button is released
      pressTimer = null;
    }
  });

  button.addEventListener('mouseleave', function() {
    clearTimeout(pressTimer); // Cancel on mouse leave
    pressTimer = null;
  });

  // Touch Events
  button.addEventListener('touchstart', function(e) {
    pressTimer = window.setTimeout(function() { longPressStart(); }, 800); // 800ms for long press
  }, {passive:false});

  button.addEventListener('touchend', function(e) {
    //e.preventDefault();
    clearTimeout(pressTimer); // Prevent long press action if the touch is ended
    pressTimer = null;
  }, {passive:false});

  button.addEventListener('touchcancel', function() {
    clearTimeout(pressTimer); // Cancel on touch cancel
    pressTimer = null;
  });

  // To prevent firing the short press action after a long press
  button.addEventListener('click', function(e) {
    console.log("START CLICK");
    e.preventDefault();
    if (pressTimer) {
      clearTimeout(pressTimer);
      pressTimer = null;
    }
    testNotes(); // Call short press action if the timer hasn't been cleared
  });

}


let dragOrigin = null;
let startOffset = null;

function graphDragStart(event) {
  dragOrigin = {x:0,y:0};
  //warning("Event type:"+event.type);
  if (event.type === 'touchstart') {
    dragOrigin.x = event.touches[0].clientX;
    dragOrigin.y = event.touches[0].clientY;
    //warning("Touches:"+ event.touches.length+" x:"+dragOrigin.x+" y:"+dragOrigin.y);
    if (typeof dragOrigin.x === 'undefined') {
      dragOrigin.x = 0;
    }
  } else {
    dragOrigin.x = event.clientX;
    dragOrigin.y = event.clientY;
  }

  if (dragOrigin.x > graphCanvas.width*0.66 || graphMag === DEFAULTGRAPHMAG) { // ignore touchstart near the right edge, or if not magnified, so its easier to scroll the window
    dragOrigin = null;
    return;
  }
  event.preventDefault();
  startOffset = {x:0,y:0};
  startOffset.x = graphOffset.x;
  startOffset.y = graphOffset.y;
  graphCanvas.style.zIndex = 10000;
  //warning("DRAGSTART: offx:"+dragOrigin.x+" offy:"+dragOrigin.y+" gx"+graphOffset.x+" gy:"+graphOffset.y+" cw:"+graphCanvas.width);
}

function graphDragMove(event) {
  if (graphMag === DEFAULTGRAPHMAG || graphOffset === null) {
    return; // no dragging needed when half magnified because entire graph fits on screen
  }
  //warning("Event type:"+event.type);
  event.preventDefault();
  if (dragOrigin === null) { // there's been no touchstart inside the window
    return;
  }
  let x;
  let y;
  if (event.type === 'touchmove') {
    x = event.touches[0].clientX;
    y = event.touches[0].clientY;
    //warning("Touches:"+ event.touches.length+" x:"+x+" y:"+y);
  } else {
    x = event.clientX;
    y = event.clientY
  }

  graphOffset.x = startOffset.x+dragOrigin.x-x;
  graphOffset.y = startOffset.y+dragOrigin.y-y;
  //warning("DRAG: offx:"+graphOffset.x+" offy:"+graphOffset.y+" x:"+x+" y:"+y+" startx:"+startOffset.x+" starty:"+startOffset.y);
  graphShow();
}

function graphDragEnd(event) {
  event.preventDefault();
  dragOrigin = null;
  startOffset = null;
  graphCanvas.style.zIndex = 0;
}

function magnifyScreen(dir) {
  if (dir === -1) {
    graphMag *= 4/5;
  } else {
    graphMag *= 5/4;
  }

  if (graphMag > MAXGRAPHMAG) {
    graphMag = MAXGRAPHMAG;
  } else if (graphMag <= DEFAULTGRAPHMAG) {
    graphMag = DEFAULTGRAPHMAG;
    graphOffset = {x:0,y:0}; // reset when things get small enough to show entire thing on the screen
  }
  graphShow();
}

function clearPlayedNotes(matchhand=null, firstnon=-1) {

  if (notesToPlay === null || !isAvail(notesToPlay) || notesToPlay.length === 0 ||
      notesToPlay[0].length + notesToPlay[1].length === 0) {
    return;
  }

  const en = document.getElementById("ntp_error_note");
  if (en) {
    en.parentNode.style.lineHeight = "1.6";
    en.remove(); // remove the error note.
  }

  wrongNotePlayed = false;
  wrongNoteNumber = -1;

  for (let h = 0; h < 2; h++) {
    for (let i = 0; i <= notesToPlay[h].length; i++) {
      if (matchhand === h && i < firstnon) {
        //console.log("Not clearing nonrest h="+h+" i="+i);
        continue; // don't clear rests that have already moved.
      }
      //console.log("Clearing h="+h+" i="+i);
      let ntp = null;
      if (i === notesToPlay[h].length) {
        ntp = document.getElementById("ntp_"+h+"_error");
      } else {
        ntp = document.getElementById("ntp_"+h+"_"+i);
      }
      if (ntp !== null) {
        ntp.style.color = "black";
        ntp.style.fontWeight = "normal";
        ntp.style.backgroundColor = "";
      } else {
        console.log("**** NTP is null during RESET");
      }
    }
  }

  for (let h = 0; h < 2; h++) {
    if (noteScope[h].first != 0 || noteScope[h].last != notesToPlay[h].length-1) {
      for (let n = noteScope[h].first; n <= noteScope[h].last; n++) {
        if (matchhand === h && n < firstnon) {
          //console.log("Not clearing nonrest h="+h+" n="+n);
          continue; // don't clear rests that have already moved.
        }
        const ntp = document.getElementById("ntp_"+h+"_"+n);
        ntp.style.backgroundColor = "#CCCCFF";
        if (n === noteScope[h].first) {
            // scroll the played note onto the left if it is more than 50% past center of screen horizontally
            const leftpos = ntp.getBoundingClientRect().left/window.innerWidth;
            ntp.scrollIntoView({behavior:'smooth', block: 'nearest', inline: 'start'});
        }
      }
    }
  }
}


function clearNotesToPlay() {
  notesToPlay = [[], []];
  errorNotes = [[],[]];
  let notesDiv = document.getElementById('notesLH');
  notesDiv.innerHTML = '';
  notesDiv = document.getElementById('notesRH');
  notesDiv.innerHTML = '';
  wrongNotePlayed = false;
  wrongNoteNumber = -1;
  noteScope = null;
  errorStats(wrongNotePlayed);
}

function prnotenum(note, h=null, i=null, c=null) {
  const octave = Math.floor(note / 12) - 1;
  const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

  if (note === RESTNOTE) {
    if (h !== null && i !== null) {
      // print rest with its duration
      return(restWithDur(h,i));
    }
    return "\u2014"; // rest represented by mdash
  }
  return noteNames[note % 12] + octave;
}

function prnote(note) {
  return prnotenum(note.number);
}

if (typeof WebMidi !== 'undefined' && WebMidi !== null) {
  // Check if Web MIDI is supported
  if (WebMidi.supported) {
    WebMidi.enable(function (err) {
      if (err) {
        console.error('WebMidi could not be enabled:', err);
      } else { // initialize

        WebMidi.addListener("connected", function(event) {
            warning("Connection to MIDI received");
            connectMidi();
        });

        WebMidi.addListener("disconnected", function(event) {
            warning("Lost MIDI connection: "+event.port.id+" "+event.port.manufacturer+" "+event.port.name);
            keyboardStatus = 'disconnected';
        });

        connectMidi();

      } // end of initialize
    }); // end of webmidi.enable
  } else { // end of if webmidi supported
    console.error('Web MIDI is not supported in this browser.');
  }
} else {
  console.error('Web MIDI is null--is not supported in this browser.');
}

function connectMidi() {
  let outputs = WebMidi.outputs;
  if (outputs.length > 0) {
    for (let i = 0; i < outputs.length; i++) {
      message("Output["+i+"]="+outputs[i].type+"/"+outputs[i].manufacturer+"/"+outputs[i].name);
    }
    midiOutput = outputs[0];
    setTimeout(function () {
      playMIDINote("C1", 300, 80, 52);
    },1000);
    setTimeout(function () {
      playMIDINote("C2", 300, 100, 52);
    },1400);
    setTimeout(function () {
      playMIDINote("C3", 300, 127, 52);
    },1800);
  } else {
    warning('No MIDI output devices found.');
  }

  // Retrieve the first available MIDI input device
  let input;
  if (WebMidi.inputs.length > 0) {

    for (let i = 0; i < WebMidi.inputs.length; i++) {
      WebMidi.inputs[i].removeListener(); // remove any prior listeners so we don't get double-listeners
    }
    input = WebMidi.inputs[0];
    message("Connected to WebMidi input port 0:" + WebMidi.inputs[0].name + " " + WebMidi.inputs[0].manufacturer);
    keyboardStatus = 'connected';
  } else {
    warning('No MIDI input devices found. Please connect a device.');
    keyboardStatus = 'disconnected';
    return;
  }

  input.addListener('controlchange', "all", controlChangeHandler, { once: true });

  function controlChangeHandler(event) {
    if (event.controller.name === 'holdpedal') {
      if (event.value) {
        document.getElementById('pedalSymbolDiv').innerHTML = M["pedal"];
      } else {
        document.getElementById('pedalSymbolDiv').innerHTML = M["pedalup"];
      }
    }
  }

  input.addListener('noteoff', 'all', noteOffHandler, { once: true });
  input.addListener('noteon', 'all', noteOnHandler, { once: true });

  function noteOffHandler(e) {

    lastNoteTime = Date.now();

    // remove from list of notes showing on mini keyboard canvas
    keyboardOptions.notesOn = keyboardOptions.notesOn.filter((element) => element !== e.note.number);

    if (currentState !== STATE.SETTING_NOTES && !timerPaused &&
      (e.note.number > noteFilterHigh || e.note.number < noteFilterLow)) {
      console.log("ignoring note out of range");
      return;
    }
    const all = [waitNotes, playedNotes];  // the ending note could be in either

    for (let d = 0; d < 2; d++) {
      if (d === 0 && all[d] === null) {
        console.log("Waitnotes null, skipping d="+d);
        continue; // waitNotes can be null if processing was previously completed
      }
      for (let hand = 0; hand < 2; hand++) {
        // go backwards since most recent notes are likely the ones that have just finished playing
        //console.log("Finding note in: d="+d+" hand=" + hand);
        for (let n = all[d][hand].length-1; n >= 0; n--) {
            if (all[d][hand][n].note.number === e.note.number && all[d][hand][n].eTime === null) {
              all[d][hand][n].eTime = e.timestamp;
              //console.log("found ending note");
              if (d === 0) {  // if the note was found in the waitNotes array
                // we found the noteoff in the waitNotes array so it might now
                // be complete. see if it has any eTime === null
                for (let h2 = 0; h2 < 2; h2++) {
                  for (let n2 = 0; n2 < waitNotes[h2].length; n2++) {
                    if (waitNotes[h2][n2].eTime === null) {
                      console.log("waitNotes is still incomplete");
                      return; // no we're still waiting for at least 1 note
                    }
                  }
                }

                // if we get here then waitNotes is now full so we can compute stats and
                // clear it out.
                // to avoid blocking here, we spin it off async using a 0 second timeout.
                // to avoid race conditions, we send it a copy of the waitNotes array.

                setTimeout(function() {displayTestStats(waitNotes.slice());}, 0);
              }
              return;
            }
          }
      }
    }
    console.log("Could not find ending note");
    //debugWindow();
  }

  function noteOnHandler(e) {

    //console.log("*****NoteOn: "+e.note.number);
    lastNoteTime = Date.now();

    keyboardOptions.notesOn.push(e.note.number);

    // we ignore notes that are significantly out of range
    // of the current hand. This allows you, for example, to accompany
    // a RH scale with a LH chord progression (common when practicing blues scales)

    if (currentState !== STATE.SETTING_NOTES &&
      (e.note.number > noteFilterHigh || e.note.number < noteFilterLow)) {
      console.log("ignoring note out of range");
      return;
    }

    currentHand = getSelectedHand();

    // store stats (used further down in the code)
    const notestruct = {
        note:   e.note,
        velocity: e.velocity,
        sTime:  e.timestamp,
        eTime:  null
    };

    // helper function to find the next non-rest note
    function nextNonRest(notes, start) {
      //console.log("NextNonRest start="+start+" notes="+notes);
      for (let i = start; i < notes.length; i++) {
        if (notes[i] !== RESTNOTE) {
          //console.log("Returning:"+notes[i]+" at position:"+i);
          return notes[i];
        }
      }
      //console.log("### Ran out of notes while skipping rests. start="+start+" notes="+notes);
      return null;
    }

    if (currentState === STATE.SETTING_NOTES) {
      let note = e.note.number;
      if (currentHand === 'left') {
        notesToPlay[0].push(note);
        // Display the human-readable note name on the main screen
        let noteName = prnote(e.note);
        let notesDiv = document.getElementById('notesLH');
        notesDiv.textContent = notesDiv.textContent + " " + noteName;
      }
      if (currentHand === 'right' || currentHand === 'both') {
        notesToPlay[1].push(note);
        // Display the human-readable note name on the main screen
        let noteName = prnote(e.note);
        let notesDiv = document.getElementById('notesRH');
        notesDiv.textContent = notesDiv.textContent + " " + noteName;
      }
      updateDisplayedNotesToPlay();

    } else if (currentState === STATE.TESTING_NOTES && !timerPaused) {
      // This is the main section that handles testing notes

      //console.log("STATE.TESTING_NOTES");

      // Check if the played note matches the expected note
      let playedNote = e.note.number;

      let matchhand = 0;

      // compute the set of possible notes we're expecting for all relevant hands.
      let exp = [[],[]];

      // handle chords in note positions
      if (currentHand === 'left' || currentHand === 'both') {
        if (isChord(playedNotes[0][playedNotes[0].length-1])) {

        }
      }
      if (currentHand === 'right' || currentHand === 'both') {

      }

      if (currentHand === 'left') {
        moveRests(0, e);
        playedNotes[0].push(notestruct);
      } else if (currentHand === 'right') {
        moveRests(1, e);
        playedNotes[1].push(notestruct);
        matchhand = 1;
      } else { // both hands
        // take a peek and see if it matches expected left hand
        const nextLeft = nextNonRest(notesToPlay[0], playedNotes[0].length+noteScope[0].first); //notesToPlay[0][playedNotes[0].length];
        const nextRight = nextNonRest(notesToPlay[1], playedNotes[1].length+noteScope[1].first); //notesToPlay[1][playedNotes[1].length];

        if (playedNote === nextLeft) {
          moveRests(0, e);
          playedNotes[0].push(notestruct);
        } else if (playedNote === nextRight){
          moveRests(1, e);
          playedNotes[1].push(notestruct);
          matchhand = 1;
        } else {
          // it doesn't match either hand. Choose the hand where the played note is
          // closest to the expected note (in terms of midi number of the notes)

          if (Math.abs(playedNote-nextLeft) < Math.abs(playedNote-nextRight)) {
            matchhand = 0;
          } else {
            matchhand = 1;
          }
          console.log("MISS MATCH: pn="+playedNote+" nextLeft="+nextLeft+
            " nextRight="+nextRight+
            " matchhand="+matchhand
          );
          moveRests(matchhand, e);
          playedNotes[matchhand].push(notestruct);
        }
      }

      const expectedNote = notesToPlay[matchhand][playedNotes[matchhand].length - 1 + noteScope[matchhand].first]; // note number

      // if this is the first non-rest note for the matching hand, and
      // there are no played non-rests in the other hand, then this is the very
      // first note of the new test cycle so start the timer.

      //console.log("mh="+matchhand+" pnm.len="+playedNotes[matchhand].length+" firstnon:"+noteScope[matchhand].firstrangenonrest+" othlen:"+playedNotes[1-matchhand].length+" othfnr:"+noteScope[1-matchhand].firstrangenonrest);
      if (playedNotes[matchhand].length === 1+(noteScope[matchhand].firstrangenonrest-noteScope[matchhand].first)
            && playedNotes[1-matchhand].length <= (noteScope[1-matchhand].firstrangenonrest-noteScope[1-matchhand].first)) {
        startTime = performance.now(); // we always start when the first note starts
        clearPlayedNotes(matchhand, noteScope[matchhand].firstrangenonrest);
        console.log("FIRST NOTE OF NEW TEST DETECTED, CLEARED PLAYED");
      }

      if (0) {
        console.log("Test: Expected: " + expectedNote + " got: " + playedNote + " start=" + notestruct.sTime);

        console.log("NOTE ANALYSIS: curhand:"+currentHand+" priorFailed:"+priorFailed+
          " played0:"+playedNotes[0].length+" played1:"+playedNotes[1].length+
          " played=expected:"+(playedNote===expectedNote));
      }

      if (playedNote === expectedNote) {
        showPlayedNote(e.note, matchhand, playedNotes[matchhand].length - 1 + noteScope[matchhand].first, true);
        wrongNotePlayed = false;
        wrongNoteNumber = -1;
        errorStats(wrongNotePlayed);
        nnAccuracy.success++;
        goodNotes++;  // this is the number of good notes just in the current run, it gets reset by logOneRun
        //console.log("NN.SUCCESS "+goodNotes);
      } else if (
        (currentHand === 'both' &&
            (playedNote === notesToPlay[0][noteScope[0].firstrangenonrest] || playedNote === notesToPlay[1][noteScope[1].firstrangenonrest]))
         ||
        (currentHand === 'right' && (playedNote === notesToPlay[1][noteScope[1].firstrangenonrest]))
          ||
        (currentHand === 'left' && (playedNote === notesToPlay[0][noteScope[0].firstrangenonrest]))
      ) {
          // FALSE FAIL DETECT #1 (Restart cancels run)
          // This could, rarely, result in a false good run, but it is necessary to
          // avoid false fails. Basically, at any time the user can restart the current run
          // without penalty as long as they haven't hit a wrong note.
          // Without this code, with scales and arpeggios the starting and ending notes
          // of each hand are the same, so if a user hits a wrong note and doesn't notice
          // and continues playing, the ending notes will be falsely detected as the
          // starting note, which will cause failures to stack up even though no mistakes
          // are being made.

          // no credit for notes played if you cancel early!
          const canc = goodNotes - 1; // cancel them all except the one just played
          nnAccuracy.success -= canc; // adjust entire session accuracy figures too
          goodNotes = 1; // just the one just played is now considered good
          console.log("CANCELED GOOD NOTES "+canc+" gn="+goodNotes);

          playedNotes = [[],[]];
          clearPlayedNotes();
          if (playedNote === notesToPlay[0][noteScope[0].firstrangenonrest]) {
            matchhand = 0;
          } else {
            matchhand = 1;
          }
          moveRests(matchhand, e);
          playedNotes[matchhand].push(notestruct);
          showPlayedNote(e.note, matchhand, noteScope[matchhand].firstrangenonrest, true);
          wrongNotePlayed = false;
          wrongNoteNumber = -1;
          startTime = performance.now();
          errorStats(wrongNotePlayed);
      } else if (currentHand === 'both' && priorFailed === true &&
          (playedNotes[0].length+playedNotes[1].length)===2+noteScope[0].firstrangenonrest+noteScope[1].firstrangenonrest) {
        // FALSE FAIL DETECTION #2
        // ok, this is a missed note that occurred in a very specific situation:
        // 1. we are in hands together mode
        // 2. the prior result was failure, meaning we recently came back into a new run after a fail
        // 3. Exactly one note has been recognized as good so far.
        // 4. We now have a bad note.
        // In this situation, if we count this as a failed run, we will very frequently be causing a
        // false bad run. What can happen (esp with scales/arps) is that the user kept playing after
        // a bad note (which in fact they should get in the habit of doing: keep playing after a mistake)
        // and, for example, the left hand gets up to the tonic note of the right hand, which would cause
        // a new run to start being counted, however as soon as the right hand plays another note it would
        // be logged as yet another failure. So essentially we are saying that in this situation it would
        // be better to just consider this to be part of the prior failure rather than count it as a new
        // failure. Another way to look at it is that after a fail state, we will require BOTH hands to play
        // one good note before we'll consider a new run to be truly started. As with the code above, this
        // may on occassion fail to count a legit error, but the vast majority of the time this will stop
        // a false failure.
        currentState = STATE.TEST_FLUSHING;
        wrongNotePlayed = true;
        priorFailed = true;
        console.log("***********TEST OF FALSE NEG TRIGGERED");
      } else { // missed the note
        console.log("NFail got:"+prnote(e.note));
        warning("Nfail:"+prnote(e.note)+" expected:"+expectedNote+" played:"+playedNote);
        wrongNotePlayed = true;
        wrongNoteNumber = e.note.number;
        nnAccuracy.fail++;
        //console.log("NN.FAIL");
        // add one error at note position played.
        const errorindex = playedNotes[matchhand].length-1+noteScope[matchhand].first
        if (!isAvail(errorNotes[matchhand])) {
          errorNotes[matchhand] = [];
        }
        if (!isAvail(errorNotes[matchhand][errorindex])) {
          errorNotes[matchhand][errorindex] = 0;
        }
        currentErrorNote = {hand:matchhand, errorIndex:errorindex}; // needed for logOneRun
        errorNotes[matchhand][errorindex]++;

        showPlayedNoteErrors(e.note, matchhand, errorindex, errorNotes[matchhand][errorindex]);
        showPlayedNote(e.note, matchhand, errorindex, false);
        errorStats(wrongNotePlayed);

        failCount++; // we do this here, but not again in the flushing state
        noteFailCount++;
        displayTestStats(null, "failure");
        currentState = STATE.TEST_FLUSHING;
        //console.log("State=flushing, failcount=" + failCount);
        priorFailed = true;
      }

      // See if we have played the last note required, thus ending this
      // test cycle.

      if ( (!wrongNotePlayed) &&
        (
          (currentHand === 'right' && playedNotes[1].length === (noteScope[1].last-noteScope[1].first+1)) || //playedNotes[1].length) ||
          (currentHand === 'left' && playedNotes[0].length === (noteScope[0].last-noteScope[0].first+1)) || //playedNotes[0].length) ||
          (currentHand === 'both' && playedNotes[0].length === (noteScope[0].last-noteScope[0].first+1) && //playedNotes[0].length &&
            playedNotes[1].length === (noteScope[1].last-noteScope[1].first+1)) //playedNotes[1].length)
        )
      ) {
        // we've come to the end of a successful test cycle.
        //message("Completed Test Cycle");
        console.log("TEST COMPLETE. pn0len:"+playedNotes[0].length+" pn1len:"+playedNotes[1].length+" ns0:"+noteScope[0].last+"/"+noteScope[0].first+" ns1:"+noteScope[1].last+"/"+noteScope[1].first);
        successCount++;
        splitRests();
        waitNotes = playedNotes.slice(); // copy of array
        playedNotes = [[], []];
        //clearPlayedNotes();
        priorFailed = false;
      }
    } else if (currentState === STATE.TEST_FLUSHING) {
      // continue testing when we see either the first LH or first RH
      console.log("FLUSHING got:"+e.note.number);
      let playedNote = e.note.number;

      console.log("first nr L:"+notesToPlay[0][noteScope[0].first]+" R:"+notesToPlay[1][noteScope[1].first]);
      const firstLeft = nextNonRest(notesToPlay[0], noteScope[0].first);
      const firstRight = nextNonRest(notesToPlay[1], noteScope[1].first);

      if (
          ( currentHand === 'right' && playedNote === firstRight ) ||
          (currentHand === 'left' && playedNote === firstLeft) ||
          (currentHand === 'both' &&
            (playedNote === firstRight || playedNote === firstLeft)
          )
        ) {
        wrongNotePlayed = false;
        wrongNoteNumber = -1;
        playedNotes = [[], []];
        clearPlayedNotes();
        if (currentHand === 'left') {
          moveRests(0, e);
          playedNotes[0].push(notestruct);
          showPlayedNote(e.note, 0, playedNotes[0].length-1+noteScope[0].first, true);
        } else if (currentHand === 'right') {
          moveRests(1, e);
          playedNotes[1].push(notestruct);
          showPlayedNote(e.note, 1, playedNotes[1].length-1+noteScope[1].first, true);
        } else if (playedNote === firstLeft) {
          moveRests(0, e);
          playedNotes[0].push(notestruct);
          showPlayedNote(e.note, 0, playedNotes[0].length-1+noteScope[0].first, true);
        } else if (playedNote === firstRight) {
          moveRests(1, e);
          playedNotes[1].push(notestruct);
          showPlayedNote(e.note, 1, playedNotes[1].length-1+noteScope[1].first, true);
        } else {
          console.error("RAN OUT OF CONDITIONS IN STATE FLUSHING");
        }
        startTime = performance.now();
        //console.log("While Flushing, got start note: going back into state testing");
        currentState = STATE.TESTING_NOTES;
      } else {
        wrongNotePlayed = true;
        currentState = STATE.TEST_FLUSHING;
        console.log("In state flushing, note still wrong, still flushing failed=" + failCount);
      }
    }
  } // end of noteOnHandler

  function moveRests(h, e) {
    while (notesToPlay[h][playedNotes[h].length+noteScope[h].first] === RESTNOTE) {
      let starttime = e.timestamp-250; // arbitrary start of rest when first "note" of entire piece is a rest
      if (playedNotes[h].length > 0) {
        // the start time of the rest is the end time of the prior note for this hand
        starttime = playedNotes[playedNotes.length-1].eTime;
      }
      const restnote = {
          note:   {number:RESTNOTE},
          velocity: 0,
          sTime:  starttime,
          eTime:  starttime+250 // this is just a placeholder
      };
      showPlayedNote(RESTNOTE, h, playedNotes[h].length+noteScope[h].first, true); // show that it's been "played"
      playedNotes[h].push(restnote);
    }
} // end of moveRests

function splitRests() {
  // check to see if there are two rest notes in a row and divide time between them
  // proportionately with respect to their durations.
  // Also, fix up rest start and end times.

  for (let h = 0; h < 2; h++) {
    for (let cur = 0; cur < playedNotes[h].length-1; cur++) {
      //console.log("SPLIT h="+h+" cur="+cur);

      if (playedNotes[h][cur].note.number === RESTNOTE) {
        if (!isAvail(playedNotes[h][cur].sTime)) {
          if (cur > 0) {
            // the start time of a rest is the end time of the prior note
            playedNotes[h][cur].sTime = playedNotes[h][cur-1].eTime;
            if (!isAvail(playedNotes[h][cur].eTime)) {
              playedNotes[h][cur].eTime = playedNotes[h][cur+1].sTime;
            }
          } else {
            // if the rest is the very first note, arbitrarily put its start time
            // 250 ms in the past. IMPLEMENT: There should be a better solution here.
            playedNotes[h][cur].eTime = playedNotes[h][cur+1].sTime;
            playedNotes[h][cur].sTime = playedNotes[h][cur].eTime - 250;
          }
        }
      }

      // IMPLEMENT: This only works for at most 2 rests in a row. This should be generalized to handle
      // any number of rests in a row since there could be cases of multiple bars of rests. To do this,
      // the if statements below need to be changed into loops.

      if (playedNotes[h][cur].note.number === RESTNOTE && playedNotes[h][cur+1].note.number === RESTNOTE) {

        if (cur+2 < playedNotes[h].length) {
          // make end time of the rests the same as start time of next note, if there is one
          playedNotes[h][cur].eTime =
          playedNotes[h][cur+1].eTime =
            playedNotes[h][cur+2].sTime;
        } else if (cur > 0) {
          playedNotes[h][cur].eTime =
          playedNotes[h][cur+1].eTime = playedNotes[h][cur-1].eTime+250; // punt! These rests were the last notes, so when did they end? You're guess is as good as mine.
        }

        if (cur > 0) {
          // make start time of rests the same as end time of prior note
          playedNotes[h][cur].sTime =
          playedNotes[h][cur+1].sTime =
            playedNotes[h][cur-1].eTime;
        } else {
          playedNotes[h][cur].sTime =
          playedNotes[h][cur+1].sTime =
            playedNotes[h][cur+1].sTime-250;
        }

        const dur1 = durationsToPlay[h][(cur+noteScope[h].first)%durationsToPlay[h].length];
        const dur2 = durationsToPlay[h][(cur+1+noteScope[h].first)%durationsToPlay[h].length];

        console.log("SPLITTING: hand="+h+"curnote="+cur+" dur1="+dur1+" dur2="+dur2+" curst="+playedNotes[h][cur].sTime+" curet="+playedNotes[h][cur].eTime+" nxtst"+playedNotes[h][cur+1].sTime+" nxtet="+playedNotes[h][cur+1].eTime);

        console.log("typeof stime:'"+(typeof playedNotes[h][cur].sTime)+"'");

        if (typeof playedNotes[h][cur].sTime !== "number" || isNaN(playedNotes[h][cur].sTime)) {
          playedNotes[h][cur].sTime = playedNotes[h][cur].eTime - 250;
          //console.log("SPLITTING FIX: hand="+h+"curnote="+cur+" dur1="+dur1+" dur2="+dur2+" curst="+playedNotes[h][cur].sTime+" curet="+playedNotes[h][cur].eTime+" nxtst"+playedNotes[h][cur+1].sTime+" nxtet="+playedNotes[h][cur+1].eTime);

        }
        if (typeof playedNotes[h][cur+1].sTime !== "number" || isNaN(playedNotes[h][cur+1].sTime)) {
          playedNotes[h][cur+1].sTime = playedNotes[h][cur+1].eTime - 250;
          //console.log("SPLITTING FIX: hand="+h+"curnote="+cur+" dur1="+dur1+" dur2="+dur2+" curst="+playedNotes[h][cur].sTime+" curet="+playedNotes[h][cur].eTime+" nxtst"+playedNotes[h][cur+1].sTime+" nxtet="+playedNotes[h][cur+1].eTime);

        }
        const elapsed = playedNotes[h][cur+1].eTime-playedNotes[h][cur].sTime;
        playedNotes[h][cur+1].sTime =
            playedNotes[h][cur].sTime + (dur1/(dur1+dur2))*elapsed;
        playedNotes[h][cur+1].eTime = playedNotes[h][cur].eTime;
        playedNotes[h][cur].eTime = playedNotes[h][cur+1].sTime;
        //console.log("SPLIT RESTS: elapsed:"+elapsed+" dur1:"+dur1+" dur2:"+dur2+" times:"+playedNotes[h][cur].sTime+":"+playedNotes[h][cur].eTime+"::"+playedNotes[h][cur+1].sTime+":"+playedNotes[h][cur+1].eTime);
      }
    } // end of for (cur...)
  } // end of for (h...)
} // end of splitRests()

} // end of connectMidi

// Function to start the test and initialize the start time
function startTest() {
  let button = document.getElementById('testNotesButton');

  testStartTime = Date.now();
  testPauseTime = 0;
  console.log("Cleared testPauseTime in starttest");
  timerPaused = false;
  lastNoteTime = 0; // for autopause feature
  button.textContent = "STOP";
  document.getElementById("timerPauseButton").style.display = "inline-block";
  document.getElementById("timerPauseButton").style.color = "gray";
  updateElapsedTime(); // Update elapsed time starts a timer to keep it up to date
  if (preferences['autoFullscreenStart'] && !presets[curPresetIndex].isFreePlay) {
    console.log("Full Screen auto on start");
      setTimeout(function() {fullscreen(true);}, 300);
  }
}

function showPlayedNote(note, hand, index, correct) {
  //console.log("Showing note "+note+" h="+hand+" index="+index+" correct="+correct);
  // Display the played note during the test phase, highlighting in green or red

  if (index >= notesToPlay[hand].length) {
    index = "error";
  }
  const ntp = document.getElementById("ntp_"+hand+"_"+index);
  if (ntp !== null) {
    if (note === RESTNOTE) {
      //console.log("Showing REST");
    }
    ntp.style.color = correct?"green":"red";
    ntp.style.fontWeight = "bold";
    ntp.style.backgroundColor = correct?"#98FB98":"#FFCCCB"; // pale green or pale red

    if (!correct) {
      var errorNote = document.createElement('div');
      errorNote.id = "ntp_error_note";
      errorNote.style.color = "red";
      errorNote.style.fontSize = "x-small";
      errorNote.style.textDecoration = "line-through";
      errorNote.textContent = prnotenum(wrongNoteNumber);

      // Prepend the new element to the div
      ntp.insertBefore(errorNote, ntp.firstChild);
      ntp.style.lineHeight = "0.8";
    }

    // scroll the played note onto the left if it is more than 50% past center of screen horizontally
    const leftpos = ntp.getBoundingClientRect().left/window.innerWidth;
    if (leftpos > 0.5) {
      ntp.scrollIntoView({behavior:'smooth', block: 'nearest', inline: 'start'});
    }

  } else {
    console.log("showPlayedNote NTP is null");
  }
}

function showPlayedNoteErrors(note, hand, index, errors) {
  //console.log("Showing note error for h="+hand+" i="+index+" numerr="+errors);
  if (index >= notesToPlay[hand].length) {
    index = "error"; // we're past the end of the played notes
  }
  const ntp = document.getElementById("ntp_"+hand+"_"+index);
  if (ntp !== null) {
    if (errors === 0) {
      ntp.style.border = "none";
    } else if (errors === 1) {
      ntp.style.border = "1px dotted orange";
    } else if (errors === 2) {
      ntp.style.border = "1px solid orange";
    } else if (errors === 3) {
      ntp.style.border = "2px solid orange";
    } else if (errors === 4) {
      ntp.style.border = "1px solid red";
    } else if (errors === 5) {
      ntp.style.border = "2px solid red";
    }  else if (errors === 6) {
      ntp.style.border = "3px solid red";
    } else if (errors === 7) {
      ntp.style.border = "4px double red";
    } else if (errors > 7) {
      ntp.style.border = "6px double red";
    }
    ntp.title = "Errors on this note: "+errors;
  } else {
    console.error("*NTP IS NULL");
  }
}

function printObject(obj) {
  let p = "";
  for (const key in obj) {
    p += `${key}:`+obj[key]+'\n';
  }
  return p;
}

function replay(notes, hand, speedMultiplier) {
  if (midiOutput === null || notes === null) {
    warning("No MIDI output device available for replay.");
    return;
  }

  let startTime;

  if (hand === 'left') {
    startTime = notes[0][0].sTime;
  } else if (hand === 'right') {
    startTime = notes[1][0].sTime;
  } else {
    startTime = math.Min(notes[0][0].sTime, notes[0][1].sTime);
  }

  for (let i = 0; i < notes.length; i++) {
    if (hand === 'both' || hand === 'left') {

    }
    if (hand === 'both' || hand === 'right') {

    }
  }
}

// Function to play a MIDI note for a specific duration
// IMPLEMENT: This could use the note scheduling feature built into the webmidi interface and
// that might work better

function playMIDINote(noteNumber, dur, vel, voice, time=null) {
  if (midiOutput === null)
    return;

  dur = (typeof dur === 'string') ? parseInt(dur) : dur;
  vel = (typeof vel === 'string') ? parseInt(vel) : vel;
  voice = (typeof voice === 'string') ? parseInt(voice) : voice;

  const opts = {
    duration: dur,
    time: "+"+(time===null?0:time),
    attack: (vel/128),
  };

  console.log("Playing note "+noteNumber+" att:"+vel+" dur:"+dur+" voice:"+voice);

  midiOutput.channels[1].sendProgramChange(voice);
  midiOutput.channels[1].playNote(noteNumber, opts);

}

// Function to update the elapsed time display
function updateElapsedTime() {
  if (testStartTime) {
    if (timerPaused) {
      return;
    }

    if (false && preferences.autoPauseClock) {
      if ((Date.now()-lastNoteTime) > 5000) {
        pauseTimer(true);
        return;
      } else {
        pauseTimer();
      }
    }
    let currentTime = Date.now();
    let elapsedTime = currentTime - testStartTime + testPauseTime;
    let elapsedSeconds = Math.floor(elapsedTime / 1000); // Convert milliseconds to seconds

    // Update the element with the elapsed time
    let elapsedTimeElement = document.getElementById('elapsedTime');
    elapsedTimeElement.textContent = formatTime(elapsedSeconds);
    // Schedule the next update in 0.1 second
    setTimeout(updateElapsedTime, 100);
  }
}

function pauseTimer(autoPause=false) {
  if (timerPaused) {
    resumeTimer();
    return;
  }
  console.log("Pause Timer, autopause="+autoPause);
  let currentTime = Date.now();
  testPauseTime = currentTime - testStartTime + testPauseTime;
  console.log("Set testpausetime to:"+testPauseTime);
  timerPaused = true;
  const button =document.getElementById("timerPauseButton");
  button.style.color = "red";
  if (autoPause) {
    button.innerHTML = "&#9208;<span style=font-size:x-small>a</span>";
  } else {
    button.innerHTML = "&#9208";
  }
}

function resumeTimer() {
  testStartTime = Date.now();
  timerPaused = false;
  updateElapsedTime();
  document.getElementById("timerPauseButton").style.color = "gray";
}

// Function to format the elapsed time in MM:SS format
function formatTime(seconds) {
  //console.log("Formatting number:"+seconds);
  seconds = Number(seconds);
  let hours = Math.floor(seconds/(60*60));
  let minutes = Math.floor((seconds-hours*60*60) / 60);
  let remainingSeconds = Math.trunc(seconds % 60);
  //console.log("hours="+hours+" min:"+minutes+" remsec="+remainingSeconds);

  // Pad single-digit seconds with leading zero
  let secondsString = remainingSeconds < 10 ? '0' + remainingSeconds : remainingSeconds;
  //console.log("secstr="+secondsString);

  if (hours === 0) {
      return String(minutes) + ':' + secondsString;
  } else {
      return String(hours) + ":" + String((minutes<10)?'0':'') + String(minutes) + ':' + secondsString;
  }

}

// Function to end the test and reset the start time
let run = 0;

function endTest() {
  if (testOptions.isFreePlay) {
    logFreePlay(Date.now() - testStartTime + testPauseTime);
    //document.getElementById("PresetMenu").disabled = false; // it was disabled during the test.
  }
  testStartTime = null;
  testPauseTime = 0;
  console.log("Cleared testPauseTime in endtest");
  enablePresetMenu();

  if (preferences.autoExitFullscreenStop) {
    exitFullscreen();
  }
}

function debugWindow() {

  let d = "<p>Notes list:";

  for (let hand = 0; hand < 2; hand++) {
    for (let n = 0; n < playedNotes[hand].length; n++) {
      if (playedNotes[hand][n].sTime !== null && playedNotes[hand][n].eTime !== null) {
        //continue; // this note was finished
      }
      d += "H"+hand+"N"+n+
        "(" + prnote(playedNotes[hand][n].note) + ") s=" +
        Math.trunc(playedNotes[hand][n].sTime) + " e="+
        (playedNotes[hand][n].eTime !==null?Math.trunc(playedNotes[hand][n].eTime):"NULL") + "</br>";
    }
  }
  d+="</p>";

  document.getElementById("debugDiv").innerHTML = d;
}



function scrollToDataTop(godata) {

  if (godata) {
    const dataTable = document.getElementById('data');
    if (dataTable) {
      const dataTableRect = dataTable.getBoundingClientRect();
      const dataTableTop = dataTableRect.top + window.scrollY - 3;
      window.scrollTo({
        top: dataTableTop,
        behavior: 'smooth'
      });
    }
  } else {
    const uitop = document.getElementById('uitop');
    console.log("UITOP in scrolldata:"+uitop)
    if (top) {
      const rect = uitop.getBoundingClientRect();
      const top = rect.top + window.scrollY;
      console.log("UITOP Scroll pos:"+top);
      setTimeout(function() {
        window.scrollTo({
          top: 1,
          behavior: 'smooth'
        });
      },500);
    }
  }
}

function drawPianoKeyboard(options) {
  const canvas = document.getElementById(options.canvasId);
  const ctx = canvas.getContext('2d');
  const s = getComputedStyle(canvas);
  canvas.width = parseInt(s.width);
  canvas.height = parseInt(s.height);

  const numOctaves = options.numOctaves || 5;
  const startingOctave = options.startingOctave || 1;
  const canvasWidth = canvas.width;
  const canvasHeight = canvas.height;

  const whiteKeyWidth = canvasWidth / (1 + numOctaves * 7); // we will tack on one extra "C" at the end
  const whiteKeyHeight = canvasHeight;
  const blackKeyWidth = whiteKeyWidth * 0.6;
  const blackKeyHeight = whiteKeyHeight * 0.6;

  const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

  ctx.clearRect(0, 0, canvasWidth, canvasHeight);

  if (preferences.showKeyboard === false) {
    return;
  }

  const whiteKeyOffsets = [0,2,4,5,7,9,11]; // offset within an octave of white key numbers

  // Draw white keys
  for (let o = 0; o <= numOctaves; o++) {
    for (let i = 0; i < 7; i++) {
      const x = o * 7 * whiteKeyWidth + i * whiteKeyWidth;
      ctx.fillStyle = 'white';
      ctx.fillRect(x, 0, whiteKeyWidth, whiteKeyHeight);
      ctx.strokeStyle = 'black';
      ctx.strokeRect(x, 0, whiteKeyWidth, whiteKeyHeight);

      // Check if the current note should be highlighted
      const noteNumber = (startingOctave+o+1) * 12 + whiteKeyOffsets[i];

      if (noteNumber === 60) {
        ctx.font = "9px Arial";
        ctx.textAlign = "left";
        ctx.textBaseline = "bottom";
        ctx.fillStyle = "black";
        ctx.fillText("C4", x+1, whiteKeyHeight-2);
      }

      if (options.notesOn && options.notesOn.includes(noteNumber)) {
        ctx.fillStyle = 'blue';
        ctx.fillRect(x+1, 1, whiteKeyWidth-3, whiteKeyHeight-2);
        ctx.fillStyle = 'white';
        ctx.font = "9px Arial";
        ctx.textAlign = "left";
        ctx.textBaseline = "bottom";
        ctx.fillText(prnotenum(noteNumber), x+1, whiteKeyHeight-2)
      }

      if (o === numOctaves) {
        break;  // this is just one more C to end the keyboard.
      }
    }
  }

  // Draw black keys
  ctx.fillStyle = 'black';
  const blackKeyIndices = [1, 2, 4, 5, 6];
  const blackKeyOffsets = [1,3,6,8,10];
  for (let o = 0; o < numOctaves; o++) {
    let keynum = 0;
    for (const keyIndex of blackKeyIndices) {
      const x = o * 7 * whiteKeyWidth + keyIndex * whiteKeyWidth - blackKeyWidth / 2;
      ctx.fillRect(x, 0, blackKeyWidth, blackKeyHeight);
      // Check if the current note should be highlighted
      const noteNumber = (startingOctave+o+1) * 12 + blackKeyOffsets[keynum];
      if (options.notesOn && options.notesOn.includes(noteNumber)) {
        ctx.fillStyle = 'blue';
        ctx.fillRect(x+1, 1, blackKeyWidth-2, blackKeyHeight-2);
        ctx.fillStyle = 'white';
        ctx.textAlign = "left";
        ctx.textBaseline = "bottom";
        ctx.save();
        ctx.translate(x-1,5);
        ctx.rotate(Math.PI/2);
        ctx.font = "10px Arial";
        ctx.fillText(prnotenum(noteNumber), 0, 0);
        ctx.restore();
        ctx.fillStyle = 'black';
      }
      keynum++;
    }
  }

  if (keyboardStatus === 'disconnected') {
    ctx.fillStyle = "rgba(240,240,240,0.8)";
    ctx.fillRect(0,0,keyboardCanvas.width,keyboardCanvas.height);
    ctx.font = "bold "+Math.trunc(whiteKeyHeight)+"px Arial";
    ctx.fillStyle = "red";
    ctx.textBaseline = "bottom";
    ctx.textAlign = "center";
    ctx.fillText("DISCONNECTED", keyboardCanvas.width/2, keyboardCanvas.height+5);
  }
}

function copyToClipboard(text) {
  const textarea = document.createElement('textarea');
  textarea.value = text;
  document.body.appendChild(textarea);
  textarea.select();
  document.execCommand('copy');
  document.body.removeChild(textarea);
}

const voiceNumberElement = document.getElementById('voiceNumber');
const incrementButton = document.getElementById('increment');
const decrementButton = document.getElementById('decrement');

let counterValue = 0;

function updateCounterDisplay() {
  if (voiceNumberElement !== null) voiceNumberElement.textContent = counterValue;
}

function incrementCounter() {
  if (counterValue < 100) {
    counterValue++;
    updateCounterDisplay();
  }
}

function decrementCounter() {
  if (counterValue > 1) {
    counterValue--;
    updateCounterDisplay();
  }
}

if (incrementButton !== null) incrementButton.addEventListener('click', incrementCounter);
if (decrementButton !== null) decrementButton.addEventListener('click', decrementCounter);

updateCounterDisplay(); // Initialize the display with the initial value

function playVoice(event) {
  let vn = document.getElementById("voiceNumber");
  let voice = 1;

  if (vn !== null) {
    voice = vn.textContent;
  }

  console.log("Playing voice "+voice);
  playMIDINote("C4", 500, 100, voice);

}

// This makes it easier to debug on tablet devices with no access to the console.
// Since the midi is using the OTG port, it's hard to get debugging info out.
function redirectConsole() {
  // Override the console.log function
  const originalConsoleError = console.error;
  console.error = function (...args) {
    // Call the original console.error function
    originalConsoleError.apply(console, args);

    // Create a new div element to display the message
    warning(args.join(' ')); // Join arguments into a single string
  };
}

function showScaleArpWizard() {
  const popupContainer = document.getElementById('scaleArpWizardContainer');
  popupContainer.style.display = 'block';
}

function dismissScaleArpWizard() {
  const popupContainer = document.getElementById('scaleArpWizardContainer');
  popupContainer.style.display = 'none';
}

function generateTest() {
  const testType = document.getElementById('test-type').value;
  const tonic = document.getElementById('tonic').value;
  const mode = document.getElementById('mode').value;
  const octaves = document.getElementById('octaves').value;
  const lhStartOctave = document.getElementById('lh-start-octave').value;

  let modename = mode;
  if (testType === 'Arpeggio') {
    modename += "Arp";
  }
  console.log("Modename:"+modename);

  // Call your generateTestNotes function here with the retrieved values
  const tmp = presets.length;

  const p = generateScalePreset(tonic, modename, parseInt(octaves), parseInt(lhStartOctave));

  if (p === null) {
    // generate failed.
    alert("Not able to generate that arpeggio yet: try Major or Minor");
    return;
  }
  presets.push(p);
  let option = document.createElement('option');
  option.value = tmp;
  option.innerHTML = presets[tmp].name;
  option.style.fontSize = "16px";
  //presetMenu.appendChild(option);
  option.selected = true;

  handlePresetSelection(tmp);

  dismissScaleArpWizard();
}

function populateTestNameOptions() {
    const testNameSelect = document.getElementById("testNameHistorySelect");
    testNameSelect.innerHTML = ""; // blank it out

    // add the "all" option
    const allopt = document.createElement("option");
    allopt.value = "all";
    allopt.textContent = " ALL";
    testNameSelect.appendChild(allopt);

    const testNames = Object.keys(runHistory);
    const seen = [];
    testNames.forEach((testName) => {
        if (testName.startsWith(".PREF.") || runHistory[testName].isFreePlay) {
          return;
        }
        const option = document.createElement("option");
        const [date, preset, hand] = testName.split("|");

        const decoded = decodeHTMLEntities(preset);
        if (typeof seen[preset] !== 'undefined') {
          return;
        }
        seen[preset] = true;
        option.value = preset;
        option.textContent = decoded;

        if (preset === (curPresetName+historyNameModifier())) {
          option.selected = true;
        }
        testNameSelect.appendChild(option);

        // also select current hand
        const h = getSelectedHand();
        const sel = document.getElementById("handSelect");
        sel.value = h;
    });

    sortSelectedOptions(testNameSelect);
}

function sortSelectedOptions(select) {
  // Get all options in the select element
  const options = Array.from(select.options);

  // Sort the options alphabetically by textContent
  options.sort((a, b) => {
    const textA = a.textContent.toUpperCase();
    const textB = b.textContent.toUpperCase();
    return textA.localeCompare(textB);
  });

  // Clear the select element
  select.innerHTML = '';

  // Append the sorted options back to the select element
  options.forEach((option) => {
    select.appendChild(option);
  });
}


function decodeHTMLEntities(html) {
  const textarea = document.createElement("textarea");
  textarea.innerHTML = html;
  return textarea.value;
}

// This function populates the history table with run data
function populateHistoryTable() {
    const historyTableBody = document.getElementById("historyTableBody");
    historyTableBody.innerHTML = ""; // Clear the table body

    if (runHistory === null) {
      loadRunHistory();
    }

    populateTestNameOptions();

    return;
}

// Function to filter and display history based on selected filters
function filterAndDisplayHistory() {
    const historyTableBody = document.getElementById("historyTableBody");
    historyTableBody.innerHTML = ""; // Clear the existing rows in the table

    const dateRange = document.getElementById("dateRangeSelect").value;
    const selectedTestName = document.getElementById("testNameHistorySelect").value;
    const selectedHand = document.getElementById("handSelect").value;

    // Initialize an object to store statistics for graphing
    const stats = {};
    let qrows = "";

    let maxBPM = 0;
    let minBPM = 10000; // higher than humanly possible
    let firstMonth = '';
    let lastMonth = '';

    // Loop through the runHistory object and populate the table
    let totReps = 0;
    let totNfail = 0;
    let totElapsed = 0;
    let streakGraphBPM = [];


    for (const runName in runHistory) {
        const runData = runHistory[runName];
        const [date, preset, hand] = runName.split("|");

        // Date range filtering logic
        if (dateRange === "1Month" && !isWithinLastMonths(date, 1)) continue;
        if (dateRange === "3Months" && !isWithinLastMonths(date, 3)) continue;
        if (dateRange === "1Year" && !isWithinLastMonths(date, 12)) continue;

        // Test name filtering logic
        if (selectedTestName !== "all" && selectedTestName !== preset) continue;

        // Hand filtering logic
        if (selectedHand !== "any" && selectedHand !== hand) continue;

        const [year, month, day] = date.split('-');
        const datedisp = year + "-" + month;
        if (firstMonth === '') {
          firstMonth = date;
        }
        lastMonth = date; // this will keep overwriting until it is really the last one

        // Initialize the monthly statistics if not already done
        if (!stats[date]) {
            stats[date] = {
                avgBPM: 0,
                bestBPM: 0,
                maxBPM: 0,
                streakBPM: 0
            };
        }

        // Update the monthly statistics
        stats[date].avgBPM = runData.sumBPM / (runData.success>0?runData.success:1);
        stats[date].bestBPM = runData.bestBPM;
        stats[date].maxBPM = runData.maxBPM;
        stats[date].notefail = Math.trunc(100*runData.notefail/(runData.success+runData.notefail+0.1));

        // Update maxBPM
        //console.log("avg="+stats[date].avgBPM+" best="+stats[date].bestBPM+" max="+stats[date].maxBPM);


        maxBPM = Math.max(
            maxBPM,
            stats[date].bestBPM,
            stats[date].maxBPM,
            stats[date].avgBPM
        );

        // zero bpm just about always just indicates a lack of data so don't count that for purposes of graphing
        if (stats[date].bestBPM)
          minBPM = Math.min(minBPM, stats[date].bestBPM);
        if (stats[date].maxBPM)
          minBPM = Math.min(minBPM, stats[date].maxBPM);
        if (stats[date].avgBPM)
          minBPM = Math.min(minBPM, stats[date].avgBPM);

        const newRow = document.createElement("tr");
        let acc = "&nbsp;";
        if (typeof runData.goodNotes !== 'undefined' && runData.goodNotes !== null) {
          acc = (100*runData.goodNotes/Math.max(runData.goodNotes+runData.notefail,1)).toFixed(2);
          qrows += `<td>${acc}%</td>`;
        }

        let errmaplink = "";
        if (isAvail(runData.errorNotes)) {
          errmaplink = "<div onclick=\"showErrorMap('"+runName+"');\" onmouseover='this.style.backgroundColor=\"white\"' onmouseout='this.style.backgroundColor=\"rgb(238,238,238)\"' style=color:blue;>SHOW</span>";
        }
        let streak = "";
        if (isAvail(runData.maxStreak)) {
          let streakbpm = [0,0,0,0];
          for (let i = 0; i < 4; i++) {
            if (isAvail(runData.maxStreakBPM) && isAvail(runData.maxStreakBPM[i])) {
              streakbpm[i] = Math.trunc(runData.maxStreakBPM[i]/(runData.maxStreak[i]?runData.maxStreak[i]:1));
            }
          }
          streak = "<div style=font-size:x-small>"+
                    "<span style=color:green>" + avail(runData.maxStreak[0],0)+"/"+
                      streakbpm[0]+"&nbsp;</span>"+
                    "<span style=color:blue>" +avail(runData.maxStreak[1],0)+"/"+
                      streakbpm[1]+"&nbsp;</span>"+
                    "<span style=color:orange>" +avail(runData.maxStreak[2],0)+"/"+
                      streakbpm[2]+"&nbsp;</span>"+
                    "<span style=color:red>" +avail(runData.maxStreak[3],0)+"/"+
                      streakbpm[3]+"</span>"+
                    "</div>";
          stats[date].streakBPM = streakbpm[2];
        }

        newRow.innerHTML = `
            <td>${date}</td>
            <td>${preset}</td>
            <td>${hand}</td>
            <td>${runData.success}</td>
            <td>${runData.notefail} (${Math.trunc(100*runData.notefail/(runData.count))}%)</td>
            <td>${(runData.elapsed/1000).toFixed(1)}</td>
            <td>${(runData.sumStrikes / runData.success).toFixed(2)}</td>
            <td>${acc}</td>
            <td>${errmaplink}</td>
            <td>${streak}</td>
            <td>${Math.trunc(runData.sumBPM / runData.success)}</td>
            <td>${runData.maxBPM}</td>
            <td>${runData.bestBPM}</td>

        `;

        totReps += runData.success;
        totNfail += runData.notefail;
        totElapsed += (runData.elapsed/1000);

        if (typeof runData.numQBPM !== 'undefined' && runData.numQBPM !== null) {
            let qrows = "";
            let sum = 0;
            for (let q = 0; q < 4; q++) {
              if (typeof runData.numQBPM[q] !== 'undefined' && runData.numQBPM[q] !== null) {
                sum += runData.numQBPM[q];
              } else {
                runData.numQBPM[q] = 0;
              }
            }
            if (sum === 0) sum = 1;  // avoid div by zero errors
            for (let q = 0; q < 4; q++) {
              //console.log("ADDING QROW: q:"+q+" sum:"+sum+" rD[q]:"+runData.sumQBPM[q]+" n:"+runData.numQBPM[q]);
              qrows += `<td>${Math.trunc(100*runData.numQBPM[q]/sum)}%</td>`;
            }
            newRow.innerHTML += qrows;
        }

        historyTableBody.appendChild(newRow);
    }

    const sumRow = document.createElement("tr");

    sumRow.innerHTML += "<td colspan=3 style=text-align:left;font-weight:bold>TOTALS</td>" +
                        "<td style=text-align:left;font-weight:bold>"+totReps+"</td>" +
                        "<td style=text-align:left;font-weight:bold>"+totNfail+" ("+Math.trunc(100*totNfail/(totNfail+totReps))+"%)"+"</td>" +
                        "<td style=text-align:left;font-weight:bold>"+formatTime(totElapsed)+"</td>";
    historyTableBody.appendChild(sumRow);

    maxBPM = Math.ceil(maxBPM/20)*20;  // round nearest 20
    minBPM = Math.floor(minBPM/20)*20;  // round nearest 20

    // Call the graphing function with the required parameters
    if (selectedTestName !== "all" && selectedHand !== "any") {
      drawHistoryGraph(stats, firstMonth, lastMonth, maxBPM, minBPM);
    }

    const hist = document.getElementById('historyGraph');
    if (hist) {
      const rect = hist.getBoundingClientRect();
      const top = rect.top + window.scrollY - 3;
      hist.scrollTo({
        top: top,
        behavior: 'smooth'
      });
    }
}


function showStreakData(name) {
  alert("Not yet implemented");
}

function showErrorMap(name) {
  console.log("SHOW ERROR MAP "+name);
  document.getElementById("errorMapContainer").style.display = "block";
  updateDisplayedNotesToPlay(true);
}

function drawHistoryGraph(stats, firstMonth, lastMonth, maxBPM, minBPM) {

  //console.log("In Drawhist fm="+firstMonth+" lm="+lastMonth+" maxbpm="+maxBPM);
  if (maxBPM === 0) {
    maxBPM = 1; // avoid div by 0 errors, the graph is pathologic in this case anyway.
  }
  // Get the canvas context
  const canvas = document.getElementById("historyGraph");
  const ctx = canvas.getContext("2d");
  const canvasErr = document.getElementById("historyGraphErr");
  const ctxErr = canvasErr.getContext("2d");

  // Set canvas dimensions from actual size as rendered in html
  const s = getComputedStyle(canvas);
  canvas.width = parseInt(s.width);
  canvas.height = parseInt(s.height);
  ctx.font = "10px Arial";

  const se = getComputedStyle(canvasErr);
  canvasErr.width = parseInt(se.width);
  canvasErr.height = parseInt(se.height);
  ctxErr.font = "10px Arial";

  // Set up colors and styles
  ctx.fillStyle = "#BBB"; // Background color
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.lineWidth = 2;
  ctx.strokeStyle = "white";
  ctx.fillStyle = "white";
  ctx.textAlign = "left";

  ctxErr.fillStyle = "#BBB"; // Background color
  ctxErr.fillRect(0, 0, canvasErr.width, canvasErr.height);

  ctxErr.lineWidth = 2;
  ctxErr.strokeStyle = "white";
  ctxErr.fillStyle = "white";
  ctxErr.textAlign = "left";

  let [fyear,fmonth,fday] = firstMonth.split('-');
  if (fday >= 22) {
    fday = 22;
  } else if (fday >= 15) {
    fday = 15;
  } else if (fday >= 7) {
    fday = 7;
  } else {
    fday = "01";
  }
  let [lyear,lmonth,lday] = lastMonth.split('-');
  lmonth=parseInt(lmonth);
  if (lday < 7) {
    lday = 7;
  } else if (lday < 15) {
    lday = 15;
  } else if (lday < 22) {
    lday = 22;
  } else if (lday <= 28) {
    if (lmonth == 2) {
      console.log("lmonth==2:"+lmonth);
      lday = 28 + (((lyear%4) === 0)?1:0);
    } else if (lmonth == 3 || lmonth == 4 || lmonth==6||lmonth==9||lmonth==11) {
      lday = 30;
    } else {
      lday = 31;
    }
  }

  console.log("graphhist: firstMonth="+firstMonth+" Adj lastmonth="+lastMonth);
  console.log("fday="+fday+" fmonth="+fmonth+" fyear="+fyear+" lday="+lday+" lmonth="+lmonth+" lyear="+lyear);

  const firstday = dateToDaysSince1970(fyear+"-"+fmonth+"-"+fday);
  const lastday = dateToDaysSince1970(lyear+"-"+lmonth+"-"+lday);
  const totdays = lastday-firstday;

  console.log("Totdays="+totdays+" firstmonth="+firstMonth+" lastm="+lastMonth);

  const graphAxisHorizontalMargin = 55; // pixels to leave for axis and labels
  const graphAxisVerticalMargin = 25;
  const graphAxisVerticalMarginErr = 8;

  const xScale = (canvas.width-2*graphAxisHorizontalMargin) / totdays;
  const yScale = (canvas.height-2*graphAxisVerticalMargin) / (maxBPM-minBPM);

  const xScaleErr = (canvasErr.width-2*graphAxisHorizontalMargin) / totdays;
  const yScaleErr = (canvasErr.height-2*graphAxisVerticalMargin) / (100);

  //console.log("xscale="+xScale);

  // Draw horizontal and vertical axes

  ctx.beginPath();
  ctx.moveTo(graphAxisHorizontalMargin, canvas.height-graphAxisVerticalMargin);
  ctx.lineTo(canvas.width-graphAxisHorizontalMargin, canvas.height-graphAxisVerticalMargin);
  ctx.moveTo(graphAxisHorizontalMargin, graphAxisVerticalMargin);
  ctx.lineTo(graphAxisHorizontalMargin, canvas.height-graphAxisVerticalMargin);
  ctx.stroke();

  ctx.lineWidth = 2;

  //console.log("Drawing history graph "+fyear+"."+fmonth+" "+lyear+"."+lmonth);

  // Draw labels on the horizontal axis
  for (let year = fyear, month = fmonth, day = fday;
       parseInt(year) < parseInt(lyear) ||
         ( parseInt(year) == parseInt(lyear) && parseInt(month) <= parseInt(lmonth) );
       // there is no third part for the for loop, this is handled at the end of the loop
     ) {
    console.log("Drawing date axis m="+month+" d="+day+" y="+year);
    const x = graphAxisHorizontalMargin + (dateToDaysSince1970(year+'-'+month+'-'+day) - firstday)*xScale;
    console.log(" x="+x+" daystodate returned:"+dateToDaysSince1970(year+'-'+month+'-'+day)+" firstday="+firstday);
    ctx.textAlign = 'center';
    ctx.fillText(year+'-'+month+'-'+day, x, canvas.height - graphAxisVerticalMargin/2); // Adjust label position

    console.log("***label "+year+'-'+month+" at x="+x+" y="+(canvas.height-graphAxisVerticalMargin/2));

    ctx.moveTo(x, graphAxisVerticalMargin);
    ctx.lineTo(x, canvas.height-graphAxisVerticalMargin);
    ctx.stroke();

    ctxErr.moveTo(x, graphAxisVerticalMarginErr);
    ctxErr.lineTo(x, canvasErr.height-graphAxisVerticalMarginErr);
    ctxErr.stroke();

    // increment date by varying amounts depending on total timespan.
    // IMPLEMENT: This could be a bit more sophisticated about how many time divisions are reasonable.

    if (day < 15) {
      day = 15;
    } else {
      day = "01";
      month++;
      if (month > 12) {
        month = "01";
        year++;
      }
    }
    console.log("Updated yyyy mm dd="+year+" "+month+" "+day+" last="+lyear+" "+lmonth+" "+lday);
  }

  // draw labels for bpm

  ctx.strokeStyle = "#444";
  ctx.lineWidth = "1";
  ctx.textBaseline = "middle";
  let bpmIncrement = 20;
  if (maxBPM - minBPM > 1600) {
    bpmIncrement = 200;
  } else if (maxBPM-minBPM > 1000) {
    bpmIncrement = 100;
  } else if (maxBPM - minBPM > 400) {
    bpmIncrement = 50;
  }
  for (let bpm = minBPM; bpm <= maxBPM; bpm += bpmIncrement) {
    const y = canvas.height - graphAxisVerticalMargin - (bpm-minBPM)*yScale;
    ctx.textAlign = "right";
    ctx.fillText(bpm+' ', graphAxisHorizontalMargin, y);
    ctx.moveTo(graphAxisHorizontalMargin, y);
    ctx.lineTo(canvas.width-graphAxisHorizontalMargin, y);
    ctx.stroke();
    ctx.textAlign = "left";
    ctx.fillText(bpm, canvas.width-graphAxisHorizontalMargin, y);

  }

  // draw labels on the Error graph vertical axis
  ctxErr.strokeStyle = "#611";
  ctxErr.fillStyle = "#B11";
  ctxErr.lineWidth = "1";

  let perYScale = (canvasErr.height-2*graphAxisVerticalMarginErr) / (50);
  ctxErr.textBaseline = "middle";
  for (let per = 0; per <= 50; per += 10) {
    const y = canvasErr.height - graphAxisVerticalMarginErr - per*perYScale;
    ctxErr.textAlign = "left";
    ctxErr.fillText(per+'% ', canvasErr.width-graphAxisHorizontalMargin+3, y);
    ctxErr.textAlign = "right";
    ctxErr.fillText(per+'% ', graphAxisHorizontalMargin-3, y);
    ctxErr.moveTo(graphAxisHorizontalMargin, y);
    ctxErr.lineTo(canvasErr.width-graphAxisHorizontalMargin, y);
    ctxErr.stroke();
  }

  // give color code
  ctx.font = "12px Arial";
  ctx.textAlign = "left";
  ctx.fillStyle = "#AAFF00";
  ctx.fillText("BestBPM", graphAxisVerticalMargin*2, graphAxisVerticalMargin/2);
  ctx.fillStyle = "#0096FF";
  ctx.fillText("AvgBPM", graphAxisVerticalMargin*5, graphAxisVerticalMargin/2);
  ctx.fillStyle = "#BF40BF";
  ctx.fillText("MaxBPM", graphAxisVerticalMargin*8, graphAxisVerticalMargin/2);
  ctx.fillStyle = "#FFFFFF";
  ctx.fillText("StreakBPM", graphAxisVerticalMargin*11, graphAxisVerticalMargin/2);
  ctx.fillStyle = "#FF0000";
  ctx.fillText("NoteFail", graphAxisVerticalMargin*16, graphAxisVerticalMargin/2);

  // Plot lines for Average BPM (blue), Best BPM (green), and Max BPM (purple)
  const colors = ["#0096FF", "#AAFF00", "#BF40BF", "#FFFFFF"];
  const dataKeys = ["avgBPM", "bestBPM", "maxBPM", "streakBPM"];

  ctx.lineWidth = "3";

  for (let i = 0; i < dataKeys.length; i++) {
    ctx.strokeStyle = colors[i];
    ctx.beginPath();

    let firstkey = true;
    for (const key in stats) {
      if (stats.hasOwnProperty(key)) {
          if (stats[key][dataKeys[i]] === 0) {
            continue; // don't graph 0 bpm data points, they represent a lack of data not actual data
          }
          const x = graphAxisHorizontalMargin + (dateToDaysSince1970(key) - firstday) * xScale + 2*i;
          const y = canvas.height - graphAxisVerticalMargin - (stats[key][dataKeys[i]]-minBPM) * yScale;
          if (firstkey) {
            ctx.moveTo(x, y);
            firstkey = false;
          } else {
            ctx.lineTo(x, y);
          }
      }
    }

    ctx.stroke();

    for (const key in stats) {
      if (stats.hasOwnProperty(key)) {
          if (stats[key][dataKeys[i]] === 0) {
            continue; // don't graph 0 bpm data points, they represent a lack of data not actual data
          }
          const x = graphAxisHorizontalMargin + (dateToDaysSince1970(key) - firstday) * xScale + 2*i;
          const y = canvas.height - graphAxisVerticalMargin - (stats[key][dataKeys[i]]-minBPM) * yScale;
          ctx.fillStyle = colors[i];
          ctx.beginPath();
          ctx.moveTo(x, y - 4); // Move to the top point
          ctx.lineTo(x + 4, y); // Line to the right point
          ctx.lineTo(x, y + 4); // Line to the bottom point
          ctx.lineTo(x - 4, y); // Line to the left point
          ctx.closePath(); // Close the path to complete the diamond
          ctx.fill(); // Fill the diamond
      }
    }
  }

  // draw the notefail data

  let first = true;
  ctxErr.lineWidth = 3;
  ctxErr.strokeStyle = "rgba(255,0,0,0.5)";
  ctxErr.setLineDash([4,4]);
  ctxErr.lineDashOffset = 0;
  ctxErr.beginPath();

  for (const date in stats) {
    if (!stats.hasOwnProperty(date)) {
      continue;
    }
    const x = graphAxisHorizontalMargin + (dateToDaysSince1970(date) - firstday) * xScale;
    const y = canvasErr.height - graphAxisVerticalMarginErr - (stats[date].notefail) * perYScale;

    //console.log("Drawing nfail at x="+x+" y="+y+" val="+stats[date].notefail);

    if (first) {
      ctxErr.moveTo(x, y);
      first = false;
    } else {
      ctxErr.lineTo(x, y);
    }
  }
  ctxErr.stroke();
  ctxErr.setLineDash([]);

  ctxErr.fillStyle = "rgba(255,0,0,0.5)";

  for (const date in stats) {
    if (!stats.hasOwnProperty(date)) {
      continue;
    }
    const x = graphAxisHorizontalMargin + (dateToDaysSince1970(date) - firstday) * xScale;
    const y = canvasErr.height - graphAxisVerticalMarginErr - (stats[date].notefail) * perYScale;
     ctxErr.beginPath();
     ctxErr.moveTo(x, y - 4); // Move to the top point
     ctxErr.lineTo(x + 4, y); // Line to the right point
     ctxErr.lineTo(x, y + 4); // Line to the bottom point
     ctxErr.lineTo(x - 4, y); // Line to the left point
     ctxErr.closePath(); // Close the path to complete the diamond
     ctxErr.fill(); // Fill the diamond
  }

}


// Function to check if a date is within the last 'n' months
function isWithinLastMonths(dateString, n) {
    const currentDate = new Date();
    const date = new Date(dateString);
    const diff = currentDate - date;
    const monthDiff = diff / (1000 * 60 * 60 * 24 * 30.44); // Approximate average days in a month

    return monthDiff <= n;
}


function showHistory() {
    populateHistoryTable();
    animateOpen("historyTableContainer");
    setTimeout(function() {
      filterAndDisplayHistory();
    }, 300);
}

function showFreePlay() {
    animateOpen("freePlayContainer");
    setTimeout(function() {
      displayFreePlay();
    }, 300);
}

function showFreePlayHiddenItems() {
  showFreePlayHidden = !showFreePlayHidden;
  if (showFreePlayHidden) {
    document.getElementById("showFreePlayHiddenButton").innerHTML = "Hide Hidden Items";
  } else {
    document.getElementById("showFreePlayHiddenButton").innerHTML = "Show Hidden Items";
  }
  displayFreePlay();
}

function displayFreePlay(edit=-1) {
  const tab = document.getElementById("freePlayTbody");
  let t = ""; // will build up table rows
  for (let i = 0; i < freePlay.length; i++) {
    if (freePlay[i].deleted && showFreePlayHidden === false) {
      continue;
    }
    if (edit == i) {
      // this item is being edited
      t += "<tr data-index="+i+"><td colspan=3 style=text-align:center>"+
        "<button onclick='saveEditFreePlay("+i+")' "+
                     " title='Save edited Free Play item' style=font-size:medium;display:inline-block;padding:4px;margin:0><i class=\"fa-regular fa-floppy-disk\"></i> Save</button>"+
         "&nbsp;<button onclick='displayFreePlay()' "+
                      " title='Cancel edit' style=font-size:medium;display:inline-block;padding:4px;margin:0><i class=\"fa-regular fa-rectangle-xmark\"></i> Cancel</button>"+
        "</td>"+
        "<td style=font-weight:bold>"+freePlay[i].name+"</td>"+
        "<td><input type=text id=freePlayEditDescription value='"+freePlay[i].description+"' maxlength=100 style=width:95%;x-overflow:auto></td>"+
        "<td><select id=freePlayEditCategory>";
        presetCats.forEach(cat => {
          t += "<option value='"+cat.name+"'>"+cat.description+"</option>";
        });
        t += "</select></tr>";
      continue;
    }
    t += "<tr draggable=true id=freeplay_"+i+" data-index="+i+"><td style=text-align:center;min-width:2em;padding:4px>&vellip;&vellip;</td>";

    if (freePlay[i].deleted) {
      t += "<td style=text-align:center;min-width:2eml;padding:4px>"+
            "<div onclick='deleteFreePlay("+i+", false)' style=display:inline-block title='Item is hidden in Presets menu. Click to make visible.'><i class='fa-solid fa-eye-slash'></i></div></td>";
    } else {
      t += "<td style=text-align:center;min-width:2em;padding:4px>"+
            "<div onclick='deleteFreePlay("+i+")' style=display:inline-block title='Item is visible in Presets menu. Click to hide it.'><i class='fa-solid fa-eye'></i></div></td>";

    }
    t += "<td onclick='displayFreePlay("+i+")' style=min-width:2em;text-align:center><i class='fa-solid fa-pencil'></i></td>";
    const cat = presetCats.find(cat => cat.name === freePlay[i].category);
    t += "<td onclick='gotoPreset(\""+freePlay[i].name+"\",\"freePlayContainer\")' style=cursor:pointer>"+
          "<i class=\"fa-solid fa-square-arrow-up-right\" style=opacity:0.3;padding:3px></i> "+freePlay[i].name+"</td>"+
          "<td>"+freePlay[i].description+"</td>"+
          "<td>"+avail(cat.description,'Miscellaneous')+"</td>";

    t += "</tr>";
  }

  // allow user to add a new one

  t += "<tr><td colspan=3 style=text-align:center><div onclick='addNewFreePlay()' "+
                 " title='Create a new Free Play item' style=font-size:x-large;font-weight:bold;cursor:pointer>&#65291;</div></td>"+
    "<td><input type=text id=freePlayName placeholder='New item short name' maxlength=32></td>"+
    "<td><input type=text id=freePlayDescription placeholder='New item description of practice activity' maxlength=100 style=width:95%;x-overflow:auto></td>"+
    "<td><select id=freePlayCategory>";
    presetCats.forEach(cat => {
      t += "<option value='"+cat.name+"'>"+cat.description+"</option>";
    });
    t += "</select></tr>";

  tab.innerHTML = t;

  // attach drag events
  setTimeout(function() {
      let placeholder;

      const rows = document.querySelectorAll("#freePlayTbody tr[draggable=true]");
      let draggedItem = null;

      rows.forEach((row) => {

        row.cells[0].style.touchAction = "none"; // the drag icon is in cell[0] and we want to handle touches there

        // Touch Start
        row.cells[0].addEventListener('touchstart', function(e) {
          draggedItem = row;

          // Enhanced Placeholder
          placeholder = document.createElement('tr');
          placeholder.style.border = "3px dashed #ccc"; // Example styling
          placeholder.style.height = `${row.offsetHeight}px`; // Match the height of the original row
          placeholder.innerHTML = "<td colspan='6' style=text-align:center;background-color:lightgray>"+
            "MOVING: <strong>"+ row.cells[3].textContent+"</strong></td>"; // Adjust colspan as needed

          // Insert placeholder
          row.parentNode.insertBefore(placeholder, row);
          row.style.opacity = "0.5"; // Optional: make the dragged row semi-transparent

          e.preventDefault();
        }, {passive: false});

        // Touch Move
        row.cells[0].addEventListener('touchmove', function(e) {
          if (!draggedItem) return;

          const touchLocation = e.targetTouches[0];
          const targetElement = document.elementFromPoint(touchLocation.clientX, touchLocation.clientY);

          if (targetElement && targetElement.closest('tr') && targetElement.closest('tr') !== placeholder) {
            const targetRow = targetElement.closest('tr');
            const comparisonRect = targetRow.getBoundingClientRect();

            // Move placeholder
            if (touchLocation.clientY > comparisonRect.top + comparisonRect.height / 2) {
              targetRow.parentNode.insertBefore(placeholder, targetRow.nextSibling);
            } else {
              targetRow.parentNode.insertBefore(placeholder, targetRow);
            }
          }
          e.preventDefault();
        }, {passive: false});

        // Touch End
        row.cells[0].addEventListener('touchend', function(e) {
          if (draggedItem && placeholder) {
           // Finalize the drop
           const oldIndex = parseInt(draggedItem.getAttribute('data-index'));
           let newIndex = Array.from(placeholder.parentNode.children).indexOf(placeholder);

           // If dragging down, adjust for the removal of the original position
           if (newIndex > oldIndex) newIndex -= 1;

           // Reorder the freePlay array
           const [reorderedItem] = freePlay.splice(oldIndex, 1); // Remove item from old position
           freePlay.splice(newIndex, 0, reorderedItem); // Insert item at new position

           placeholder.parentNode.insertBefore(draggedItem, placeholder);
           placeholder.parentNode.removeChild(placeholder);
           draggedItem.style.opacity = "1"; // Restore opacity

           // Save the reordered array
           saveFreePlay();
           displayFreePlay(); // redraw
           createPresetMenu(); // items have changed order

           draggedItem = null; // Clear references
         }
          e.preventDefault();
        }, {passive: false});

        // Add drag and drop handlers

        row.addEventListener('dragstart', (event) => {
          freePlayDragIndex = row.getAttribute("data-index");
        });

        row.addEventListener('dragover', (event) => {
          event.preventDefault();
        });

        row.addEventListener('drop', (event) => {
          event.preventDefault();
          // Calculate target index and perform the swap
          const targetIndex = [...row.parentNode.children].indexOf(event.currentTarget);
          if (freePlayDragIndex !== targetIndex) {
            const itemToMove = freePlay[freePlayDragIndex];
            freePlay.splice(freePlayDragIndex, 1); // Remove the item from its original position
            freePlay.splice(targetIndex, 0, itemToMove); // Insert it at the new position
            saveFreePlay();
            displayFreePlay(); // redraw
            createPresetMenu(); // items changed order
          }
        });
      });  // end of foreach row
    }, 100);
}

function deleteFreePlay(index, value=true) {
  freePlay[index].deleted = value;
  saveFreePlay();
  displayFreePlay(); // redisplay
  createPresetMenu(); // items changed
}

function addNewFreePlay() {
  const name = document.getElementById("freePlayName").value.trim();
  const desc = document.getElementById("freePlayDescription").value.trim();
  const cat = document.getElementById("freePlayCategory").value.trim();

  if (name && desc && cat) {
    freePlay.push({name: name, description: desc, category: cat, deleted: false, isFreePlay: true});
    saveFreePlay();
    displayFreePlay();
    createPresetMenu(); // item added
    document.getElementById("freePlayName").value = "";
    document.getElementById("freePlayDescription").value = "";
  }
}

function saveEditFreePlay(edit) {
  const desc = document.getElementById("freePlayEditDescription").value.trim();
  const cat = document.getElementById("freePlayEditCategory").value.trim();

  if (desc && cat) {
    freePlay[edit] = {name: freePlay[edit].name, description: desc, category: cat, deleted: false, isFreePlay: true};
    saveFreePlay();
    displayFreePlay();
    createPresetMenu(); // item modified
  }
}

function dateToDaysSince1970(dateString) {
    const parts = dateString.split('-');
    if (parts.length === 2) {
      parts[2] = 1;
      console.log("auto added 01 day to date");
    } else if (parts.length !== 3) {
        throw new Error("Invalid date format. '"+dateString+"' Use yyyy-mm-dd.");
    }

    const year = parseInt(parts[0], 10);
    const month = parseInt(parts[1], 10) - 1; // Months are 0-indexed in JavaScript
    const day = parseInt(parts[2], 10);

    const inputDate = new Date(year, month, day);
    const januaryFirst1970 = new Date(1970, 0, 1); // January is month 0

    // Calculate the difference in milliseconds and convert to days
    const daysDifference = Math.floor((inputDate - januaryFirst1970) / (24 * 60 * 60 * 1000));

    return daysDifference;
}

function scrollToFirstNote() {
  if (beatsToPlay === null || noteScope === null) {
    return;
  }
  const firstbeat = [ beatsToPlay[0][noteScope[0].first], beatsToPlay[1][noteScope[1].first]];
  const hand = (firstbeat[0]>firstbeat[1]) ? 1 : 0;
  const ntp = document.getElementById("ntp_"+hand+"_"+noteScope[hand].first);
  console.log("NTP="+ntp+" hand="+hand+" note="+noteScope[hand].first);
  if (ntp !== null) {
      ntp.scrollIntoView({behavior:'smooth', block: 'nearest', inline: 'start'});
  }
}

function importExportHistory() {
  animateOpen('importExportContainer');

  //setTimeOut(function() {
    // this can take a while so async it
    const hist = JSON.stringify(runHistory);
    document.getElementById('importExportTextarea').value = hist;
    document.getElementById('importExportSizeDiv').innerHTML = "Bytes: "+hist.length;
  //},500);

  setTimeout(function() {
    document.getElementById("historyGraph").scrollIntoView({ behavior: "smooth", block: "end" });
  }, 1200);

}

function playGraph(speed = 1.0) {

  console.log("playing midi notes from graph");

  if (midiNotes === null || midiNotes.length === 0) {
    warning("There are no notes to play.");
    return;
  }

 document.getElementById("playNotesButton").style.color = "red";

 setTimeout(function() {
    document.getElementById("playNotesButton").style.color = "black";
 }, 1000);

if (1) {
  for (let i = 0; i < midiNotes.length; i++) {
    warning("MidiNote["+i+"]="+midiNotes[i].name+
     ":"+midiNotes[i].options.time+
     ":"+midiNotes[i].options.duration+
     ":"+midiNotes[i].options.attack);
  }
}


 midiOutput.channels[1].sendProgramChange(0); // grand piano or at least some kind of piano on most midi keyboards
 for (let i = 0; i < midiNotes.length; i++) {
   const opts = Object.assign({}, midiNotes[i].options); // make a shallow copy of the options
   if (speed !== 1) {
     opts.duration = parseFloat(opts.duration)/speed; // a speed of 1/2 doubles duration
     opts.time = "+"+(parseFloat(opts.time)/speed).toString();         // a speed of 1/2 doubles starting time
     warning("Changed dur to:"+opts.duration+" time to:"+opts.time);
   }
   midiOutput.channels[1].playNote(midiNotes[i], (speed===1)?midiNotes[i].options:opts);
 }
} // end of playgraph

function playNotesToPlay(speed = 1.0) {

  console.log("playing midi notes from notesToPlay array.");

  if (notesToPlay === null || notesToPlay.length === 0) {
    warning("There are no notes to play.");
    return;
  }

 const hand = getSelectedHand();

 const voice = avail(testOptions.midiVoice, 0); // default is grand piano

 midiOutput.channels[1].sendProgramChange(voice);

 const bpm = avail(testOptions.targetBPM, 120);
 const bpb = avail(testOptions.beatsPerBar, 4);
 const beatdur = avail(testOptions.beatDur, 1/4);
 const disconnectDur = avail(testOptions.disconnectDur, 10);

 for (let h = 0; h < 2; h++) {
   if ((h === 0 && hand === 'right') || (h === 1 && hand === 'left')) {
     continue; // not playing this hand
   }
   let firstBeat = -1;
   for (let n = noteScope[h].first; n <= noteScope[h].last; n++) {
     if (firstBeat === -1) {
       firstBeat = noteStartBeat[h][n];
     }

     const note = notesToPlay[h][n];
     if (note === -1) {
       continue; // we don't need to play a rest
     }
     const dur = durationsToPlay[h][n%durationsToPlay[h].length];
     // if there are independent hold times, use that for length of time to play note
     // otherwise assume it's the same as dur.
     const hold = isAvail(holdsToPlay[h])?holdsToPlay[h][n%holdsToPlay[h].length]:dur;
     console.log("hold="+hold+" dur="+dur);
     const durms = (60000/speed)*(hold/beatdur)/bpm - (disconnectDur/1000); // how many milliseconds should it play
     const t = (60000/speed)*(noteStartBeat[h][n]-firstBeat)/bpm;

     // this is a simple shot at "dynamics"
     let attack = 0.51; // weak beat, mezzo-piano
     const curbeat = (noteStartBeat[h][n])%bpb;
     if (bpb === 4) {
       if (curbeat === 0) {
         attack = 0.75; // strong beat, forte
       } else if (curbeat === 2) {
         attack = 0.63; // less strong beat, mezzo-forte
       } else if (curbeat > Math.trunc(curbeat)) {
         // fractional beat, even weaker than weak
         attack = 0.4;
       }
     } else if (bpb === 3) {
       if (curbeat === 0) {
         attack = 0.75; // strong beat, forte
       } else if (curbeat > Math.trunc(curbeat)) {
          // fractional beat, even weaker than weak
          attack = 0.4;
        } else {
          attack = 0.51;
        }

   } else if (bpb === 6) {
     if (curbeat === 0 || curbeat === 3) {
       attack = 0.85; // strong beat, forte
     } else if (curbeat > Math.trunc(curbeat)) {
        // fractional beat, even weaker than weak
        attack = 0.4;
      } else {
        attack = 0.51;
      }
   }
     // IMPLEMENT: We need more cases to cover other numbers of beats per bar
     // that are common. In the limit, a method for the user to specify the
     // metric stress pattern would be interesting since some styles of music
     // use other stress patterns.
     const opts = {
       duration: durms,
       time: "+"+t,
       attack: attack
     };
     midiOutput.channels[1].playNote(note, opts);
     console.log("Playing note "+note+" for "+durms+"ms at t="+t+ " attack:"+attack);
   }
 }
} // end of playNotesToPlay

function getToday() {
  let today = new Date();
  let yyyy = today.getFullYear();
  let mm = String(today.getMonth() + 1).padStart(2, '0'); // January is 0!
  let dd = String(today.getDate()).padStart(2, '0');
  let formattedDate = `${yyyy}-${mm}-${dd}`;
  return formattedDate;
}


function exportBackupFile() {
    let jsonStr = JSON.stringify(runHistory, null, 2);

    let blob = new Blob([jsonStr], { type: "application/json" });

    // Generate current date in yyyy-mm-dd format
    let today = new Date();
    let yyyy = today.getFullYear();
    let mm = String(today.getMonth() + 1).padStart(2, '0'); // January is 0!
    let dd = String(today.getDate()).padStart(2, '0');
    let formattedDate = `${yyyy}-${mm}-${dd}`;

    let url = URL.createObjectURL(blob);
    let a = document.createElement('a');
    a.style.display = 'none';
    a.href = url;
    // Update the filename to include the date
    a.download = `REPiano-backup-${formattedDate}.json`;

    document.body.appendChild(a);
    a.click();

    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    //runHistory[".PREF.lastBackupDate"] = Date.now();
    localStorage.setItem('REPiano.lastBackupTimestamp', Date.now());
    saveRunHistory();
    checkBackupStatus();

    alert(`
Backup of history has downloaded to your browser\'s download folder.
Be sure to back it up to cloud storage using a syncing app or perhaps
attach it to an email to yourself. Your device may someday be lost or
stolen, or crash, and your practice history data is important.`
  );
}

function toggleAdvancedImportExport() {
  const aiediv = document.getElementById("advancedImportExportDiv");
  const style = window.getComputedStyle(aiediv);
  const button = document.getElementById("AdvancedButton");
  if (style.display === 'none') {
    aiediv.style.display = "block";
    button.innerHTML = "Hide Advanced";
  } else {
    aiediv.style.display = "none";
    button.innerHTML = "Show Advanced";
  }
}

let currentHistoryDisplayGraph = true;

function toggleGraphRawData() {
  const button = document.getElementById("toggleGraphRawData");
  const graphdiv = document.getElementById("historyGraphDiv");
  const datadiv = document.getElementById("historyRawDataDiv");

  if (currentHistoryDisplayGraph) {
    button.innerHTML = "Show Graph";
    graphdiv.style.display= "none";
    datadiv.style.display= "block";
  } else {
    button.innerHTML = "Show Raw Data";
    graphdiv.style.display= "block";
    datadiv.style.display= "none";
    showHistory();
  }
  currentHistoryDisplayGraph = !currentHistoryDisplayGraph;
}

/// Metronome feature code and data
const metronomeTickBase64 = `AAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAAHRltZGF0IRFFABRQAUb/8QpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpd/+IUtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0uYQpaWlpaXghGxOjDoyMEbBQYhQIkBRElVrmqqURVNZqmSUGsnKXQEPQKUtn4oSzNXbdXJ5WynHAaT/b5jvfcW6Y14bvcOjMLc+PcDCK6QekAI3eNYfeO3TmC/YJjDLdOI3A+RPxrHuIgU9qw8PcQpnPwGD48sAI/b/f3w4AoGcS0aQ+QB4EbESMBYajEYKakRiqpKlKtmq1koKprJylwR/0ClLZ8U+555r2eMnl6d4FEVn3Hh6SjGEADt2AA93zvI7uj/wBt4GHpEUld7aQA/k5hcIjONTjgnZVkb5QEIsIAXUKUX+Lxdlk2e/j030Cc/KiwarYrGq69mvt7/RvXX8Zrc1jVWAA+NQ25qflEN/+IUtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0u8GEKWlpaWlpaWlpaWlpaWlpaWlpaXBwAAAAIJEAAAAB1nQgQf6QCgC3f+AAIAAoEAAAMAAQAAAwA8jwiEagAAAARozjyAAAAKmmWIhABf///h4SKAAItvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrwISsT+w7+BwgYRpnG9FTea5u5u+dS7ZeXvhTv4BEY2Wwx4oYd5D9S6w4wzR8JlOa/hNnc23UHnDkfMfbmBh648f4hDZ/DmqtxZmV+SKnE5PeYf8nlcH2u4kXxn6/8nylWo/63nGUbA/qel3/5GZhSYL2CoxfU8oZgyx/4d6+J/b+hs6E+YxTZjsdMbc8/DXQGTw/CRQ5zFQgodKA7dF+f+55Q2J3hsyYNccwtq3ANiq7MJEufLtDxLyTsj0fuu7AcAoYHEOnejmUE/SRenP/VBgv/fG9LD+3/8x4fONed4624LkMOZklmD/X2ePqr/RviePbHv/z1B8ftXl/meku7NzsH3/N/OHG/3P+nsq+PsePwar6gdUmioMnr2QDZwyGHsD929WThac20AUgsLttkBo6U8h5D9BmC2P2ncmFaRusP4fi/8HjOYP3Fwc6+n8VZH3IoxRoSJFCOOWcrisJEpSR9McjsjDfkRPmMFgfkacgALpmPtEMyIAf0FSLwCBEq75l1UmYVxu8ri6rnz49uXEzoA8+HJpONonoJN1uas2bINt/u1YC4s3BCcqCuTrTf93h8X3/PX6j9Z+s9f3dRATj3/8/WVbGkwa8swjkmz6DiHD8rh90eP39tuuTxcDw+oB9L7gaEmvfvf1K3AfO7iz5pPsvtv+BLhHRmDjTBAfY25WA+ctMn1dO1zf/wbfK/YlYDshdE/y+GO/xdUVZRNvqlLoA+dj4AMYrwuo08DtAsB7ouSnM+fwZXFG7RTn2zVf/5jwvOG69l9Dd3+d/0PD/aHPG99Sin93zfTcHWz5aBgjDPmQA8xwdONHFkqVoC5s8ba3JvXAg2aXufC4u/yZD/e80Zm+0fdOsXGOWAAAAWaOOBiBgdkYYh3AQCebfs/gFSNzm/z5ZgiRIkYIhYHTE7hJhF4P9TrMfoEwNCQ4IIUAQdJ1QsAcAhTcb1424fdt/0IhqWaakHfYO+xIK+zIJpzXxzqb5965fHWr5+f7+b3+K83xXj/0/9u+/1711fA7y/Xc2wGcM77hqfeYdnTqi+wCv/qD4pNqCnekpF1bmLkLD+t3Xs/5pz7DLegZ1gz0xDsw9s7vapeif/H4aHpg+SZ/aT1+Ow7jAviTV9EsothZPtsec9wfr+0Kx//4Hwv67Uv9/pqVAfY97fVPFMkUZ9UqQH/hrT2/cen6BhbTxZTyxy7oMdUfHkDcABmK3QZG/Ce5dU2zUQfvege054+n5ZvNU//HZbfsX9vqL8RmrMfwnKmFUMCxg9kO9kbrkzz0JTvY2Hcem1kE2iQsvFtk6i4lf87AvVhJCE06GnDHW5dS02/Uorc7v5g9q1CJSk2PpuYs+W0650BKwVGjWKPzCh1Tk9zVVsWDPmbXRHqVzCf4THEH9inMVVzcgSnGOemlk4kyLS/TuKfolAhdcNfRoCqLDNQDl7P3NrSTIO5Ttg77B32DQ3xRkiQTRzL1M5r9PaXXEn7clSa1fj36lfHd+WkUNnAAyBG9HHPTVgK1VePHopqiKTxuC+evaH0VIn7MZi7X0LbLZic09WA4LKtHzLtEH2j3DLMZyrx864xkPkOyM1MFsqcYtn5bcl5fCdYZYtq+FR1jcg6zc/wvkZkIpaj9m+LWxfFtzBo8+AAFgPIgAHwFINZo4WxGJ/lfuzqD+5nmswxloz7hVEhSWsfn5fB0NlnR86DlwufeNrb7f/V2kKzgbH7qspcDFjfw+hMvc18+yJ1Xo3JP9O6AR7Rnlf/95i58w1EGpTpXNcdVMHPr+iq0Ad/d50g+8F1OKF60sUTDyei387bhWFWDMTqwYN5NTmnAtV5F/z8ox80UziSwikiHNOZtE3EM9HYxLZCNac3luwOgk0Ytl6NhU59rf9s+9+99x7QqqoTCOqMwsRFdnyO5e/FzyesBwQgBwAAAACCTAAAAAIQZoiAZ4AOEYhexRVLtdIgoEErmr13u9d+/iedeUzmr44y8SXd1PumGshWgMTvGWdlxM7cZ19uo6SxWSzroW1Vra8bgX2RsOclYT8D9vk8H2CkmLEWp0odAdc2VX8hmt8oXU2dRUhrfLk3vmm+ME6BpiyvPIjxo7MPTX2mP3Y5Y0i15zIGLQZpPFJwvNMxVOoGEu3+KtxujzjK8zJYbPcxZJROyEjhJGvTtPHAPsFNVODYOmjHqkLqbBhqsehPz8V52iHyhW9PgTNNrzVjt+LoNjMmXTZ+S7XHgFFVnF0z3VM8fb2GcoXDmNVydNL/wl5k+YWkFTjw6fypYAzgupTt3JvNWHA1nt7vze9nRlhWkmSk+oUFo5OnvEtM4N+l1Y9SRfAqr4mt/E1ywNBE5fATJXQRJBSqWXzHblFlsCLVdip8CsJBYYJeF8Pzrjx6yav2qPEnHFXhNNVbWVLI4AAKAl5f3YkiK7BHbjtxaN697vLkTrfqDkp0tnFsiDxj0He6sqkQ5BRYOyloB/B1T2LrvJnOAjmZRCDctZxXlei2e3BqA4ookUkeZOQPEU16EEvAMvKLZTZlrHYOx+XqGecdrkMNAW03b7lomJiONrIOPiejcHxvpVSgRGe6azpdhqZUZsejyGgvbSvfhCQuVDF9b4ydnbpDPNyL9FSXjuJSL6C2Ft47uN0LMIbR9ZGFGAAAdH1aMu1y3hTj1VSYL19XkqQArsoT3+z6gGHhtHA0CkrfToOm7hjEjAHAAAAAgkwAAAACEGaRAGeADhGIRsULS7FRrHRbOoQMIyqXuVm/4r286TNtamaZdcRH7qB5o8xMf018utRlPllboKCPvcFkeqVHWtYalv5/9zdAtDxoh2mRg5DcKsQYwfyuU8spXSZpYKTVcrrEb3z7HA5qvuorfL7kf9CWgPvSfcO0OP9jXaWMtZY1kkgr1a2eZgRG2D5HVym9Bbc6eqfnWdwQ2vcUs55UALOtc/1TnN4itVlkuKMuikRTNpbK7k0mTdHqrurR3jSCO39ZDpeRoxEOX1RzjRyTtj24wyjbNMyEXC5haIxZN+MQStleAABmRJ6nml5islXNMAyeBAFSU1fl5wECcAe3Q5pAaIHIuooLEnJoKZcIsAawFAAAxMY8Tg0OFUmGbjIdBj4nXJfDH0b/96wJQ/LcvClhKRFIIZUWYQ0pw0Jw0GSgUiBvj1d5z+nPxr2MzOOJS8alS6/yUOx2gz2/w7NJ4OlgaGg+sM9ZyKouGpgdYlHXlTdrAa8f7rk8NPUZ8zVDZpLpFv5zC6FpFMeifRB+q7R3d3dB9Qm7t/W69P45bFEivPzSnPbt9UuSfmmrTeVWKE1DB8czMWp+ckZTwM/2LvPW/Cv7Hm18BfcBgjwcToBfwVlXTf3LvhaTOvb9saSVaXlKMdzfAxQZ/7tL+z31IoKGyn7zt8l5ndQbk+iq2Gc/RfaPifs3rIA6vpt2y+nA3cTQBXL4e0npMwDQ9x5HquvN+L0PWOJepryVsnPAAueE3lgF3ZV+5k3K7euBAMJkMRNMAMHIRsP5bv//wBC1SEqFiiEhiNBGVJuXXj3nV3bO7mrXlStSrLBeNZYgpJEkDoFEIhJe84kcfQSq+Ysk/yfCTT1EF/z/04DsG3+u23b4B7/ygUHD8wf8r3TgW7DSLHnWscbyreOrprA85/wmF0dunLOmuHM3jEPY9oo1L5Tndyxw+Y1z9Bcn3hlkGGUQ+UgiXEdGJopJF2mDTVONgy7idGpbGUzJm3rZJq2cJaoZq2e5qbUmqClG4O17mptWaR7mhhqa2cgnAGqWoRzBY7uf6f8xVGA3Z/v/nL2UJIVNtSG7p2kd8wGgMtt+DFZOnalKOkjoIE0kwC8VNM4snkcxIKmnqIlCDCMrAjxXVdWi/qxWh44YrHBTKwu8FZxqvJWaq8FZxCyMIPkUgOYLIwiuRW7w7Fp8FYUDYiDYtCNzOuYc/bf3tNc704tMq1xEdBeNZYgpJEkDoFSkiqubMolrhoSv6er4S0tDHKOuyLsjCxNUDGs9CNEwDNQ/QujaQYiUl3e7FRcCaChgazW4U890aDiQCc7Nr/gDn/pZ/NwUSGhiCtJGEBnyQyVPHnTZ2G9c0MgiZJBVTtiQv+OVJbtRALIIIbTSYnNXgnbKvAeGtGBcm9Y7SuJU0c5LpUea4oLh+T2tUeF7KKhA45sf3+nu4m5OAgA1rud8SQwQLNmoEEjt6/zY+P55ogoADF8XpjTBSw2BSGRnBcplo2LLIwiuRSA9QsjCK5FID1MqZcmzuozrnzkyvqyplumztnzrnskyvqyaW6bO2fN57JMr5cmluoztnzfKyrK+XJs7qM657HysqyplyuoVTFvVww79lFTq+cPNzwj7P30JJsox7XTl/dxRRRRcAAAAAIJMAAAAAhBmmYBngA4RiEbD8GEP///t9phqDEIQYQKK55zJ53q8XRM1jWVhMJ6IAHigUJSbWCk9AJDDXYaBHk4n5MiQE/Dl4n4HgnW3ouhPz258s1DcXKp2tKfi6ZOLVYYlVJY7bJYnLJSHi2UeplFswFBMI7OAubdN1tVJYvktUd7g2HHi4L82DfarxVgmqSPb5tspJLOoXSUz4X0YWTVy421YxJSkh0VrMIAAA42qGEJQhEhA3VVvK7nTjKp7SkxrJg2AeFAoSk1pGfdswCyrBfmYo7xz/d5g/FeS9Af0uf8RkBTOFR1mSTLm3TdrlS73taWsqoYrRYlmEgUi80NlItnBfZQjUWLbJoV2TvR+22NxxzUhk8+Vrnytc8zv25Vc5syaOfLnzc25xrnytADBwAABi5tb292AAAAbG12aGQAAAAAAAAAAAAAAAAAAAPoAAAApwABAAABAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAACS3RyYWsAAABcdGtoZAAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAhgAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAFAAAAAtAAAAAAACRlZHRzAAAAHGVsc3QAAAAAAAAAAQAAAIYAAAAAAAEAAAAAAcNtZGlhAAAAIG1kaGQAAAAAAAAAAAAAAAAAADwAAAAIAFXEAAAAAAAtaGRscgAAAAAAAAAAdmlkZQAAAAAAAAAAAAAAAFZpZGVvSGFuZGxlcgAAAAFubWluZgAAABR2bWhkAAAAAQAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAABLnN0YmwAAACac3RzZAAAAAAAAAABAAAAimF2YzEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAFAALQAEgAAABIAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY//8AAAA0YXZjQwFCBB//4QAdZ0IEH+kAoAt3/gACAAKBAAADAAEAAAMAPI8IhGoBAARozjyAAAAAGHN0dHMAAAAAAAAAAQAAAAQAAAIAAAAAFHN0c3MAAAAAAAAAAQAAAAEAAAAcc3RzYwAAAAAAAAABAAAAAQAAAAEAAAABAAAAJHN0c3oAAAAAAAAAAAAAAAQAAArNAAAAEgAAABIAAAASAAAAIHN0Y28AAAAAAAAABAAABIoAABT2AAAXOgAAHAwAAAJ2dHJhawAAAFx0a2hkAAAAAwAAAAAAAAAAAAAAAgAAAAAAAACnAAAAAAAAAAAAAAABAQAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAJGVkdHMAAAAcZWxzdAAAAAAAAAABAAAAeAAACAAAAQAAAAAB7m1kaWEAAAAgbWRoZAAAAAAAAAAAAAAAAAAArEQAABzBVcQAAAAAAC1oZGxyAAAAAAAAAABzb3VuAAAAAAAAAAAAAAAAU291bmRIYW5kbGVyAAAAAZltaW5mAAAAEHNtaGQAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAV1zdGJsAAAAZ3N0c2QAAAAAAAAAAQAAAFdtcDRhAAAAAAAAAAEAAAAAAAAAAAACABAAAAAArEQAAAAAADNlc2RzAAAAAAOAgIAiAAIABICAgBRAFQAAAAADYVQAA2FUBYCAgAISEAaAgIABAgAAACBzdHRzAAAAAAAAAAIAAAAHAAAEAAAAAAEAAADBAAAAQHN0c2MAAAAAAAAABAAAAAEAAAACAAAAAQAAAAMAAAABAAAAAQAAAAQAAAACAAAAAQAAAAUAAAABAAAAAQAAADRzdHN6AAAAAAAAAAAAAAAIAAACLQAAAi0AAALJAAAC1gAAAjIAAAI9AAACgwAAASMAAAAkc3RjbwAAAAAAAAAFAAAAMAAAD1cAABUIAAAXTAAAHB4AAAAac2dwZAEAAAByb2xsAAAAAgAAAAH//wAAABxzYmdwAAAAAHJvbGwAAAABAAAACAAAAAEAAAD5dWR0YQAAAPFtZXRhAAAAAAAAACFoZGxyAAAAAAAAAABtZGlyYXBwbAAAAAAAAAAAAAAAAMRpbHN0AAAALal0b28AAAAlZGF0YQAAAAEAAAAAaHR0cHM6Ly9jbGlwY2hhbXAuY29tAAAAj6ljbXQAAACHZGF0YQAAAAEAAAAAQ3JlYXRlIHZpZGVvcyB3aXRoIGh0dHBzOi8vY2xpcGNoYW1wLmNvbS9lbi92aWRlby1lZGl0b3IgLSBmcmVlIG9ubGluZSB2aWRlbyBlZGl0b3IsIHZpZGVvIGNvbXByZXNzb3IsIHZpZGVvIGNvbnZlcnRlci4=`;


function metronomeIconSVG(small=false) {
  if (small) {
    return `<svg version="1.1" id="small_Metronome" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 11 11" style="enable-background:new 0 0 314 314;" xml:space="preserve" width="11" height="11"><path d="M9.874 1.634a0.251 0.251 0 0 0 -0.122 -0.168l-0.394 -0.22 0.185 -0.333a0.245 0.245 0 1 0 -0.428 -0.239l-0.185 0.333 -0.394 -0.22a0.245 0.245 0 0 0 -0.351 0.134L7.7 2.326a0.244 0.244 0 0 0 0.112 0.294l0.166 0.093 -0.81 1.454L6.466 0.599A0.762 0.762 0 0 0 5.737 0H3.774a0.762 0.762 0 0 0 -0.729 0.6l-1.43 7.263v0.001l-0.481 2.443c-0.035 0.178 0.007 0.355 0.115 0.486s0.274 0.207 0.455 0.207h6.103c0.181 0 0.346 -0.075 0.455 -0.207s0.151 -0.309 0.115 -0.486l-0.481 -2.443 -0.581 -2.95L8.407 2.953l0.166 0.093a0.244 0.244 0 0 0 0.309 -0.059l0.941 -1.151a0.251 0.251 0 0 0 0.051 -0.201M3.526 0.694a0.275 0.275 0 0 1 0.247 -0.204h1.964c0.108 0 0.227 0.097 0.247 0.204l0.815 4.136 -1.054 1.894a2.357 2.357 0 0 0 -0.744 -0.188v-0.522h0.384a0.245 0.245 0 1 0 0 -0.49h-0.384V4.079h0.384a0.245 0.245 0 1 0 0 -0.49h-0.384V2.145h0.384a0.245 0.245 0 1 0 0 -0.49h-0.384v-0.431a0.245 0.245 0 1 0 -0.49 0v0.431h-0.384a0.245 0.245 0 1 0 0 0.49h0.384v1.444h-0.384a0.245 0.245 0 1 0 0 0.49h0.384V5.524h-0.384a0.245 0.245 0 1 0 0 0.49h0.384v0.522c-0.681 0.062 -1.127 0.375 -1.527 0.654 -0.277 0.194 -0.525 0.368 -0.824 0.441zm4.357 9.787c-0.015 0.019 -0.042 0.028 -0.076 0.028H1.705c-0.034 0 -0.061 -0.01 -0.076 -0.028s-0.02 -0.047 -0.013 -0.08l0.444 -2.255c0.496 -0.056 0.856 -0.309 1.207 -0.554 0.423 -0.296 0.822 -0.576 1.49 -0.576s1.067 0.28 1.49 0.576c0.35 0.246 0.712 0.498 1.207 0.554l0.444 2.255q0.009 0.052 -0.013 0.08M7.35 7.629c-0.299 -0.073 -0.548 -0.247 -0.824 -0.441a7.857 7.857 0 0 0 -0.349 -0.236l0.768 -1.379zm1.282 -5.113 -0.402 -0.224 0.321 -0.934 0.706 0.393z"/></svg>
    `;
  } else {
    return `<svg version="1.1" id="large_Metronome" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 40 40" style="enable-background:new 0 0 314 314;" xml:space="preserve" width="40" height="40"><path d="M35.905 5.94a0.892 0.892 0 0 0 -0.442 -0.612l-1.434 -0.799 0.675 -1.212a0.892 0.892 0 1 0 -1.558 -0.868l-0.675 1.212 -1.434 -0.799a0.892 0.892 0 0 0 -1.277 0.489l-1.759 5.109a0.892 0.892 0 0 0 0.409 1.069l0.604 0.337 -2.945 5.287 -2.555 -12.975C23.274 0.957 22.11 0 20.864 0h-7.14c-1.246 0 -2.41 0.957 -2.651 2.18l-5.2 26.41 -0.001 0.004 -1.749 8.882c-0.127 0.645 0.026 1.291 0.42 1.77 0.394 0.479 0.997 0.754 1.655 0.754h22.19c0.658 0 1.261 -0.275 1.655 -0.754s0.548 -1.124 0.421 -1.77l-1.749 -8.884 0 -0.001 -2.113 -10.729 3.969 -7.127 0.604 0.337a0.891 0.891 0 0 0 1.124 -0.215l3.419 -4.185a0.892 0.892 0 0 0 0.185 -0.731M12.823 2.524c0.076 -0.388 0.506 -0.741 0.901 -0.741h7.14c0.395 0 0.825 0.353 0.901 0.741l2.962 15.041L20.892 24.45c-0.786 -0.337 -1.671 -0.589 -2.706 -0.683v-1.901h1.396a0.892 0.892 0 1 0 0 -1.783h-1.396v-5.25h1.396a0.892 0.892 0 1 0 0 -1.783h-1.396v-5.25h1.396a0.892 0.892 0 1 0 0 -1.783h-1.396V4.451a0.892 0.892 0 1 0 -1.783 0v1.566h-1.396a0.892 0.892 0 1 0 0 1.783h1.396v5.25h-1.396a0.892 0.892 0 1 0 0 1.783h1.396v5.25h-1.396a0.892 0.892 0 1 0 0 1.783h1.396v1.901c-2.477 0.225 -4.101 1.362 -5.55 2.378 -1.006 0.705 -1.908 1.337 -2.996 1.602zm15.844 35.589c-0.055 0.067 -0.154 0.104 -0.278 0.104H6.199c-0.124 0 -0.223 -0.037 -0.278 -0.104s-0.072 -0.171 -0.048 -0.293l1.615 -8.2c1.802 -0.203 3.115 -1.122 4.389 -2.015 1.536 -1.077 2.987 -2.095 5.417 -2.095s3.881 1.017 5.417 2.095c1.274 0.894 2.587 1.812 4.389 2.015l1.615 8.2c0.024 0.122 0.007 0.226 -0.048 0.293m-1.936 -10.367c-1.089 -0.265 -1.991 -0.896 -2.996 -1.602 -0.404 -0.284 -0.822 -0.577 -1.269 -0.857l2.793 -5.015zm4.661 -18.596 -1.462 -0.814 1.169 -3.396 2.565 1.429z"/></svg>
    `;
  }
}

let audioContext = new (window.AudioContext || window.webkitAudioContext)();
let gainNode = audioContext.createGain(); // Create a GainNode
gainNode.connect(audioContext.destination); // Connect the GainNode to the destination
let audioBuffer; // This will store the decoded audio data

function setMetroBPM(value, absolute=false) {

  if (absolute) {
      metroBPM = value;
  } else {
      metroBPM += value;
      metroBPM = Math.round(metroBPM/value,value)*value;
  }

  if (metroBPM > 480) {
    metroBPM = 480;
  }
  if (metroBPM < 10) {
    metroBPM = 10;
  }
  updateMetronome();
}

async function loadAudioBuffer() {
    const response = await fetch(`data:audio/wav;base64,${metronomeTickBase64}`);
    const arrayBuffer = await response.arrayBuffer();
    audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
}

let tickNum = 0;

function scheduleTick(time) {
    const source = audioContext.createBufferSource();
    source.buffer = audioBuffer;
    source.connect(gainNode);
    //console.log("DUR="+audioBuffer.duration);
    if ( (tickNum % testOptions.beatsPerBar) === 0) {
      source.playbackRate.value = 1;
    } else {
      source.playbackRate.value = 2;
    }
    tickNum++;
    gainNode.gain.value = avail(preferences.metroVolume, 0.5);
    source.start(time);
}

function playTick() {
    if (!metronomeRunning) return;

    nextTickTime += tickInterval; // Schedule the next tick
    scheduleTick(nextTickTime); // Schedule this tick

    // Calculate the exact time to call playTick again
    let currentTime = audioContext.currentTime;
    let timeUntilNextTick = nextTickTime - currentTime;

    // Schedule the next call to playTick
    setTimeout(playTick, timeUntilNextTick * 1000);
}

function startMetronome() {
    const metroIcon = document.getElementById("metronomeIcon");
    if (metronomeRunning) {
        stopMetronome();
        updateMetronome();
        return; // Prevent multiple instances
    }
    console.log("Starting metronome");

    tickNum = 0;
    metroSmartExtra = 0;
    metronomeRunning = true;
    updateMetronome();

    nextTickTime = audioContext.currentTime;

    loadAudioBuffer().then(() => {
        playTick(); // Start ticking
    });
}

function stopMetronome() {
    metronomeRunning = false; // This will stop the scheduling of new ticks
    metroSmartExtra = 0;      // reset smart metro
}

function updateMetronome() {
  const metroIcon = document.getElementById("metronomeIcon");

  if (metronomeRunning) {
        metroIcon.style.backgroundColor = "green";
  } else {
        metroIcon.style.backgroundColor = "transparent";
  }
  tickInterval = 60 / (metroBPM+metroSmartExtra); // Calculate the interval for the given BPM

  drawMetronomeIndicators();

  updateSmartMetronome();
}

function drawMetronomeIndicators() {
  let bpmreport = String(metroBPM);

  let mfsize = 'mf';
  let adjbpmy = -6;
  let pad = 5;
  let bpmfontsize = 30;
  let iconsize = 40;
  if (metroExpanded) {
    mfsize = 'mfxl';
    adjbpmy = -6;
    pad = 10;
    bpmfontsize = 40;
    iconsize = 60;
  }

  document.getElementById("large_Metronome").style.width = iconsize+"px";
  document.getElementById("large_Metronome").style.height = iconsize+"px";

  if (metroSmart) {
    bpmreport = bpmreport + `<span class=${mfsize} style=color:blue>+${String(metroSmartExtra)}</span>`;
  }

  document.getElementById("metronomeDiv").innerHTML = `
    <div style=line-height:1>
    <div class=${mfsize} style=align-self:center;display:flex;flex-direction:row;width:100%>
        &nbsp;
        <span onclick=setMetroBPM(-10) style=padding:${pad}px>&#9194;</span>
        &nbsp;<span onclick=setMetroBPM(-1) style=padding:${pad}px>&#9664;&nbsp;</span>

        <div class=mfxl onclick="metroExpanded=!metroExpanded;updateMetronome();"
          style=padding:${pad-2}px;font-size:${bpmfontsize}px;transform:translateY(${adjbpmy}px)>
          ${bpmreport}</div>

        <span onclick=setMetroBPM(+1) style=padding:${pad}px;padding-left:{$pad+2}px>&#9654;</span>
        &nbsp;<span onclick=setMetroBPM(+10) style=padding:${pad}px>&#9193;</span>
      </div>
    <label id=metroVolumeMuteSymbol for:metroVolumnSlider class=${mfsize} style=position:relative;top:-3px>
      &nbsp;&#128266;</label>
    <input type=range id=metroVolumeSlider onchange='adjustMetroVolume()' min=0 max=1 step=0.1 value=
      preferences["metroVolume"]+" style=width:75%;>
    </div>
    `;
}

function cycleSmartMetronome() {
  metroSmart = !metroSmart;

  updateSmartMetronome();
}

function updateSmartMetronome() {
  const smd = document.getElementById("smartMetronomeDiv");

  const fsize = metroExpanded?"large":"x-small";

  if (metroSmart) {
    const strikenames = ["QFAIL","PASSING","GOOD","EXCELLENT"];
    const value = strikenames[preferences.metroSmartIncStrikes];
    smd.innerHTML = `<div style=display:flex;flex-direction:row>
      <div  style=font-weight:bold;font-size:${fsize}><span style=color:grey><i class="fa-solid fa-arrow-rotate-right"></i></span>
        SMART</div>&nbsp;&nbsp;<div onclick=smartMetronomeMenu style=font-style:italic;font-size:${fsize}>
        +${preferences.metroSmartInc} on ${value}, Max: +${preferences.metroSmartExtraMax}</div>
        </div>`;
  } else {
    smd.innerHTML = `<div style=font-weight:bold;font-size:${fsize}><i class="fa-solid fa-arrow-rotate-right"></i>FIXED</div>`;
  }
}

function adjustMetroVolume() {
  const volslider = document.getElementById("metroVolumeSlider");
  const val = volslider.value;
  setPref("metroVolume", val);
  document.getElementById("metroVolumeMenu").value = val;
  localStorage.setItem("metroVolume", val);
  if (val == 0) {
    document.getElementById("metroVolumeMuteSymbol").innerHTML = "&#128263;"; // muted speaker
  } else {
    document.getElementById("metroVolumeMuteSymbol").innerHTML = "&#128266;"; // non-muted speaker
  }
}

function toggleLearningScheduleMenu() {
    var menu = document.getElementById('learningScheduleMenu');
    if (menu.style.display === 'none') {
        menu.style.display = 'block';
    } else {
        menu.style.display = 'none';
    }
}

function updateLearningSchedule(schedule) {
    console.log("Schedule updated to:", schedule);
    // Here you would typically update some data or call a server-side API
    document.getElementById('learningScheduleMenu').style.display = 'none'; // hide menu after selection
    setLearningSchedule(schedule, true);
}

function setLearningSchedule(schedule, isnew = false) {

  if (isnew) {
    testOptions.learningSchedule = schedule;
    runHistory[".PREF.LEARNINGSCHEDULE."+stripPresetModifiers(curPresetName)] = schedule;
    saveRunHistory();
  }

  const icondiv = document.getElementById("learningScheduleDiv");
  if (schedule === "" || schedule === null) {
    console.log("empty schedule, set to begin");
    schedule = "begin";
  }
  console.log("Setting LearningSchedule for /"+avail(schedule, "begin")+"/ to icon: /"+learningScheduleIconName[schedule]+"/");
  icondiv.innerHTML = `<i id=learningScheduleIcon class="${learningScheduleIconName[schedule]}" style=font-size:18px aria-hidden="true"></i>`;
}


</script>
</body>
</html>
