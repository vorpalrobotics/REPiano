<!DOCTYPE html>
<html>
<head>
  <title>REPiano Practice Tracker</title>
  <style>
    .green-note {
      color: green;
    }
    .red-note {
      color: red;
    }
    th.col, td.col, td, th {
      border-left:1px solid black;
      border-right:1px solid black;
    }
    th {
      border-top:1px solid black;
      border-bottom:1px solid black;
    }
    button, select {
      font-size:14px;
      margin-right:20px;
    }

    .bigstat {
      font-size: 30px;
    }

    .smallstat {
      font-size: 18px;
    }

    body {
      margin: 2px;
      padding: 0px;
    }

    .container {
      position: relative;
      right:0;
      top:0;
    }

    .gear-button {
      position: fixed;
      top: 30px;
      right: -25px;
      width: 40px;
      height: 40px;
      background-color: transparent;
      border: none;
      cursor: pointer;
    }

    .gear-icon {
      fill: #808080; /* Gray color for the gear icon */
    }

    .mode-container {
      display: inline;
    }

.mode-box {
  display:inline;
  text-align: center;
  margin-right: 5px;
  padding: 2px;
  padding-left:10px;
  padding-right:10px;
  margin-right:15px;
  background-color: white;
  color: lightgrey;
  font-weight: normal;
  cursor: pointer;
  border: 1px solid black;
}

.selected {
  background-color: lightgreen;
  color: black;
  font-weight: bold;
}
#popup-container {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: auto;
  height: auto;
  background-color: rgba(0, 0, 0, 0.5);
  justify-content: center;
  align-items: center;
}

#popup-form {
  background-color: white;
  padding: 20px;
  border-radius: 5px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

#popup-form select, #popup-form button {
  margin: 5px 0;
}


  </style>
  <script src="https://cdn.jsdelivr.net/npm/webmidi@next/dist/iife/webmidi.iife.js"></script>
</head>
<body>
  <div class="container">
    <button class="gear-button" id="gearButton" onclick="showPrefs(true)">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M24 13.616v-3.232c-1.651-.587-2.694-.752-3.219-2.019v-.001c-.527-1.271.1-2.134.847-3.707l-2.285-2.285c-1.561.742-2.433 1.375-3.707.847h-.001c-1.269-.526-1.435-1.576-2.019-3.219h-3.232c-.582 1.635-.749 2.692-2.019 3.219h-.001c-1.271.528-2.132-.098-3.707-.847l-2.285 2.285c.745 1.568 1.375 2.434.847 3.707-.527 1.271-1.584 1.438-3.219 2.02v3.232c1.632.58 2.692.749 3.219 2.019.53 1.282-.114 2.166-.847 3.707l2.285 2.286c1.562-.743 2.434-1.375 3.707-.847h.001c1.27.526 1.436 1.579 2.019 3.219h3.232c.582-1.636.75-2.69 2.027-3.222h.001c1.262-.524 2.12.101 3.698.851l2.285-2.286c-.744-1.563-1.375-2.433-.848-3.706.527-1.271 1.588-1.44 3.221-2.021zm-12 2.384c-2.209 0-4-1.791-4-4s1.791-4 4-4 4 1.791 4 4-1.791 4-4 4z"/> </svg>
     </button>
</div>
      <button id="fullscreenButton" onclick="fullscreen()"
        style="position:fixed;right:-15px;top:2px;background:lightblue;">Full Screen</button>
  <div style=user-select:none>
    <span id=uitop style="font-size:18px"><strong>REP<em>iano</em></strong>&nbsp;&nbsp;</span>
    <button id="generateNotesButton" onclick="showTestGenerateForm();">Scales/Arps</button>
    <button id="setNotesButton" onclick="setNotes()">Set Custom Notes</button>
    <button id="doneButton" onclick="done()" style=display:inline disabled>DONE</button>
    <button id="historyButton">History</button>
  </div>

  <div style="max-height:90vh; padding-top:10px;">
    <table id=data style="border-collapse:collapse; border: 1px solid black;width:100%">
      <tr style="border-bottom:1px solid black;vertical-align: top;">
        <td style='width:20%;vertical-align:top;'>
          <div style='width:100%;height:100%;text-align:center;vertical-align:top;'>
          <div id="elapsedTime" style="font-size:60px;text-align:center;width:100%;user-select:none;">0:00</div>
          <div style="display:inline-block;width:100%;">
          <button id="testNotesButton" onclick="testNotes()" style=font-size:24px;display:inline;margin-right:5px;>START</button>
          <button id="pauseButton" onclick="pauseTest()" style=margin-right:0;display:none;font-size:24px;font-weight:bold;border:none;background-color:white>&#x23F8;</button>
        </div>
        </div>
        </td>
        <td colspan=4><div id="statsDiv" style="font-size:12px;user-select:none;">&nbsp;<br>&nbsp;</div></td></tr>
        <tr><td colspan=2 style="border-bottom:1px solid black;position:relative;">
          <div style="width:100%">
              <canvas id=graphCanvas style="width:100%;height:70vh;position:relative;"></canvas>
          </div>
          <div style="position:absolute;bottom:0;left:0;max-width:95vw;overflow-x:auto;overflow-y:hide;white-space:nowrap;user-select:none;">
            <strong>LH:</strong>
            <div id="notesLH" style="display:inline-block"></div><br>
            <strong>RH:</strong>
            <div id="notesRH" style="display:inline-block"></div>
          </div>
          <div style="position:absolute;top:15vh;right:0;border:1px solid black;padding-left:5px;border-radius:5px;margin-right:2px;user-select:none">
            <div id=playNotesButton style='cursor:pointer' onclick="playGraph();">
              <svg version="1.1" id="svgPlayButton" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 24 24" style="enable-background:new 0 0 330 330;transform:translateY(4px);" xml:space="preserve" width="24" height="24"><path id="XMLID_308_" d="M2.744 23.863a1.09 1.09 0 0 0 1.107 -0.029l17.455 -10.909a1.091 1.091 0 0 0 0 -1.85L3.851 0.166A1.091 1.091 0 0 0 2.182 1.091v21.818a1.091 1.091 0 0 0 0.562 0.954z"/>
              </svg>
            </div><br>
            <div onclick="magnifyScreen(1)" style=font-size:30px;font-weight:800;cursor:pointer;user-select:none>+</div><br>
            <div onclick="magnifyScreen(-1)" style=font-size:30px;font-weight:800;cursor:pointer;user-select:none>&ndash;</div>
          </div>
          <div style="position:absolute;top:0;left:25%;text-align:left;user-select:none;">
            <canvas id="keyboardCanvas" style="width:60vw;height:4vw" ontap="playVoice(event);" onclick="playVoice(event)"></canvas>
            <br>
            <div id="presetMenuContainer" style="font-size:24px;display:inline;width:30%;text-align:center;"></div>
            <div class="mode-container">
              <div class="mode-box" id="lh" onclick="changeSelectedHand('left')" title="play only left hand" style=user-select:none;>LH</div>
              <div class="mode-box" id="rh" onclick="changeSelectedHand('right')" title="play only right hand" style=user-select:none;>RH</div>
              <div class="mode-box" id="ht" onclick="changeSelectedHand('both')" title="play hands together" style=user-select:none;>HT</div>
            </div>
            <div id=meterDiv onclick="cycleMeter();" style=display:inline-block;width=2em;>1/4</div>
            <div id=pedalSymbolDiv style=display:inline-block;width:4em;>&nbsp;</div>
            <br>
            <div id="routineContainer" style="font-size:24px;display:inline;width:30%;text-align:center;display:none">
              <select id="routines">
                <option>no routine</option>
                <option>Arp C-Am-F-G</option>
            </div>
          </div>

          </td></tr>
      <tr>
        <div id=runSummary style="">
        </div>
      </tr>
      <tr>
        <td colspan=2 style="vertical-align: top;">
          <strong>Console:</strong>
          <div id="console" style="max-height:40vh;overflow-y:auto;"></div>
        </td>
      </tr>
    </table>
    <!-- Preferences Screen -->
  <div id="prefsScreen" class="prefs-screen" style="display:none;position:fixed;top:60px;right:10px;background-color:lightgrey;padding:10px;">
    <div style="max-height:70vh;overflow-y:auto;">
    <h2 style=margin-top:2px;padding-top:2px;>Preferences</h2>
    <label>
      <input id='autoFullscreenStartToggle' type="checkbox" onchange="togglePref('autoFullscreenStart')" checked />
      Auto Full Screen on START
    </label><br>
    <label>
      <input id='autoExitFullscreenStopToggle' type="checkbox" onchange="togglePref('autoExitFullscreenStop')" checked />
      Auto Exit Full Screen on STOP
    </label><br>
    <label>
      <input id='qualFailRepSuccessToggle' type="checkbox" onchange="togglePref('qualFailRepSuccess')" checked />
      QFail Still Counts as a REP
    </label><br>
    <label>
      <input id='showKeyboardToggle' type="checkbox" onchange="togglePref('showKeyboard')" checked />
      Show Keyboard
    </label><br><br>
    <label>
      BPM=quarter, played=
      <select id=bpmNoteValueMenu onchange="setPref('bpmNoteValue', this.value)">
        <option value="whole">whole</option>
        <option value="quarter" selected>quarter</option>
        <option value="eighth">eighth</option>
        <option value="sixteenth">sixteenth</option>
      </select>
    </label><br>
    <label>
      Ignore outrange notes, semitones:
      <select id=noteFilterMenu onchange="setPref('noteFilter', this.value)">
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3" selected>3</option>
        <option value="-1">don't ignore</option>
      </select>
    </label>
    <hr>
    <h4 style=margin-top:3px;margin-bottom:3px;max-width:70vw;>
      Score "strikes" on these metrics:
    </h4>
    <label>
      <input id='scoreHTQToggle' type="checkbox" onchange="togglePref('scoreHTQ')" checked />
      Score HT Quality
    </label><br>
    <label>
      <input id='scoreMetQToggle' type="checkbox" onchange="togglePref('scoreMetQ')" checked />
      Score Metric Quality
    </label><br>
    <label>
      <input id='scoreDynQToggle' type="checkbox" onchange="togglePref('scoreDynQ')" checked />
      Score Dynamic Quality (loudness)
    </label><br>
    <label>
      <input id='scoreLegQToggle' type="checkbox" onchange="togglePref('scoreLegQ')" checked />
      Score Legato Quality
    </label><br>
    <label>
      <input id='scoreStaQToggle' type="checkbox" onchange="togglePref('scoreStaQ')" checked />
      Score Staccato Quality
    </label><br>
    <hr>
    <h4 style=margin-top:3px;margin-bottom:3px;max-width:70vw;>
      Play tones based on run results:
    </h4>
    <label>
      <input id='enableTonesToggle' type="checkbox" onchange="togglePref('enableTones')" checked />
      Enable result tones
    </label><br>
    <label>
      <span style=width:10em;display:inline-block>Tone on Note Fail:</span>
      <select id=toneOnNoteFailMenu onchange="setPref('toneOnNoteFail', this.value)">
        <option value="none">none</option>
        <option value="C2" selected>C2</option>
        <option value="D2">D2</option>
        <option value="E2">E2</option>
        <option value="F2">F2</option>
        <option value="G2">G2</option>
      </select>
    </label><br>
    <label>
      <span style=width:10em;display:inline-block>Tone on QFail:</span>
      <select id=toneOnQFailMenu onchange="setPref('toneOnQFail', this.value)">
        <option value="none">none</option>
        <option value="C2">C2</option>
        <option value="D2">D2</option>
        <option value="E2">E2</option>
        <option value="F2">F2</option>
        <option value="G2" selected>G2</option>
      </select>
    </label><br>
    <label>
      <span style=width:10em;display:inline-block>Tone on Passing:</span>
      <select id=toneOnPassingMenu onchange="setPref('toneOnPassing', this.value)">
        <option value="none">none</option>
        <option value="C5" selected>C5</option>
        <option value="D5">D5</option>
        <option value="E5">E5</option>
        <option value="F5">F5</option>
        <option value="G5">G5</option>
      </select>
    </label><br>
    <label>
      <span style=width:10em;display:inline-block>Tone on Good:</span>
      <select id=toneOnGoodMenu onchange="setPref('toneOnGood', this.value)">
        <option value="none">none</option>
        <option value="C5">C5</option>
        <option value="D5">D5</option>
        <option value="E5" selected>E5</option>
        <option value="F5">F5</option>
        <option value="G5">G5</option>
      </select>
    </label><br>
    <label>
      <span style=width:10em;display:inline-block>Tone on Excellent:</span>
      <select id=toneOnExcellentMenu onchange="setPref('toneOnExcellent', this.value)">
        <option value="none">whole</option>
        <option value="C5">C5+</option>
        <option value="D5">D5+</option>
        <option value="E5">E5+</option>
        <option value="F5">F5+</option>
        <option value="G5" selected>G5+</option>
      </select>
    </label><br>
    <label>
      <span style=width:10em;display:inline-block>Tone Duration:</span>
      <select id=toneDurationMenu onchange="setPref('toneDuration', this.value)">
        <option value="100">100 ms</option>
        <option value="200" selected>200 ms</option>
        <option value="300">300 ms</option>
        <option value="400">400 ms</option>
        <option value="500">500 ms</option>
      </select>
    </label><br>
    <label>
      <span style=width:10em;display:inline-block>Tone Velocity:</span>
      <select id=toneVelocityMenu onchange="setPref('toneVelocity', this.value)">
        <option value="10">10</option>
        <option value="30">30</option>
        <option value="60">60</option>
        <option value="80">80</option>
        <option value="100" selected>100</option>
        <option value="127">127 (max)</option>
      </select>
    </label><br>
  </div>
      <hr>
      <div style=text-align:center><button onclick="showPrefs(false);">DONE</button></div>
  </div>
    <div id=helpDiv style=max-width:80vw;display:none>
    <h2>Explanations:</h2>
    <h3>Top line statistics</h3>
    <dl>
      <dt>REPS</dt><dd>The number of repetitions completed. For a run to count as a valid REP there must be no note errors. A note error is a NoteFail.</dd>
      <dt>NoteFail</dt><dd>The number of runs in which you hit an incorrect note.</dd>
      <dt>QFail</dt><dd>The number of runs where there was a Quality Fail. A Quality Fail doesn't cause
        you to lose the REP. A Quality Fail occurs if you get 3 strikes on quality metrics, which are defined
        below.</dd>
      <dt>BPM</dt><dd>The beats per minute speed of your most recent run that did not have a note fail. This
        assumes each note played is a "beat". So this is really "notes per minute".</dd>
      <dt>Avg, Max, Best</dt><dd>These are the Average BPM, Maximum BPM, and Best BPM, respectively. Best BPM
        is defined as the maximum BPM among runs with no strikes, in other words your highest BPM during a high
        quality run.</dd>
      <dt>AvgHQ, AvgMQ, AvgLQ</dt><dd>These are the average BPM values during High Quality (0 strikes), Medium Quality (1 strike),
        and Low Quality (2 or more strikes) runs. As always, runs with a note failure don't count at all, as they are considered
        totally failed runs for which BPM can't really be measured.</dd>
      </dl>
    <h3>Bottom Line Statistics</h3>
    The second line of stats give quality metrics.
    <dl>
    <dt>HTQ</dt><dd>Hands Together Quality measures what percentage of time your hands struck the corresponding notes
      at the same time. Over 85% is considered high quality.</dd>
    <dt>MetQ</dt><dd>Metric Quality measures how similar the lengths of time of each note is. If every note was played exacty the same amount of time this measure would be 100%.
      If the standard deviation of note durations is bigger than the mean note duration this measure would be 0 percent.
      You can ignore this stat if you are purposefully playing some notes longer than others, for example you are
      playing your scales to a rhythm. The mean and standard deviation are displayed under this stat in a small font in the format: mean&plusmn;sd.</dd>
    <dt>DynQ</dt><dd>Dynamic Quality measures whether each note was played with the same loudness (velocity in midi terms).
      If every note is equally loud this will be 100%. If the standard deviation of loudness is greater than the mean loudness this will be
      zero percent. The mean and standard deviation are displayed under this stat in a small font in the format: mean&plusmn;sd. You can ignore this stat
      if you are purposefully putting a louder beat on certain notes, or if you are purposefully playing one hand loud and the other soft.</dd>
    <dt>LegQ</dt><dd>Legato quality measures how well you are playing Legato (smoothly without breaks). Note that strikes are not assigned to low legato scores since we don't know if you're attempting to play legato or not. If each note (in each hand) starts exactly when the
      last note finishes every single time, this measure will be 100%. A very small overlap is not penalized because some teachers instruct that legato has
      a small overlap. A gap or a larger overlap is penalized. Underneath this stat there is a display of the amount of average gap in milliseconds (when there was a gap), and the amount of average overlap (when there was an overlap).
      If you are purposely playing one hand legato and one hand staccatto you can just bear in mind that this figure would only be 50% at most (i.e. half the notes are perfect legato).</dd>
    <dt>StaQ</dt><dd>Staccato Quality, like Legato Quality, measures how closely you are playing Staccato. It also doesn't cause strikes for the same reason as
      Legato Quality doesn't. A perfect score of 100% would occur if every note has a gap afterwards of at least the duration of the note. We do not attempt to distinguish different kinds of staccatto.</dd>
    </dl>
    <p>Strikes occur on a run with no note failures when one or more quality metrics (not counting LegQ or StaQ) are below certain values.
       Generally, scores of 85 or higher get zero strikes. Scores between 70 and 84 inclusive get 1 strike. Scores between 50 and 69 inclusive get 2 strikes, and scores under 50 get 3 strikes.
       Strikes are added up between the HTQ, MetQ, and DynQ stats. Zero total strikes is considered a "high quality run", one total strike is a "medium quality run" and anything more than 1 strike
       is considered a "quality fail".
    <h3>The Graph</h3>
    <p>The graph only displays data on runs without note fails.</p>
    <p>The graph shows proportional note start/end times as a bar graph, blue for left hand notes and red for right hand.</p>
    <p>The loudness (midi velocity) on a scale of 0 to 100 is displayed in white letters right on the note bars. Also, standard piano abbreviations such as "pp" for pianissimo or "mf" for mezzo forte are printed. However, depending on your exact midi keyboard parameters these may not be accurate, so just consider them approximations.
      Each bar's internal color is also faded the more softly it was played.</p>
    <p>For scales/arpeggios that have fingering data, the finger that was supposed to play the note is displayed underneath the bars.
      The left hand finger is blue and the right hand finger is red.</p>
    <p>On any run with 2 or more quality strikes, the words "Slow Down!" are printed on the graph in a large font.</p>
    <p>A legend in the upper right corner shows the proportional horizontal time scale for 100 milliseconds (1/10 of second). This can give you a feeling for how large gaps/overlaps are between
      played notes, how consistent note durations are, etc.</p>
    <p>Using the graph, you might be able to pick out fingering problems, for example some fingers might be
      holding too long or releasing too quickly in a consistent way. By concentrating on making those fingers
      consistent your quality should increase.</p>
    </div>

  </div>

  <div id="popup-container">
  <div id="popup-form">
    <h2>Scale/Arpeggio Wizard</h2>
    <label for="test-type">Type:</label>
    <select id="test-type">
      <option value="Scale">Scale</option>
      <option value="Arpeggio">Arpeggio</option>
    </select><br>

    <label for="tonic">Tonic:</label>
    <select id="tonic">
      <option value="C">C</option>
      <option value="C#">C#</option>
      <option value="D">D</option>
      <option value="D#">D# / Eb</option>
      <option value="E">E</option>
      <option value="F">F</option>
      <option value="F#">F# / Gb</option>
      <option value="G">G</option>
      <option value="G#">G# / Ab</option>
      <option value="A">A</option>
      <option value="A#">A# / Bb</option>
      <option value="B">B</option>
    </select><br>

    <label for="mode">Mode:</label>
    <select id="mode">
      <option value="maj">Major</option>
      <option value="natMin">Minor</option>
      <option value="harMin">Harmonic Minor</option>
      <option value="melMin">Melodic Minor (Classical)</option>
      <option value="melMinJ">Melodic Minor (Jazz)</option>
      <option value="blues">Pentatonic Blues</option>
      <option value="mixoBlues">Mixo-Blues</option>
      <option value="majPent">Major Pentatonic</option>
      <option value="minPent">Minor Pentatonic</option>
      <option value="dor">Dorian Mode</option>
      <option value="phryg">Phrygian Mode</option>
      <option value="lyd">Lydian Mode</option>
      <option value="mixo">Mixolydian Mode</option>
      <option value="aeo">Aeolian Mode</option>
      <option value="loc">Locrian Mode</option>
    </select><br>

    <label for="octaves">Octaves:</label>
    <select id="octaves">
      <option value="1">1</option>
      <option value="2">2</option>
      <option value="3">3</option>
      <option value="4">4</option>
    </select><br>

    <label for="lh-start-octave">LH Start Octave:</label>
    <select id="lh-start-octave">
      <option value="1">1</option>
      <option value="2">2</option>
      <option value="3" selected>3</option>
      <option value="4">4</option>
    </select><br>

    <button onclick="generateTest()">GENERATE</button>
    <button onclick="dismissForm()">CANCEL</button>
  </div>
</div>

<div id="historyTableContainer" style="display:none;border:1px solid black;background-color:#EEE;width:100vw;height:100vh;position:fixed;top:0;left:0">
<div style=text-align:right;padding:5px;>
      <button onclick="showHistory();">Import/Export History</button>
  <button onclick="document.getElementById('historyTableContainer').style.display='none';" style="margin-bottom:10px;border:2px solid black">Dismiss History</button><div>
  <div id="filtersContainer" style=padding-bottom:10px;text-align:left>
    <label for="dateRangeSelect">Date Range:</label>
    <select id="dateRangeSelect">
        <option value="all">ALL</option>
        <option value="1Month">1 Month</option>
        <option value="3Months">3 Months</option>
        <option value="1Year">1 Year</option>
    </select>

    <label for="testNameHistorySelect">Test Name:</label>
    <select id="testNameHistorySelect">
        <!-- Options for test names will be populated dynamically using JavaScript -->
    </select>

    <label for="handSelect">Hand:</label>
    <select id="handSelect">
        <option value="any">ANY</option>
        <option value="left">Left</option>
        <option value="right">Right</option>
        <option value="both">Both</option>
    </select>
    <button onclick="filterAndDisplayHistory();">FILTER</button>
</div>
    <div style=height:35vh;overflow:auto;font-size:12px;text-align:center;>
      <style>
      .header-overlay {
        position: sticky;
        top: 0;
        background-color: #f0f0f0; /* Set background color for the overlay */
        z-index: 999; /* Higher z-index than the table body but lower than the sticky thead */
        height: 40px; /* Adjust the height to match your table header */
      }
      </style>
    <div class=header-overlay></div>
    <table id="historyTable" border="1" style=height:25vh;overflow:auto;border-collapse:separate;>
        <thead id=sticky-thead style=position:sticky;top:0;background-color:rgb(220,220,220);border:2;z-index:10000>

            <tr style=background-color:rgb(240,240,240);border:2>
                <th rowspan=2>Date</th>
                <th rowspan=2>Name</th>
                <th rowspan=2>Hand</th>
                <th rowspan=2>REPS</th>
                <th rowspan=2>NFail</th>
                <th rowspan=2>Elapsed</th>
                <th rowspan=2>Avg.<br>Strikes</th>
                <th rowspan=2>NNAcc</th>
                <th rowspan=2>ErrMap</th>
                <th rowspan=2>Streak</th>
                <th colspan=8  style=background-color:rgb(240,240,240)>BPM</th>
              </tr>
              <tr style=background-color:rgb(240,240,240);border:'2px solid black'>
                <th style=background-color:rgb(240,240,240) style=background-color:rgb(240,240,240) style=background-color:rgb(240,240,240)>Avg</th>
                <th style=background-color:rgb(240,240,240) style=background-color:rgb(240,240,240)>Max</th>
                <th style=background-color:rgb(240,240,240)>Bst</th>
                <th>HQ</th>
                <th>MQ</th>
                <th>LQ</th>
                <th>FQ</th>
            </tr>
        </thead>
        <tbody id="historyTableBody">
            <!-- Run data will be inserted here -->
        </tbody>
    </table>
  </div>
    <div style=text-align:left><canvas id="historyGraph" style="width:98%;height:50vh;"></canvas></div>
</div>

<!-- History Import/Export screen -->
<div id="importExportContainer" style="z-index:20000;padding:10px;background-color:#DED;border:1px black solid;display:none;position:fixed;top:10px;left:30px;">
    <p style=text-align:left>This is a JSON encoding of your entire practice history. You can back it up by copying this text to a file, email, sms, etc.
      To restore a prior backup, erase the data below, paste in the backup data, then click RESTORE.</p>
      <p style=text-align:left>NOTES:<br>(1) Restoring will erase all prior data, so you might
      want to do a backup first just in case.<br>(2) Practice data is stored between sessions in browser local storage. Clearing your browser history or cache will probably wipe it out, and other
    system issues can also wipe it out, so it's a good idea to make backups of your data often.</p>

    </p>
    <textarea id="importExportTextarea" placeholder="Paste JSON here or copy JSON to export" rows=10 style=scrollY:auto;width:100%></textarea>
    <br>
    <div id="importExportSizeDiv" style=text-align:left;font-weight:bold;></div>
    <button id="copyToClipboardButton" onclick="document.getElementById('importExportTextarea').select();document.execCommand('copy');">Copy To Clipboard</button>
    <button id="restoreButton">Restore</button>
    <button id="eraseButton" onclick="document.getElementById('importExportTextarea').value='';">Erase</button>
    <button id="eraseButton" onclick="document.getElementById('importExportContainer').style.display='none';">Done</button>
</div>

  <script>

    "use strict";

    // global variables. Yeah there are way too many and some day I would restructure
    // so that, for example, statistics about the current run are held in an object.

    // States
    var STATE = {
      SETTING_NOTES: 'SETTING_NOTES',
      TESTING_NOTES: 'TESTING_NOTES',
      WAITING_FOR_BUTTON: 'WAITING_FOR_BUTTON',
      TEST_FLUSHING: 'TEST_FLUSHING'
    };

    const RESTNOTE = -1;  // numerical value for a "rest" or lack of a note

    var currentState = STATE.WAITING_FOR_BUTTON;

    // Variables for note tracking
    var notesToPlay = [[], []];
    var fingersToPlay = null;
    var playedNotes = [[], []];  // lh, rh
    var errorNotes = [[],[]];    // number of errors made at each note position
    var noteStartBeat = [[],[]];
    var durationsToPlay = null;
    var beatsToPlay = [0,0]; // lh, rh number of beats in selected preset.
    var noteScope = null;    // which notes within selected bars are to be tested
    var beatDur = 1/4;
    var beatsPerBar = 4;
    var activeBars = {first:1, last:1000};
    var swingEighths = false; // set to true or 'swung eighths' for jazz scales
    var midiNotes = []; // for replay feature
    var waitNotes = null;  // played notes transfer here while awaiting the final notes to stop playing
    var nnAccuracy = {success:0, fail:0};
    var goodNotes = 0;  // number of good notes just in past run
    var currentErrorNote = null; // tracks hand and index of current error note for logging

    var repCount = 0;
    var successCount = 0;
    var failCount = 0;
    var noteFailCount = 0;
    var softFailCount = 0;
    var startTime = null;
    var testStartTime = null;
    var totalDuration = 0;
    var currentHand = 'right';
    var wrongNotePlayed = false;
    var averageBPM = 0;
    var maxBPM = 0; // highest bpm not worrying about quality (but notes have to all be correct)
    var bestBPM = 0;  // best bpm among high quality runs
    var sumQBPM = [0,0,0,0];
    var numQBPM = [0,0,0,0];
    var noteFilterHigh = -1;
    var noteFilterLow = 1000;
    var flushRight = false;
    var midiOutput = null;
    var priorFailed = false;

    var curStreak = [0,0,0,0]; // indexed by high quality:0, at least medium: 1, at least low: 2
    var maxStreak = [0,0,0,0];

    var canvasLarge = null;    // buffer used for full resolution graph
    var graphMag = 0.5;
    var graphOffset = {x:0, y:0};

    var runHistory = null;
    var curPresetName = "";
    var pedalSymbol = null;
    var keyboardStatus = 'disconnected';
    const meterChoices = ["1/2", "1/4", "1/8", "1/8 S8", "1/16", "1/32"];
    var meter = "1/4";

    // Array of presets
    var presets = [];

    var keyboardOptions = {
      canvasId: 'keyboardCanvas',
      numOctaves: 5,
      startingOctave: 2,
      notesOn: []
    };

    var routines = {
      "Arp C-Am-G-F 2Oct": {

      }
    };

// Global object to store preferences

const preferences = {
  autoFullscreenStart: true,
  autoExitFullscreenStop: true,

  enableTones: true,
  toneOnNoteFail: "C2",
  toneOnQFail: "G2",
  toneOnPassing: "C5",
  toneOnGood: "E5",
  toneOnExcellent: "G5", // also this gets doubled
  toneDuration: "200",  // milliseconds
  toneVelocity: "100", // pretty loud
  toneFailVoice: "11", // vibraphone on most GM128 keyboards
  toneSuccessVoice: "52", // choir on most GM128 keyboards
  noteFilter: 3,
  scoreHTQ: true,
  scoreMetQ: true,
  scoreDynQ: true,
  scoreLegQ: true,
  scoreStaQ: true,
  showKeyboard: true,
  bpmNoteValue: "quarter",
};

function cycleMeter() {
  const md = document.getElementById("meterDiv");

  for (let i = 0; i < meterChoices.length; i++) {
    if (meter === meterChoices[i]) {
      meter = meterChoices[ (i+1)%meterChoices.length];
      md.innerHTML = meter;
      return;
    }
  }
  // didn't find it.
  meter = "1/4";
  md.innerHTML = meter;
}

// Function to show preferences screen
function showPrefs(show) {
  const prefsScreen = document.getElementById("prefsScreen");
  prefsScreen.style.display = show?"block":"none";
}

// Function to close preferences screen
function closePrefs() {
  const prefsScreen = document.getElementById("prefsScreen");
  prefsScreen.style.display = "none";
}

// Function to toggle preference values (boolean)
function togglePref(prefName, forcevalue = null) {

  if (forcevalue !== null) {
    preferences[prefName] = forcevalue;
  } else {
    preferences[prefName] = !preferences[prefName]; // Toggle the boolean value
  }
  //warning("Toggled "+prefName+" now="+preferences[prefName]);

  if (forcevalue === null) {
    localStorage.setItem(prefName, preferences[prefName]); // Save to localStorage
    warning("Saved "+prefName+"="+preferences[prefName]);
  }

  let td = document.getElementById("td"+prefName);
  if (td !== null) {
    td.style.backgroundColor = preferences[prefName]?"white":"lightgray";
    td.style.opacity = preferences[prefName]?"1":"0.3";
    //warning("Toggled pref "+prefName+" to "+td.style.backgroundColor);
  }

  if (forcevalue === null)
    loadPrefs(); // keep it in sync with saved values
}

// Function to set preference values (string) and save to localStorage
function setPref(prefName, value) {
  preferences[prefName] = value;
  localStorage.setItem(prefName, value);
  warning("Set pref "+prefName+"="+value);
}

var summary = null;

// Function to load preferences from localStorage
function loadPrefs() {

  if (typeof localStorage === "undefined" || localStorage === null) {
    warning("No local storage found");
    return;
  } else {
    //warning("Found local storage");
  }
  for (const prefName in preferences) {
    if (localStorage.hasOwnProperty(prefName)) {
      const value = localStorage.getItem(prefName);
      //warning("Loadprefs: found prefname="+prefName+" value="+value);
      if (prefName === 'bpmNoteValue' || prefName.startsWith('tone') || prefName === "noteFilter") {
        // For the menu item, directly set the value as a string
        preferences[prefName] = value;
        // Update the menu display
        const menu = document.getElementById(prefName+'Menu');
        if (menu === null) {
          warning("Could not find menu with name "+prefName+'Menu');
        } else {
          menu.value = value;
        }
      } else {
        // For boolean preferences, convert the stored value to a boolean
        preferences[prefName] = value === 'true';
        // Update the toggle display
        const toggle = document.getElementById(prefName + 'Toggle');
        if (toggle === null) {
          warning("Could not find a toggle named "+prefName+'Toggle');
        } else {
          toggle.checked = preferences[prefName];
        }
      }
    }
  }
  //warning("Completed LoadPrefs");
}


document.addEventListener('DOMContentLoaded', function () {

  setInterval(function() {
    drawPianoKeyboard(keyboardOptions);
  }, 50);
  summary = document.getElementById("runSummary");
  summary.innerHTML="";
  changeSelectedHand('both');

// JavaScript code for restoring
const restoreButton = document.getElementById("restoreButton");

restoreButton.addEventListener("click", function() {
    const importedJSON = importExportTextarea.value;
    try {
        const importedData = JSON.parse(importedJSON);
        // Replace the existing runHistory with importedData
        runHistory = importedData;
        localStorage.setItem("runHistory", JSON.stringify(runHistory));
        alert("Data restored successfully!");

        // take down the history and import screens
        document.getElementById("historyTableContainer").style.display = "none";
        document.getElementById("importExportContainer").style.display = "none";
    } catch (error) {
        alert("Invalid JSON format. Please check and try again.");
    }
  });
});

// Function to handle preset selection

function handlePresetSelection(presetIndex) {
  if (presetIndex >= 0 && presetIndex < presets.length) {
    var selectedPreset = presets[presetIndex];

    curPresetName = avail(presets[presetIndex].name, "Unknown Preset");

    // Update notesToPlay with the selected preset's notes
    notesToPlay = [selectedPreset.leftHand, selectedPreset.rightHand];

    // Auto-select a hand if only one is available

    if (selectedPreset.leftHand === null || selectedPreset.leftHand.length === 0) {
      updateSelectableHands(false, true, false);
      changeSelectedHand('right');
    } else if (selectedPreset.rightHand === null || selectedPreset.rightHand.length === 0) {
      updateSelectableHands(true, false, false);
      changeSelectedHand('left');
    } else {
      updateSelectableHands(true, true, true);
      changeSelectedHand('both');
    }

    fingersToPlay = [];
    fingersToPlay[0] = avail(selectedPreset.leftFingers, null);
    fingersToPlay[1] = avail(selectedPreset.rightFingers, null);

    beatDur = avail(selectedPreset.beatDur, 1/4);

    beatsPerBar = avail(selectedPreset.beatsPerBar, 4);

    durationsToPlay = [];
    durationsToPlay[0] = avail(selectedPreset.leftDur, [beatDur]);
    durationsToPlay[1] = avail(selectedPreset.rightDur, [beatDur]);

    swingEighths = avail(selectedPreset.swingEighths, false);
    console.log("SW8="+swingEighths);

    // compute the number of beats in the left and right hands
    beatsToPlay = [0,0];

    for (let h = 0; h < 2; h++) {
      for (let n = 0; n < notesToPlay[h].length; n++) {
        beatsToPlay[h] += durationsToPlay[h][n%durationsToPlay[h].length]/beatDur;
      }
    }

    document.getElementById("meterDiv").innerHTML = durFrac(beatDur) + (swingEighths?" S8":"");

    updateDisplayedNotesToPlay();

    // this preset has custom metrics settings
    if (isAvail(selectedPreset.metrics)) {
      const mets = ['HTQ', 'MetQ', 'DynQ', 'LegQ', 'StaQ'];
      const custmets = selectedPreset.metrics;

      for (let i = 0; i < mets.length; i++) {
        if (isAvail(custmets[mets[i]])) {
          togglePref('score'+mets[i], custmets[mets[i]]);
          //console.log("Set custom metric:"+mets[i]+"="+custmets[mets[i]]);
        }
      }
    }
  }
  setNoteFilters();
}

// these helper functions make code to test if a value is defined and set to non-null
// cleaner looking.
function avail(item, defaultValue = null) {
  if (typeof item !== 'undefined' && item !== null) {
    return item;
  }
  return defaultValue;
}

// boolean version of avail(), useful for if statements
function isAvail(item) {
  if (typeof item !== 'undefined' && item !== null) {
    return true;
  }
  return false;
}

var maxBar;
var barScope = null;  // which bars should be played? if this is null, all of them.

function updateDisplayedNotesToPlay() {

  maxBar = 0;
  noteStartBeat = [[],[]]; // beat number each note starts on, may be fractional

  for (let h = 0; h < 2; h++) {
    let notepr = "";
    let totbeats = 0;
    for (var i = 0; i < notesToPlay[h].length; i++) {
      if ( (totbeats % beatsPerBar) === 0 ) {
        const barnum = 1+Math.trunc(totbeats/beatsPerBar);
        notepr += "&nbsp;<span id=bar_"+h+"_"+barnum+" onclick='toggleBarScope(event);' style=user-select:none;display:inline-block><sup>"+barnum+"</sup>|&nbsp;";
      }

      noteStartBeat[h][i] = totbeats; // this will be used for HTQ and graph display

      notepr += " <span id=ntp_"+h+"_"+i+" style=display:inline-block>";
      notepr+=prnotenum(notesToPlay[h][i]);
      if (isAvail(fingersToPlay)) {
        if (isAvail(fingersToPlay[h]) && isAvail(fingersToPlay[h][i])) {
            notepr += '<sub>'+fingersToPlay[h][i]+prDur(h,i)+'</sub>';
          }
      }
      totbeats += durationsToPlay[h][i%durationsToPlay[h].length]/beatDur;
      if ( (totbeats % beatsPerBar) === 0 ) {
        notepr += "</span>";
      }
      notepr+="</span>";
      maxBar = Math.max(maxBar, Math.ceil(totbeats/beatsPerBar));
    }
    // add an extra span for errors that happen at the end, after all legit notes are played
    notepr += "<span id=ntp_"+h+"_error style=display:inline-block>&nbsp;&nbsp;&nbsp;</span>";

    document.getElementById("notes"+(h?"RH":"LH")).innerHTML = notepr;
  }

  setTimeout(function() {
    // make bars for L and R the same width
    for (let b = 1; b <= maxBar; b++) {
      const lb = document.getElementById("bar_0_"+b);
      const rb = document.getElementById("bar_1_"+b);
      const lbw = (lb!==null)?parseInt(getComputedStyle(lb).width):0;
      const rbw = (rb!==null)?parseInt(getComputedStyle(rb).width):0;
      const maxw = Math.max(lbw,rbw) + "px";
      console.log("barnum="+b+" maxw="+maxw+" lbw:"+lbw+" rbw:"+rbw+" rb:"+rb+" lb:"+lb);
      if (lb !== null && rb !== null) {
        lb.style.width = maxw;
        rb.style.width = maxw;
      }
    }
  }, 0);
}

function toggleBarScope(event) {

  const [toss,hand,bar] = event.currentTarget.id.split('_');
  //console.log("toggleBarScope clicked. h="+hand+" bar="+bar);

  if (barScope === null) {
    barScope = [];
    for (let b = 0; b < maxBar; b++) {
      barScope[b] = false;
    }
  }

  barScope[bar] = ! barScope[bar];

  // make sure they're contiguous
  let oncount = 0;
  var lowestBar = 100000;
  var highestBar = -1;
  for (let b = 1; b <= maxBar; b++) {
    if (barScope[b]) {
      lowestBar = b;
      break;
    }
  }
  for (let b = maxBar; b > 0; b--) {
    if (barScope[b]) {
      highestBar = b;
      break;
    }
  }
  // fill in all bars between lowest and highest, this will do nothing if no
  // bars are selected. If no bars are selected, then all bars will play. If
  // one or more bars are selected, just those bars will play
  //console.log("Lowbar:"+lowestBar+" highbar:"+highestBar);
  for (let b = lowestBar; b <= highestBar; b++) {
    //console.log("setting bar to true:"+b);
    barScope[b] = true;
  }
  // recolor all the bars to make them reflect reality
  for (let b = 1; b <= maxBar; b++) {
    const barleft = document.getElementById("bar_0_"+b);
    const barright = document.getElementById("bar_1_"+b);
    if (barScope[b]) {
      if (barleft !== null) barleft.style.backgroundColor = "#CCCCFF";
      if (barright !== null) barright.style.backgroundColor = "#CCCCFF";
    } else {
      if (barleft !== null) barleft.style.backgroundColor = "transparent";
      if (barright !== null) barright.style.backgroundColor = "transparent";
    }
  }
  activeBars.first = (lowestBar<maxBar)?lowestBar:1;
  activeBars.last = (highestBar>0)?highestBar:maxBar;

  // recalculate the noteScope
  noteScope = [{first:0,last:0}, {first:0, last:0}];

if (0) {
  var s = "";
  for (let h = 0; h < 2; h++) {
    s += "hand="+h+" startbeats=";
    for (let i = 0; i < noteStartBeat[h].length; i++) {
      s += noteStartBeat[h][i]+" ";
    }
    s += " ";
  }
  console.log(s+" active bars:"+activeBars.first+"-"+activeBars.last);
}

  for (let h = 0; h < 2; h++) {
    for (let i = 0; i < noteStartBeat[h].length; i++) {
      if (noteStartBeat[h][i] === (activeBars.first-1)*beatsPerBar) {
        noteScope[h].first = i;
      } else if (Math.trunc(noteStartBeat[h][i]) < (activeBars.last)*beatsPerBar) {
        noteScope[h].last = i;
      }
    }
  }
  //console.log("Note Scope, Left:"+noteScope[0].first+"-"+noteScope[0].last+" Right:"+noteScope[1].first+"-"+noteScope[1].last);

  event.stopPropagation();
}

// Create presets
console.log("pushing new presets");

const scalemetrics = {HTQ: true, MetQ: true, DynQ: true, LegQ: true, StaQ: false};

const bluesscalemetrics = {HTQ: true, MetQ: true, DynQ: true, LegQ: true, StaQ: false};

const bluesSwungEighths = [[1/8], [1/8], 1/8, true];

presets.push("Scales, Major");
presets.push(generateScalePreset('A', 'maj', 1, 3, null, scalemetrics));
presets.push(generateScalePreset('B', 'maj', 1, 3, null, scalemetrics));
presets.push(generateScalePreset('C', 'maj', 1, 3, null, scalemetrics));
presets.push(generateScalePreset('C', 'maj', 2, 3, null, scalemetrics));
presets.push(generateScalePreset('C#', 'maj', 1, 3, null, scalemetrics));
presets.push(generateScalePreset('D', 'maj', 1, 3, null, scalemetrics));
presets.push(generateScalePreset('E', 'maj', 1, 3, null, scalemetrics));
presets.push(generateScalePreset('F', 'maj', 1, 3, null, scalemetrics));
presets.push(generateScalePreset('F#', 'maj', 1, 3, null, scalemetrics));
presets.push(generateScalePreset('G', 'maj', 1, 3, null, scalemetrics));
presets.push(generateScalePreset('G', 'maj', 2, 3, null, scalemetrics));

presets.push("Scales, Minor");
presets.push(generateScalePreset('A', 'natMin', 1, 3, null, scalemetrics));
presets.push(generateScalePreset('A', 'natMin', 2, 3, null, scalemetrics));
presets.push(generateScalePreset('D', 'natMin', 1, 3, null, scalemetrics));
presets.push(generateScalePreset('E', 'natMin', 1, 3, null, scalemetrics));
presets.push(generateScalePreset('G', 'natMin', 1, 3, null, scalemetrics));
presets.push(generateScalePreset('D', 'melMin', 1, 3, null, scalemetrics));
presets.push(generateScalePreset('E', 'melMin', 1, 3, null, scalemetrics));
presets.push(generateScalePreset('G', 'melMin', 1, 3, null, scalemetrics));

presets.push("Scales, Other");
presets.push(generateScalePreset('C', 'blues', 1, 3, null, bluesscalemetrics, bluesSwungEighths));
presets.push(generateScalePreset('C', 'blues', 2, 3, null, bluesscalemetrics, bluesSwungEighths));
presets.push(generateScalePreset('D', 'chroma', 1, 3, null, scalemetrics));

presets.push("Arpeggios");
presets.push(generateScalePreset('C', 'majArp', 2, 3, null, scalemetrics));
presets.push(generateScalePreset('F', 'majArp', 2, 3, null, scalemetrics));
presets.push(generateScalePreset('G', 'majArp', 2, 3, null, scalemetrics));
presets.push(generateScalePreset('A', 'natMinArp', 2, 3, null, scalemetrics));

presets.push("Octaves");

const octmetrics = {HTQ: false, MetQ: true, DynQ: true, LegQ: false, StaQ: true};
presets.push(generateScalePreset('C', 'maj', 1, 5, "RH Octave C5", octmetrics));
presets.push(generateScalePreset('C', 'maj', 1, 2, "LH Octave C2", octmetrics));
presets.push(generateScalePreset('G', 'maj', 1, 5, "RH Octave G5", octmetrics));
presets.push(generateScalePreset('G', 'maj', 1, 2, "LH Octave G2", octmetrics));

presets.push("Runs");
presets.push({name: 'Pitter-patter', leftHand: [],
  rightHand: [48, 50, 52, 55, 60, 62, 64, 67, 72, 74, 76, 79, 84, 86, 88, 91, 96, 91, 88,
    86, 84, 79, 76, 74, 72, 67, 64, 62, 60, 55, 52, 50, 48, ],
  metrics: {HTQ: false, MetQ: false, DynQ: true, LegQ: false, StaQ: false}
});

presets.push({name: 'FGAmG LH impr pattern',
  leftHand: [
              41, 48, 53, 48, 53, 48, 41, 48, 53, 48, 53, 48, // F
              43, 50, 55, 50, 55, 50, 43, 50, 55, 50, 55, 50, // G
              45, 52, 57, 52, 57, 52, 45, 52, 57, 52, 57, 52, // Am
              43, 50, 55, 50, 55, 50, 43, 50, 55, 50, 55, 50, // G
            ],
  rightHand: [84,83,81,76,74,72]
}
);

presets.push("Song Drills");

presets.push({
  name: 'F&uuml;r Elise A Loop',
  leftDur: [1/16],
  rightHand: [
    76, 75, 76, 75, 76, 71, 74, 72, 69,      60, 64, 69, 71,       64, 68, 71, 72,     64,
    76, 75, 76, 75, 76, 71, 74, 72, 69,       60, 64, 69, 71,       62, 72, 71, 69,
    71, 72, 74, 76,     67, 77, 76, 74,     65, 76, 74, 72,       64, 74, 72, 71
  ],
  leftHand: [
    //-1, -1, -1, -1, -1, -1, -1, -1,
    45, 52, 57,           40, 52, 56, 45, 52, 57,
    45, 52, 57, 40, 52, 56, 45, 52, 57,
    48, 55, 60, 43, 55, 59, 45, 52, 57,
    40, 52, 64, // still need the weird hand crossing part
  ],
  rightDur: [1/16], // not every note is 1/16 but for now this is an approximation since most are

  beatDur: 1/8,

  beatsPerBar: 3,

  targetBPM: 138,

  leftFingers: null,
  rightFingers: null,
  metrics: {HTQ: false, MetQ: false, DynQ: true, LegQ: true, StaQ: false}
});


presets.push({
  name: 'C.S.A B1-4',
  leftHand: [60, 67, 64, 67, 64, 67, 60, 67, //C arp
             62, 69, 65, 69, 65, 69, 62, 69, // Dm arp
             64, 71, 67, 71, 67, 71, 64, 71, // Em arp
            62, 69, 65, 69, 65, 69, 62, 69, // Dm arp
            60
           ],
  leftDur: [1/8],
  rightHand: [76, 86, 84, 76,
              77, 86, 84, 77,
              79, 86, 84, 79,
              77, 86, 84,     84, 83, 81, 83,
              84
            ],
  rightDur: [1/4, 1/4, 1/4, 1/4,
             1/4, 1/4, 1/4, 1/4,
             1/4, 1/4, 1/4, 1/4,
             1/4, 1/4, 1/4,  1/16, 1/16, 1/16, 1/16,
             3/8],
  leftFingers: null,
  rightFingers: null,
  metrics: {HTQ: true, MetQ: false, DynQ: true, LegQ: false, StaQ: false}
});

presets.push({
  name: 'C.S.A B5',
  leftHand: [
             60, 67, 64, 67, 60, 64, 60, 67, // C arp, different pattern
           ],
  leftDur: [1/8],
  rightHand: [
              84,        79,   72,     72  // the 84 is dotted quarter, the 79 is eighth, rest quarter
            ],
  rightDur: [ 3/8,       1/8,  1/4,   1/4
  ],
  beatDur: 1/4,
  leftFingers: null,
  rightFingers: null,
  metrics: {HTQ: false, MetQ: false, DynQ: true, LegQ: true, StaQ: false}
});

presets.push({
  name: 'C.S.A B6',
  leftHand: [
             55, 62, 59, 62,     55, 62, 59, 62, // C arp, different pattern, true alberti
           ],
  leftDur: [1/8],
  rightHand: [
              71,72,71,72,71,72,71,72,  // trilling on B, technically could be more or fewer than this
              71, 71, 69, 71,                            72     // the final 72 (C) is really in bar 7
            ],
  rightDur: [ 1/16,1/16,1/16,1/16,1/16,1/16,1/16,1/16,  // trills should really be faster than this, but for now 2 per LH note is good for learning it
              1/8, 1/8, 1/8, 1/8,                       1/4      // the final 1/4 is really in bar 7
  ],
  beatDur: 1/4,
  leftFingers: null,
  rightFingers: null,
  metrics: {HTQ: false, MetQ: false, DynQ: true, LegQ: true, StaQ: false}
});

presets.push({
  name: 'C.S.A B1-5',
  leftHand: [60, 67, 64, 67, 64, 67, 60, 67, //C arp
             62, 69, 65, 69, 65, 69, 62, 69, // Dm arp
             64, 71, 67, 71, 67, 71, 64, 71, // Em arp
             62, 69, 65, 69, 65, 69, 62, 69, // Dm arp

             60, 67, 64, 67, 60, 64, 60, 67, //C arp, different pattern
           ],
  leftDur: [1/8],
  rightHand: [76, 86, 84, 76,
              77, 86, 84, 77,
              79, 86, 84, 79,
              77, 86, 84, 84, 83, 81, 83, // last four are sixteenths
              84, 79, 72, 72
            ],
  rightDur: [1/4, 1/4, 1/4, 1/4,
             1/4, 1/4, 1/4, 1/4,
             1/4, 1/4, 1/4, 1/4,
             1/4, 1/4, 1/4,  1/16, 1/16, 1/16, 1/16,
             3/8, 1/8, 1/4, 1/4],
  leftFingers: null,
  rightFingers: null,
  metrics: {HTQ: false, MetQ: false, DynQ: true, LegQ: true, StaQ: false}
});

presets.push("Debugging");
presets.push(  // a very simple pattern for debugging the software
  {
    name: 'TEST',
    leftHand: [48, 50, 52, ],
    rightHand: [60, 62, 64, ],
    leftDur: [1/4, 1/8, 1/8],
    rightDur: [1/4, 1/8, 1/8],
    beatDur: 1/4,
    swingEighths: false,
    leftFingers: [5,4,3],
    rightFingers: [1,2,3],
    metrics: {HTQ: false, MetQ: true, DynQ: false, LegQ: false, StaQ: false},
  }
);
handlePresetSelection(presets.length-1); // this default makes it easier for me to test

presets.push(  // a trivial "scale" for debugging the software
  {
    name: 'SC.TEST',
    leftHand: [48, 50, 52, 50, 48],
    rightHand: [60, 62, 64, 62, 60],
    leftFingers: [5,4,3,4,5],
    rightFingers: [1,2,3,2,1],
    leftDur: [1/8],
    rightDur: [1/8],
    beatDur: 1/16,
    swingEighths: true,
    metrics: {HTQ: true, MetQ: true, DynQ: true, LegQ: true, StaQ: true}
  }
);

presets.push({
  name: 'TEST Trills',
  leftHand: [],
  rightHand: [71, 72, 71, 72, 71, 72, 71, 72,    71, 71, 69
            ],
  leftFingers: null,
  rightFingers: null,
  control: ['t'],
  metrics: {HTQ: false, MetQ: false, DynQ: true, LegQ: false, StaQ: false}
});

// Create the preset menu
var presetMenu = document.createElement('select');
presetMenu.style.fontSize = "20px";
presetMenu.style.maxHeight = "90vh";
var defaultOption = document.createElement('option');
defaultOption.value = -1;
defaultOption.text = 'Presets'; // Default menu item
defaultOption.style.fontSize = "18px";
presetMenu.appendChild(defaultOption);

// Add menu options for each preset
presets.forEach(function(preset, index) {
  if (typeof(preset) === "string") {
    // label for grouping presets
   const optgroup = document.createElement('optgroup');
   optgroup.label = preset;
   optgroup.style.fontSize = "16px";
   optgroup.style.color = "blue";
   presetMenu.appendChild(optgroup);
    return;
  }
  var option = document.createElement('option');
  option.value = index;
  option.innerHTML = preset.name;
  option.style.fontSize = "16px";
  presetMenu.appendChild(option);
});

// Event handler for preset menu selection
presetMenu.addEventListener('change', function() {
  var selectedIndex = this.value;
  handlePresetSelection(selectedIndex);
});

// Add the preset menu to the page
var menuContainer = document.getElementById('presetMenuContainer');
menuContainer.appendChild(presetMenu);

function resetPresetMenu() {
  presetMenu.selectedIndex = 0; // Set the selected index to the default option
}

function generateScalePreset(noteName, scaleType, numOctaves, lhOctave,
  name = null, metrics = null, dur = [[1/4],[1/4]]) {

  const scaleIntervals = {
    maj: [0, 2, 4, 5, 7, 9, 11, 12],
    natMin: [0, 2, 3, 5, 7, 8, 10, 12],
    harMin: [0, 2, 3, 5, 7, 8, 11, 12],
    melMin: [0, 2, 3, 5, 7, 9, 11, 12], // we have to hack the fact that descending goes back to natMin
    melMinJ: [0, 2, 3, 5, 7, 9, 11, 12], // Jazz version of melodic minor doesn't change on descending
    chroma: [0,1,2,3,4,5,6,7,8,9,10,11,12],
    mixoBlues: [0, 2, 3, 4, 5, 6, 7, 9, 10, 12],
    majArp: [0,4,7],
    natMinArp: [0,3,7],
    blues: [0,3,5,6,7,10,12],
    dor: [0, 2, 3, 5, 7, 9, 10, 12],
    lyd: [0, 2, 4, 6, 7, 9, 11, 12],
    mixolyd: [0, 2, 4, 5, 7, 9, 10, 12],
    phryg: [0, 1, 3, 5, 7, 8, 10, 12],
    loc: [0, 1, 3, 5, 6, 8, 10, 12],
    aeo: [0, 2, 3, 5, 7, 8, 10, 12],
    majPent: [0, 2, 4, 7, 9, 12],
    minPent: [0, 3, 5, 7, 10, 12],
  };

  const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

  const fingerings = new Object();

  // The "standard" fingering applies to many different scales
  fingerings["C maj"] =
    fingerings["D maj"] =
    fingerings["E maj"] =
    fingerings["G maj"] =
    fingerings["A maj"] =
    fingerings["A natMin"] =
    fingerings["C natMin"] =
    fingerings["G natMin"] =
    fingerings["D natMin"] =
    fingerings["E natMin"] =
    fingerings["A harMin"] =
    fingerings["E harMin"] =
    fingerings["D harMin"] =
    fingerings["C harMin"] =
    fingerings["G harMin"] =
      [
        { start: [5,4,3,2,1], oct: [3,2,1,4,3,2,1], end: [3,2,1] },
        { start: [1,2,3], oct: [1,2,3,4,1,2,3], end: [1,2,3,4,5] }
      ];


  fingerings["B maj"] =
    fingerings["B natMin"] =
    [
      { start: [4,3,2,1], oct: [4,3,2,1,3,2,1], end: [4,3,2,1] },
      { start: [1,2,3], oct: [1,2,3,4,1,2,3], end: [1,2,3,4,5] }
    ];

  fingerings["C mixoBlues"] =
    fingerings["B natMin"] =
    [
      { start: [1,2,3,1,2,3], oct: [1,2,3,1,2,3,1,2,3], end: [1,2,3,4] },
      { start: [3,2,1,3,2,1], oct: [3,2,1,3,2,1,3,2,1], end: [3,2,1,3] }
    ];

    fingerings["C blues"] =
    [
      {start:[1,1,1,1,1,1], oct:[], end:[]},
      { start: [1,3,1,3,1,3], oct:[1,3,1,3,1,3], end:[4] }
    ]

  const label = name?name:`${noteName} ${scaleType} Scale (${numOctaves} Oct)`;

  let fingers = fingerings[noteName+" "+scaleType];
  if (typeof fingers === "undefined") {
    fingers = null;
  }

  const preset = {
    name: label,
    leftHand: [],
    rightHand: [],
    leftFingers: null,
    rightFingers: null,
    metrics: {HTQ: true, MetQ: true, DynQ: true, LegQ: true, StaQ: false}
  };

  if (metrics !== null) {
    preset.metrics = metrics;
  }

  const arpmode = scaleType.includes("Arp");
  //console.log("arpmode="+arpmode);

  if (arpmode) {
    preset.beatsPerBar = 3;
  } else {
    preset.beatsPerBar = 4;
  }

  // Get the index of the starting note in the noteNames array
  const startNoteIndex = noteNames.indexOf(noteName);

  if (typeof scaleIntervals[scaleType] === "undefined" || scaleIntervals[scaleType] === null) {
    warning("No intervals found for scale type="+scaleType);
    return null;
  }

  // Generate the scale notes for the specified number of octaves

  // first, ascending
  for (let octave = lhOctave; octave <= lhOctave + numOctaves - 1; octave++) {
    for (let i = ((arpmode||(octave===lhOctave))?0:1); i < scaleIntervals[scaleType].length; i++) {
      const noteIndex = (startNoteIndex + scaleIntervals[scaleType][i]);
      const noteNumber = (octave+1) * 12 + noteIndex;
      preset.leftHand.push(noteNumber);
      preset.rightHand.push(noteNumber+12);
    }
  }

  if (arpmode) {
    // arpeggios usually play the tonic one beyond the top octave
    const noteIndex = (startNoteIndex + scaleIntervals[scaleType][0]);
    const noteNumber = (lhOctave+numOctaves+1) * 12 + noteIndex;
    preset.leftHand.push(noteNumber);
    preset.rightHand.push(noteNumber+12);
  }

  // then, descending. In arpeggio mode do not include the very last note
  // because arpeggios are typically practiced by 'cycling' which does not
  // repeat the first note after the end note is played

  // Also, if this is a melodic minor scale, descending substitutes the
  // natural minor. If you don't want that, use melMinJ (Jazz version)

  if (scaleType === 'melMin') {
    scaleType = 'natMin';
  }
  for (let octave = lhOctave+numOctaves-1; octave >= lhOctave; octave--) {
    for (let i = scaleIntervals[scaleType].length-(arpmode?1:2); i >= 0; i--) {
      if (arpmode && octave === lhOctave && i === 0) {
        break; // arpeggios "cycle"
      }
      const noteIndex = (startNoteIndex + scaleIntervals[scaleType][i]);
      const noteNumber = (octave+1) * 12 + noteIndex;
      preset.leftHand.push(noteNumber);
      preset.rightHand.push(noteNumber+12);
    }
  }

  if (fingers) {
    preset.leftFingers = [];
    preset.rightFingers = [];

    // ASCENDING

    // start sequences
    for (var i = 0; i < fingers[0].start.length; i++) {
      preset.leftFingers.push(fingers[0].start[i]);
    }
    for (var i = 0; i < fingers[1].start.length; i++) {
      preset.rightFingers.push(fingers[1].start[i]);
    }

    // extra octaves
    for (var oct = numOctaves-1; oct > 0; oct--) {
      for (var i = 0; i < fingers[0].oct.length; i++) {
        preset.leftFingers.push(fingers[0].oct[i]);
      }
      for (var i = 0; i < fingers[1].oct.length; i++) {
        preset.rightFingers.push(fingers[1].oct[i]);
      }
    }

    // end sequences
    for (var i = 0; i < fingers[0].end.length; i++) {
      preset.leftFingers.push(fingers[0].end[i]);
    }
    for (var i = 0; i < fingers[1].end.length; i++) {
      preset.rightFingers.push(fingers[1].end[i]);
    }

    // DESCENDING

    // end sequences
    for (var i = fingers[0].end.length-2; i >= 0; i--) {
      preset.leftFingers.push(fingers[0].end[i]);
    }
    for (var i = fingers[1].end.length-2; i >= 0; i--) {
      preset.rightFingers.push(fingers[1].end[i]);
    }

    // extra octaves
    for (var oct = numOctaves-1; oct > 0; oct--) {
      for (var i = fingers[0].oct.length-1; i >= 0; i--) {
        preset.leftFingers.push(fingers[0].oct[i]);
      }
      for (var i = fingers[1].oct.length-1; i >= 0; i--) {
        preset.rightFingers.push(fingers[1].oct[i]);
      }
    }

    // start sequences
    for (var i = fingers[0].start.length-1; i >= 0; i--) {
      preset.leftFingers.push(fingers[0].start[i]);
    }
    for (var i = fingers[1].start.length-1; i >= 0; i--) {
      preset.rightFingers.push(fingers[1].start[i]);
    }

  }

  if (dur) {
    preset.rightDur = avail(dur[0], [1/4]);
    preset.leftDur = avail(dur[1], [1/4]);
    preset.beatDur = avail(dur[2], 1/4);
    preset.swingEighths = avail(dur[3], false);
  } else {
    // use defaults
    preset.rightDur = [1/4];
    preset.leftDur = [1/4];
    preset.beatDur = 1/4;
    preset.swingEighths = false;
  }

  return preset;
}



    // Function to set the notes to be played
    function setNotes() {
      currentState = STATE.SETTING_NOTES;
      console.log("State: setting notes");
      notesToPlay = [[], []]; // reset
      fingersToPlay = null;

      //document.getElementById("testname").textContent = "Custom Notes";

      resetPresetMenu();

      updateSelectableHands(true, true, false);
      changeSelectedHand('right');

      // Prompt the user to play notes
      message('Play notes for later test');

      // Disable setNotes button and enable doneButton
      document.getElementById('setNotesButton').disabled = true;
      document.getElementById('testNotesButton').disabled = true;
      document.getElementById('doneButton').disabled = false;

      // Clear the notesToPlay on gameScreen
      clearNotesToPlay();

      // Clear the displayed played notes to start new test
      clearPlayedNotes();

      // Reset the wrongNotePlayed flag
      wrongNotePlayed = false;
      currentHand = 'left';
    }

    // Function to test the notes repetition
    function testNotes() {
      var button = document.getElementById('testNotesButton');
      document.body.style.backgroundColor = "white";

      if (currentState === STATE.TESTING_NOTES || currentState === STATE.TEST_FLUSHING) {
        currentState = STATE.WAITING_FOR_BUTTON;

        // This is really the STOP button, end the test.

        // Enable setNotes button and disable doneButton
        document.getElementById('setNotesButton').disabled = false;
        document.getElementById('doneButton').disabled = true;
        endTest(); // stop the timer
        button.textContent = "START";
        scrollToDataTop(false);
        clearPlayedNotes();

        if (preferences.autoExitFullscreenStop) {
          exitFullscreen();
        }
        return;
      }

      // if we get here we need to start a test sequence.
      clearStats();
      setNoteFilters();

      if (notesToPlay[0].length === 0 && notesToPlay[1].length === 0) {
        message("There are no notes to test, use the SET NOTES button first");
        return;
      }
      currentState = STATE.TESTING_NOTES;
      console.log("State: testing");

      // Disable the "Test Notes" button

      button.textContent = "STOP";
      document.getElementById('setNotesButton').disabled = true;
      // enable both hands mode
      updateSelectableHands(true, true, true);

      // Clear the displayed played notes during the test phase
      clearPlayedNotes();

      startTest();

      scrollToDataTop(true);

      if (preferences['autoFullscreenStart']) {
        console.log("Full Screen auto on start");
          setTimeout(function() {fullscreen(true);}, 300);
      }
    }

    function logOneRun(elapsed, notefail, strikes, bpm) {
      const runName = todayDate() + "|" + curPresetName + "|" + getSelectedHand();

      if (runHistory === null) {
        // hasn't been read yet
        runHistory = localStorage.getItem("runHistory");

        if (runHistory === null) {
          runHistory = {};
        } else {
          // Parse 'runHistory' from JSON if it exists
          runHistory = JSON.parse(runHistory);
        }
      }
      if (typeof runHistory[runName] === "undefined") {
        runHistory[runName] = {};
        runHistory[runName].count = 0;
        runHistory[runName].elapsed = 0;
        runHistory[runName].sumBPM = 0;
        runHistory[runName].notefail = 0;
        runHistory[runName].success = 0;
        runHistory[runName].maxBPM = 0;
        runHistory[runName].bestBPM = 0;
        runHistory[runName].sumStrikes = 0;
        runHistory[runName].maxStreak = [0,0,0,0];
        runHistory[runName].goodNotes = 0;
      }

      if (!isAvail(runHistory[runName].maxStreak)) {
        runHistory[runName].maxStreak = [0,0,0,0];
      }
      for (let q = 0; q < 4; q++) {
        if (maxStreak[q] > runHistory[runName].maxStreak[q]) {
          runHistory[runName].maxStreak[q] = maxStreak[q];
        }
      }

      if (!isAvail(runHistory[runName].numQBPM)) {
          runHistory[runName].numQBPM = [];
      }
      if (!isAvail(runHistory[runName].sumQBPM)) {
        runHistory[runName].sumQBPM = [];
      }
      runHistory[runName].count++;
      runHistory[runName].elapsed += elapsed;

      if (!isAvail(runHistory[runName].goodNotes)) {
        runHistory[runName].goodNotes = 0;
      }
      runHistory[runName].goodNotes += goodNotes;
      goodNotes = 0; // this is a global right now
      if (notefail) {
        runHistory[runName].notefail++;

        if (!isAvail(runHistory[runName].errorNotes)) {
          runHistory[runName].errorNotes = [[],[]];
        }
        if (!isAvail(runHistory[runName].errorNotes[currentErrorNote.hand][currentErrorNote.noteIndex])) {
          runHistory[runName].errorNotes[currentErrorNote.hand][currentErrorNote.noteIndex] = 0;
        }
        runHistory[runName].errorNotes[currentErrorNote.hand][currentErrorNote.noteIndex]++;
      } else {
        runHistory[runName].success++;
        runHistory[runName].sumStrikes += strikes;
        runHistory[runName].sumBPM += bpm;
        if (bpm > runHistory[runName].maxBPM) {
          runHistory[runName].maxBPM = bpm;
        }
        if (strikes === 0 && bpm > runHistory[runName].bestBPM) {
          runHistory[runName].bestBPM = bpm;
        }
        if (!runHistory[runName].numQBPM[strikes]) {
          runHistory[runName].numQBPM[strikes] = 0;
          runHistory[runName].sumQBPM[strikes] = 0;
        }

        runHistory[runName].numQBPM[strikes] += 1;
        runHistory[runName].sumQBPM[strikes] += bpm;
      }

      localStorage.setItem("runHistory", JSON.stringify(runHistory));
    }

    function displayStreaks() {
      // for now hard code passing quality, but this should be a preference
      document.getElementById("curStreakDiv").innerHTML =
        "Streak:<br><span class=bigstat>"+curStreak[2]+"</span><br><span style=font-size:small>Cur</span>";
      document.getElementById("maxStreakDiv").innerHTML =
        "<br><span class=bigstat>"+maxStreak[2]+"</span><br><span style=font-size:small>Max</span>";
    }

    // get the current date in yyyy-mm-dd format
    function todayDate() {
      const currentDate = new Date();
      const year = currentDate.getFullYear();
      const month = String(currentDate.getMonth() + 1).padStart(2, '0'); // Month is zero-based, so we add 1 and pad with '0' if needed.
      const day = String(currentDate.getDate()).padStart(2, '0');

      return `${year}-${month}-${day}`;
    }

    // Function to handle the "Done" button click
    function done() {
      if (currentState === STATE.SETTING_NOTES) {
        currentState = STATE.WAITING_FOR_BUTTON;

        // Enable the "Set Notes" button and disable the "Done" button
        document.getElementById('setNotesButton').disabled = false;
        document.getElementById('testNotesButton').disabled = false;
        document.getElementById('doneButton').disabled = true;

        // create a string to make it easy to create presets
        var preset = "{name: 'new', leftHand: [";
        for (var i = 0; i < notesToPlay[0].length; i++) {
          preset += notesToPlay[0][i] + ", ";
        }
        preset += "], rightHand: [";
        for (var i = 0; i < notesToPlay[1].length; i++) {
          preset += notesToPlay[1][i] + ", ";
        }
        preset += "]};";
        message(preset);
        message("(Copied to clipboard)");
        copyToClipboard(preset);

        if (notesToPlay[0].length && notesToPlay[1].length) {
            changeSelectedHand('both');
        } else if (notesToPlay[0].length) {
            changeSelectedHand('left');
        } else {
            changeSelectedHand('right');
        }

        setNoteFilters();

      }
    }

    document.addEventListener('fullscreenchange', function() {
      document.getElementById("fullscreenButton").textContent = document.fullscreenElement ? "Exit Full" : "Full Screen";
    });

    function exitFullscreen() {
      document.exitFullscreen ? document.exitFullscreen() : document.webkitExitFullscreen();
      document.getElementById("fullscreenButton").textContent = "Full Screen";
    }

    function fullscreen(force=false) {

      if (document.fullscreenElement && !force) {
        // already full screen so exit
        // because we were already full screen we know one of the two apis below are in effect
        document.exitFullscreen ? document.exitFullscreen() : document.webkitExitFullscreen();
        document.getElementById("fullscreenButton").textContent = "Full Screen";
        return;
      }

      // if we get here the browser was not already full screen
      console.log("fullscreen() is going into fullscreen mode");
      // Check if the browser supports the Fullscreen API
      if (document.documentElement.requestFullscreen) {
        // Request full-screen mode on the document element
        document.documentElement.requestFullscreen();
      } else if (document.documentElement.webkitRequestFullscreen) {
        // For older versions of Chrome, use the webkitRequestFullscreen method
        document.documentElement.webkitRequestFullscreen();
      } else {
        // Full-screen API is not supported
        alert('Fullscreen mode is not supported in this browser.');
        return;
      }
      document.getElementById("fullscreenButton").textContent = "Exit Full Screen";
    }

    // Function to display a message in the console
    function message(text) {
      var consoleDiv = document.getElementById('console');
      var messageP = document.createElement('p');
      messageP.textContent = text;
      consoleDiv.appendChild(messageP);
      consoleDiv.scrollTop = consoleDiv.scrollHeight;
    }


    // Function to display a warning message in the console
    function warning(text) {
      var consoleDiv = document.getElementById('console');
      var messageP = document.createElement('p');
      messageP.style.color = 'red';
      messageP.textContent = text;
      consoleDiv.appendChild(messageP);
      consoleDiv.scrollTop = consoleDiv.scrollHeight;
    }

    // Function to display a message in the console
    function messageStats(text) {
      var statsDiv = document.getElementById('statsDiv');
      statsDiv.innerHTML = text;
    }

    function errorStats(error) {
      var statsDiv = document.getElementById('statsDiv');
      var consoleDiv = document.getElementById('console');

      if (error) {
        document.body.style.backgroundColor = "yellow";
      } else {
        document.body.style.backgroundColor = "white";
      }
    }


    const handmodes = ['lh', 'rh', 'ht'];
    const selmodes = {lh:'left', rh:'right', ht:'both'};
    const modesels = {left:'lh', right:'rh', both:'ht'};

    // Function to get the selected hand from the pulldown menu
    function getSelectedHand() {
      const handmodes = ['lh', 'rh', 'ht'];
      const selmodes = {lh:'left', rh:'right', ht:'both'};
      const modesels = {left:'lh', right:'rh', both:'ht'};
      for (const mode of handmodes) {
        if (document.getElementById(mode).classList.contains('selected')) {
          return selmodes[mode];
        }
      }
      return null; // No mode selected
    }

    // Function to change the selected hand in the pulldown menu
    function changeSelectedHand(hand) {
      const handmodes = ['lh', 'rh', 'ht'];
      const selmodes = {lh:'left', rh:'right', ht:'both'};
      const modesels = {left:'lh', right:'rh', both:'ht'};

      handmodes.forEach(m => {
        const modeBox = document.getElementById(m);
        if (m === modesels[hand]) {
          modeBox.classList.add('selected');
        } else {
          modeBox.classList.remove('selected');
        }
      });

      setNoteFilters(); // when hand changes this needs to be updated immediately
    }


    // Function to update the availability of selectable options in the pulldown menu
    function updateSelectableHands(leftAvailable, rightAvailable, bothAvailable) {

      return;  // for now do nothing
      var selHT = document.getElementById('ht');
      var selLH = document.getElementById('lh');
      var selRH = document.getElementById('rh');

      for (var i = 0; i < options.length; i++) {
        var option = options[i];
        var value = option.value;

        if ((value === 'left' && leftAvailable !== null) ||
            (value === 'right' && rightAvailable !== null) ||
            (value === 'both' && bothAvailable !== null)) {
          option.disabled = !(value === 'left' && leftAvailable) &&
                            !(value === 'right' && rightAvailable) &&
                            !(value === 'both' && bothAvailable);
        }
      }

      // Enable the pulldown menu
      handSelect.disabled = false;
    }

    const quarterNote=`<svg xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" version="1.0"
    width="10" height="11" viewBox="0 0 30 50" style=transform:translateY(2px)>  <g transform="translate(-434,-6)" id="g11065"> <path d="M 451.09297,49.38984 C 454.48881,47.56987 456.29825,44.27529 455.18519,41.79688 C 453.99793,39.15324 449.91818,38.40716 446.07861,40.13151 C 442.23905,41.85587 440.08645,45.40091 441.27371,48.04454 C 442.46098,50.68818 446.54072,51.43426 450.38029,49.70991 C 450.62026,49.60214 450.86657,49.51117 451.09297,49.38984 z "  style="opacity:0.9;fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:0.2;stroke-miterlimit:4;stroke-dashoffset:0;stroke-opacity:1" id="path11056" /> <path d="M 454.72547,43.05645 L 454.72547,9.46888" style="fill:none;fill-opacity:0.75;fill-rule:evenodd;stroke:#000000;stroke-width:1.5;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" id="path11058" /> </g> </svg>`;

    const halfNote=`<svg xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" version="1.0"
          x="0.0000000" y="0.0000000" width="12.000000" height="7.0000000" id="svg1361"> <defs id="defs1363" /> <g
          style="fill:#000000;fill-opacity:1.0000000" id="layer1"> <g transform="translate(-199.3990,-536.4730)"
          style="fill:#000000;fill-opacity:1.0000000" id="g2912"> <path
           d="M 206.04921,542.89329 C 204.33221,542.80244 202.99047,541.27833 202.45208,539.70226 C 202.12589,538.77722 202.30505,537.38950 203.39174,537.12966 C 204.96615,536.86226 206.27260,538.19967 207.00481,539.47953 C 207.52641,540.42880 207.81478,541.92368 206.83679,542.67615 C 206.60458,542.83188 206.32387,542.89434 206.04921,542.89329 z M 208.78446,537.49000 C 206.85001,536.31510 204.40641,536.22358 202.28813,536.88110 C 200.94630,537.35025 199.41169,538.34823 199.39900,539.97250 C 199.39807,541.56396 200.87900,542.55675 202.18949,543.02959 C 204.26418,543.70824 206.65796,543.64856 208.59501,542.56669 C 209.69149,541.98333 210.66334,540.77535 210.33379,539.43643 C 210.15258,538.57546 209.49304,537.93123 208.78446,537.49000 z "
           style="fill:#000000;fill-opacity:1.0000000" id="path2918" /> </g> </g> </svg>`;

    const eighthNote=`<div style=width:6px;height:13px;display:inline-block>
<svg xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns="http://www.w3.org/2000/svg" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" id="svg3745" viewBox="0 0 52.13 97.301" version="1.0"
   viewbox="0 0 120 120">
  <g id="layer1" transform="translate(-382.51 -658)">
    <path id="path3743" d="m408.04 658c5.88 14.34 12.3 22.76 16.39 27.42 3.23 3.68 20.94 20.04 0.53 45.61 12.12-25.04 7.76-39.88-13.92-49.03v53c0.68 21.83-21.75 23.16-27.21 17.35-5.65-5.99 7.67-25.89 24.21-19.35v-75z" fill-rule="evenodd"/>
  </g>
  <metadata>
    <rdf:RDF>
      <cc:Work>
        <dc:format>image/svg+xml</dc:format>
        <dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"/>
        <cc:license rdf:resource="http://creativecommons.org/licenses/publicdomain/"/>
        <dc:publisher>
          <cc:Agent rdf:about="http://openclipart.org/">
            <dc:title>Openclipart</dc:title>
          </cc:Agent>
        </dc:publisher>
        <dc:title>Eighth note</dc:title>
        <dc:date>2007-04-10T14:26:55</dc:date>
        <dc:description>Une croche.</dc:description>
        <dc:source>http://openclipart.org/detail/3864/eighth-note-by-corbeau</dc:source>
        <dc:creator>
          <cc:Agent>
            <dc:title>corbeau</dc:title>
          </cc:Agent>
        </dc:creator>
        <dc:subject>
          <rdf:Bag>
            <rdf:li>clip art</rdf:li>
            <rdf:li>clipart</rdf:li>
            <rdf:li>croche</rdf:li>
            <rdf:li>eighth note</rdf:li>
            <rdf:li>image</rdf:li>
            <rdf:li>media</rdf:li>
            <rdf:li>music</rdf:li>
            <rdf:li>music notation</rdf:li>
            <rdf:li>musique</rdf:li>
            <rdf:li>notation musicale</rdf:li>
            <rdf:li>note</rdf:li>
            <rdf:li>public domain</rdf:li>
            <rdf:li>svg</rdf:li>
          </rdf:Bag>
        </dc:subject>
      </cc:Work>
      <cc:License rdf:about="http://creativecommons.org/licenses/publicdomain/">
        <cc:permits rdf:resource="http://creativecommons.org/ns#Reproduction"/>
        <cc:permits rdf:resource="http://creativecommons.org/ns#Distribution"/>
        <cc:permits rdf:resource="http://creativecommons.org/ns#DerivativeWorks"/>
      </cc:License>
    </rdf:RDF>
  </metadata>
</svg></div>`;

  const sixteenthNote=`<svg
   xmlns="http://www.w3.org/2000/svg"
   height="12" width="9" viewBox="10 0 20 150" style=transform:translateY(2px);
   version="1.1"
   id="svg15612" > <g style="stroke:#000000;stroke-width:3" id="g16563">
    <path d="m 50.8,44.75 0,84" id="path16482" />
    <path id="path16524" d="m 115.5,34.25 0,84" />
    <path d="m 181,26.75 0,80" id="path16522" />
    <path id="path16520" d="m 246.2,17.8 0,75" />
  </g>
  <g style="fill:#000000" id="g16590">
    <g id="g3" transform="matrix(0.816,-0.578,0.616,0.788,0,0)">
      <ellipse id="path16453" cx="-55.3" cy="130.4" rx="18.8" ry="12.2" />
      <ellipse
         id="path16453-5"
         cx="3.3"
         cy="157.8"
         rx="18.8"
         ry="12.2" />
      <ellipse
         id="path16453-3"
         cx="63.6"
         cy="184.6"
         rx="18.8"
         ry="12.2" />
      <ellipse
         id="path16453-56"
         cx="122.5"
         cy="212"
         rx="18.8"
         ry="12.2" />
    </g>
      <path
         d="M 247.7,16.5 49.3,42.6 49.3,55.5 247.7,29.3 Z"
         id="path16526" />
      <path
         id="path16530"
         d="M 247.7,37.4 49.3,63.5 49.3,76.4 247.7,50.2 Z" />
  </g>
</svg></div>`;


    var currentBPMNote = quarterNote;

    function displayTestStats(notes, displayType) {
      var alerts = []; // alert structures for graph annotations
      var metmean = 0;

      if (wrongNotePlayed && preferences['enableTones'] && preferences['toneOnNoteFail'] !== 'none') {
        playMIDINote(preferences['toneOnNoteFail'],
          preferences['toneDuration']*2, preferences['toneVelocity'],
          preferences['toneFailVoice']);
      }

      // Increment the repetition count
      repCount++;

      // Calculate average BPM
      var duration = 1;
      var noteCount = 1;
      if (notes !== null && !wrongNotePlayed) {
        let stime = 0;
        let etime = 0;
        const hand = getSelectedHand();

        // make sure beatsToPlay is initialized to something reasonable
        if (!isAvail(beatsToPlay) || !isAvail(beatsToPlay[0]) || !isAvail(beatsToPlay[1])) {
          beatsToPlay = [notesToPlay[0].length, notesToPlay[1].length];
          warning("BEATSTOPLAY WAS NOT INITIALIZED!");
        }

        if (hand === 'both') {
          stime = Math.min(notes[0][0].sTime, notes[1][0].sTime);
          etime = Math.max(notes[0][notes[0].length-1].eTime, notes[1][notes[1].length-1].eTime);
          noteCount = Math.max(beatsToPlay[0], beatsToPlay[1]);
        } else if (hand === 'left') {
          stime = notes[0][0].sTime;
          etime = notes[0][notes[0].length-1].eTime;
          noteCount = beatsToPlay[0];
        } else {
          stime = notes[1][0].sTime;
          etime = notes[1][notes[1].length-1].eTime;
          noteCount = beatsToPlay[1];
        }
        duration = etime - stime;
        totalDuration += duration;
      }

      averageBPM = totalDuration === 0 ? 0 : Math.trunc((noteCount) * successCount / (totalDuration / 60000));
      var currentBPM = 0;
      if (notes !== null && !wrongNotePlayed) { // don't update currentBPM if we're in error state
        currentBPM = Math.trunc((noteCount) / (duration / 60000));
        if (currentBPM >= maxBPM) {
          maxBPM = currentBPM;
        }
      } else {
        currentBPM = 0;
      }

      const s = avail(beatDur, 1/4);
      if (s === 1/2) {
        currentBPMNote = sixteenthNote;
      } else if (s === 1/4) {
        currentBPMNote = quarterNote;
      } else if (s === 1/8) {
        currentBPMNote = eighthNote;
      } else if (s === 1/16) {
        currentBPMNote = sixteenthNote;
      } else {
        currentBPMNote = s; // just use a fraction
      }

      // Print repetition and BPM details
      let stats = "<table><tr style='border-bottom:1px solid black'>";
      stats += '<td style=vertical-align:top;border:none;padding-right:10px>REPS:<br><span class=bigstat style="color:green">' +
        successCount +
        '</span>&nbsp;(' + Math.trunc(100 * successCount / ((successCount + failCount)?(successCount+failCount):1)) + '%) </td>';

      stats += '<td style=vertical-align:top;border:none>NFail<br><span class=smallstat style="color:red">' +
        failCount + '</span></td>';
      stats += '<td style=vertical-align:top;border:none>QFail<br><span class="smallstat" style="color:red">' +
        softFailCount + '</span></td>';

      stats += '<td style=vertical-align:top;border:none;padding-right:10px>BPM:&nbsp;'+currentBPMNote+'<br><span class=bigstat>' +
        (currentBPM?Math.trunc(currentBPM):"&nbsp;") + '</span></td>';
      stats += '<td style=vertical-align:top;border:none;padding-right:10px>Avg:<br><span class=smallstat>' +
        Math.trunc(averageBPM) + "</span></td>";
      stats += '<td style=vertical-align:top;border:none;padding-right:10px>Max:<br><span class=smallstat>' +
        Math.trunc(maxBPM) + "</span></td>";
      stats += '<td style=vertical-align:top;border:none;padding-right:10px;>Best:<br><span class=smallstat>' +
          Math.trunc(bestBPM) + "</span></td>";
      stats += '<td style=vertical-align:top;border:none;padding-right:10px>AvgHQ:<br><span class=smallstat>' +
          (numQBPM[0]?Math.trunc(sumQBPM[0]/numQBPM[0]):0) + "</span> <span style=font-size:small>("+numQBPM[0]+")</span></td>";
      stats += '<td style=vertical-align:top;border:none;padding-right:10px>AvgMQ:<br><span class=smallstat>' +
          (numQBPM[1]?Math.trunc(sumQBPM[1]/numQBPM[1]):0) + "</span> <span style=font-size:small>("+numQBPM[1]+")</span></td>";
      stats += '<td style=vertical-align:top;border:none;padding-right:10px>AvgLQ:<br><span class=smallstat>' +
              ((numQBPM[2])?Math.trunc((sumQBPM[2])/(numQBPM[2])):0) +
              "</span> <span style=font-size:small>("+(numQBPM[2])+")</span></td>";
      stats += '<td style=vertical-align:top;border:none;padding-right:10px>AvgQF:<br><span class=smallstat>' +
              ((numQBPM[3])?Math.trunc((sumQBPM[3])/(numQBPM[3])):0) +
              "</span> <span style=font-size:small>("+(numQBPM[3])+")</span></td>";
              var nonzero = (nnAccuracy.success+nnAccuracy.fail)?0:1;
              if (nonzero === 0 && nnAccuracy.fail === 0) {
                // never give 100% accuracy, if for no other reason that if there are only a small
                // number of runs our estimated accuracy can't be very certain.
                // we will estimate that there is a 0.5/numsuccess probability of error that we just
                // haven't been lucky enough to detect.
                nonzero = 1/(nnAccuracy.success+0.001);
              }
              console.log("NONZERO="+nonzero);
              var displaynacc = (100*(nnAccuracy.success/(nnAccuracy.success+nnAccuracy.fail+nonzero)).toFixed(4)).toFixed(2);
              if (parseFloat(displaynacc) > 99.99) {
                displaynacc = 99.99;
              }
      stats += '<td style=vertical-align:top;border:none;padding-right:10px>NNAcc:<br><span class=smallstat>' +
              displaynacc +
              "</span>&nbsp;<span style=font-size:small>("+nnAccuracy.success+":"+nnAccuracy.fail+")</td>";
      stats += "</tr>";
      // compute quality metrics, hands togetherness
      // but only compute this if testing in hands together mode, and if
      // both sets of notes are the same length

      var strikes = 0; // three strikes gets you a slow down message

      stats += "<tr style='border:none'>";
      if (notes !== null && !wrongNotePlayed && getSelectedHand() === 'both' &&
          notes[0].length === notes[1].length) {

        var together = 0;
        var apart = 0;
        var htStat = new StatTracker();

        for (var i = 0; i < notes[0].length; i++) {
          apart += Math.abs(notes[0][i].sTime - notes[1][i].sTime);
          apart += Math.abs(notes[0][i].eTime - notes[0][i].eTime);

          var overlap = Math.min(notes[0][i].eTime, notes[0][i].eTime)
                - Math.max(notes[0][i].sTime, notes[1][i].sTime);
          htStat.addDataPoint(Math.trunc(100*overlap/(apart+overlap)));

          if (overlap < 0) overlap = 0;
          together += overlap;
        }

        const htqmerit = Math.trunc(100*(together/(together+apart)));
        stats += tdPreferenceDisplay("scoreHTQ", "HTQ", htqmerit, "");

        if (preferences['scoreHTQ']) {
          strikes += strikeScore(htqmerit);
        }

      } else {
        stats += tdPreferenceDisplay("scoreHTQ", "HTQ", 0, "");
      }

      if (notes !== null && !wrongNotePlayed) {
        // Metric quality: were notes played for the correct amount of time?
        // Could track for left and right independently to find trouble spots.

        var metStat = new StatTracker();

        for (var h = 0; h < 2; h++) {
          for (var i = 0; i < notes[h].length; i++) {
            if (notes[h][i].eTime === null) {
              continue; // don't count notes that are not yet released.
            }

            var d = calcDur(h,i);

            var std = avail(beatDur, 1/4);

            const data = (notes[h][i].eTime - notes[h][i].sTime) * (parseFloat(std) / parseFloat(d));

            //console.log("METQ DP:"+data+" d:"+d+" std:"+std+" et:"+notes[h][i].eTime+" st:"+notes[h][i].sTime);


            metStat.addDataPoint(
              data,
              [h,i]
            );
          }
        }
        metmean = metStat.calculateMean();
        const metsd = metStat.calculateStandardDeviation();
        var metmerit = metmean?Math.trunc(100*(1 - (metsd/metmean))):0;
        if (metmerit < 0) metmerit = 0;
        //console.log("Generating MetQ, prefs="+preferences['scoreMetQ']);
        stats += tdPreferenceDisplay('scoreMetQ', "MetQ", metmerit, "(" +
          Math.trunc(metmean)+"&plusmn;"+Math.trunc(metsd)+")");

        metStat.findOutliers("SHORT", "LONG", alerts);

        if (preferences['scoreMetQ']) {
          strikes += strikeScore(metmerit);
        }

        // Dynamic quality: were notes played at approximately the same loudness?
        // Could track this separately for left and right hands as well to see if one is overpowering

        var dynStat = new StatTracker();
        var minVelocity = 1000;
        var maxVelocity = 0;
        var noteMinVelocity = -1;
        var noteMaxVelocity = -1;

        for (var h = 0; h < 2; h++) {
          for (var i = 0; i < notes[h].length; i++) {
            const v = 100*notes[h][i].velocity;
            dynStat.addDataPoint(v, [h,i]);
            if (v > maxVelocity) {
              maxVelocity = v;
              noteMaxVelocity = [h,i];
            }
            if (v < minVelocity) {
              minVelocity = v;
              noteMinVelocity = [h,i];
            }
          }
        }
        const dynmean = dynStat.calculateMean();
        const dynsd = dynStat.calculateStandardDeviation();
        var dynmerit = Math.trunc(100*(1 - (dynsd/dynmean)));
        if (dynmerit < 0) dynmerit = 0;

        if (minVelocity < dynmean*0.6) {
          alerts.push({
            name: "QUIET",
            note: noteMinVelocity
          })
        }

        if (maxVelocity > dynmean*1.4) {
          alerts.push({
            name: "LOUD",
            note: noteMaxVelocity
          })
        }

        if (preferences['scoreDynQ']) {
          strikes += strikeScore(dynmerit);
        }
        stats += tdPreferenceDisplay('scoreDynQ', "DynQ", dynmerit, "("+Math.trunc(dynmean)+"&plusmn;"+Math.trunc(dynsd)+")");

        // Legato quality: were consecutive notes in the same hand played with
        // little or no gap and little or no overlap?
        // Could track this separately for left and right hands as well to see
        // if one is better or worse

        var legSum = 0; // sum of all note durations
        var legError = 0; // sum of end/start gap or overlap errors
        var legNum = 0; // number of data points
        var gap = 0;
        var overlap = 0;
        var numgap = 0;
        var numoverlap = 0;
        var staccattoSum = 0;
        var noteMaxOverlap = -1;
        var maxOverlap = 0;

        for (var h = 0; h < 2; h++) {
          for (var i = 0; i < notes[h].length-1; i++) {
            // we will consider perfect to be 0 gap and 0 overlap, so take the absolute value
            // of the end of first note minus start of the next and accumulate this.
            legNum++;
            const notedur = notes[h][i].eTime - notes[h][i].sTime;
            legSum += notedur;
            let diff = notes[h][i].eTime - notes[h][i+1].sTime;
            if (diff > 0) {
              overlap += diff;
              numoverlap++;
              if (diff > maxOverlap) {
                maxOverlap = diff;
                noteMaxOverlap = [h,i];
              }
              // we allow up to 10% overlap of the second note's duration to
              // not be an error at all.
              // ENHANCEMENT: It might be a good idea to let the user determine
              // this percentage as a preference, because there is disagreement among teachers about
              // how much overlap, if any, is permissible.
              const tenpercent = 0.1*(notes[h][i+1].eTime - notes[h][i+1].sTime);
              diff -= tenpercent; // reduce diff by this amount
              if (diff < 0) diff = 0; // but don't let it go below zero

              // add nothing to staccatto sum because any overlap for staccatto is
              // a fail.

            } else if (diff < 0) {
              gap -= diff;
              numgap++;

              if ((1-diff) > notedur) {
                staccattoSum += 100;
              } else {
                staccattoSum += 100*(-diff/notedur);
              }
            }

            legError += Math.abs(diff);
          }
        }
        var legMerit = legSum?Math.trunc(100 - 100*(legError/legSum)):0;
        if (legMerit < 0) legMerit = 0;

        const avggap = numgap?Math.trunc(gap/numgap):0;
        const avgoverlap = numoverlap?Math.trunc(overlap/numoverlap):0;

        //console.log("maxOverlap="+maxOverlap+" avgoverlap="+avgoverlap+" avgdur="+duration/noteCount);
        if (noteMaxOverlap != -1 && maxOverlap > avgoverlap*2 &&
          maxOverlap > (0.1*(duration/noteCount))) {
            // we will always allow up to 10% of average note duration for overlap
            // because some teachers say that lagato has some overlap
          alerts.push( {
            name: "OVLP "+Math.trunc(100*maxOverlap/avgoverlap)+"%",
            note: noteMaxOverlap
          });
          //console.log("Pushed alert");
        }
        stats += tdPreferenceDisplay('scoreLegQ', "LegQ", legMerit, "(g:" + avggap + " o:" + avgoverlap + ")");

        // staccatto quality
        // staccatto quality will be considered 100% for a note that has a gap after it plays
        // that is greater than the notes duration. if gap is less than that, then quality is 100*gap/duration
        // if this is negative (i.e. overlap) then it's also 0 quality. The average quality of all notes is
        // then computed.
        const stacMerit = legNum?Math.trunc(staccattoSum/legNum):0;

        stats += tdPreferenceDisplay('scoreStaQ', "StaQ", stacMerit, "");

        // if both legQ and staQ are being scored, we will score strikes based
        // on which one is better. This allows the user to turn both metrics on
        // and then practice legatto vs. staccato at will. Presumably they're trying
        // to do one or the other if they have both turned on.

        if (preferences['scoreStaQ'] && preferences['scoreLegQ']) {
          if (stacMerit > legMerit) {
            strikes += strikeScore(stacMerit);
          } else {
            strikes += strikeScore(legMerit);
          }
        } else if (preferences['scoreStaQ']) {
            strikes += strikeScore(stacMerit);
        } else if (preferences['scoreLegQ']) {
            strikes += strikeScore(legMerit);
        }

      } else {
        // no stats due to error
        stats += tdPreferenceDisplay('scoreMetQ', "MetQ", 0, "(na)");
        stats += tdPreferenceDisplay('scoreDynQ', "DynQ", 0, "(na)");
        stats += tdPreferenceDisplay('scoreLegQ', "LegQ", 0, "(na)");
        stats += tdPreferenceDisplay('scoreStaQ', "StaQ", 0, "(na)");
      }

      // draw simple graph of number of runs with hq, mq, lq result.
      stats += "<td style=border:none><div id=curStreakDiv></div></td><td style=border:none><div id=maxStreakDiv></div></td>";
      var totqbpm = numQBPM[0]+numQBPM[1]+numQBPM[2]+numQBPM[3];
      if (totqbpm === 0) totqbpm = 1; // avoid div by 0 errors

      // draw a simple bargraph showing relative number of high, medium, low, qfail runs
      stats += "<td style=border:none><div style=position:relative;width:100%;height:50px;><div style='background-color:green;position:absolute;bottom:0;left:20%;right:20%;height:" +
        100*numQBPM[0]/totqbpm + "%'></div></td>";
      stats += "<td style=border:none><div style=position:relative;width:100%;height:50px;><div style='background-color:blue;position:absolute;bottom:0;left:20%;right:20%;height:" +
        100*numQBPM[1]/totqbpm + "%'></div></td>";
      stats += "<td style=border:none><div style=position:relative;width:100%;height:50px;><div style='background-color:yellow;position:absolute;bottom:0;left:20%;right:20%;height:" +
        100*numQBPM[2]/totqbpm + "%'></div></td>";
      stats += "<td style=border:none><div style=position:relative;width:100%;height:50px;display:block><div style='background-color:red;position:absolute;bottom:0;left:20%;right:20%;height:" +
        100*numQBPM[3]/totqbpm + "%'></div></td>";

      stats += "</tr>";

      if (strikes > 2) { // sloppy play! warn user
        softFailCount++;
        // IMPLEMENT: if preferences say that a softFail is a fail, that logic should be here
        // for example this would cause a soft fail to cancel this as a REP
      }
      stats += "</table>";

      if (strikes > 3) {
        strikes = 3;
      }
      console.log("Final Strikes="+strikes);

      // keep track of high, medium, and low quality runs
      // high quality is 0 strikes, medium is 1 strike, low is
      // 2 or 3 strikes
      if (currentBPM > 0 && !wrongNotePlayed) {
        sumQBPM[strikes] += currentBPM;
        numQBPM[strikes]++;

        if (strikes === 0 && !wrongNotePlayed && currentBPM > bestBPM) {
            bestBPM = currentBPM;
        }
      }

      messageStats(stats);

      // update streaks
      if (displayType !== "reset") { // we don't update streaks if this is just a repaint
        if (!wrongNotePlayed) {
          for (let q = 0; q < strikes; q++) {
            curStreak[q] = 0; // too many strikes for this streak
          }
          for (let q = strikes; q <= 3; q++) {
            // All streaks greater than or equal to strikes are extended.
            // for example if strikes == 1 (medium quality) then both
            // medium and low quality streaks are extended
            curStreak[q]++
            if (curStreak[q] > maxStreak[q]) {
              maxStreak[q] = curStreak[q];
            }
          }
        } else {
          // on notefail, all streaks end
          curStreak = [0,0,0,0];
        }
      }
      displayStreaks();

      if (!wrongNotePlayed) {
        drawNoteBarGraph(notes, strikes, alerts, metmean);
        logOneRun(duration, false, strikes, currentBPM);
      } else {
        logOneRun(0, true, 0, 0);
      }

      function tdPreferenceDisplay(pref, tag, score, details) {
        //console.log("Generating td for pref:/"+pref+"/ val="+preferences[pref]+" tag="+tag+" score="+score+" deets="+details);
        return "<td id=td"+pref+" style='vertical-align:top;border:none;padding-right:15px;" +
        "background-color:" + (preferences[pref]?"white":"rgb(220,220,220)") +
        ";opacity:" + (preferences[pref]?"1":"0.3") + "' " +
        "ontap=\"togglePref('" +pref+ "');\" onclick=\"togglePref('" + pref + "');\" " +
        ">"+ tag +
        ":<br><span class=bigstat style='color:" + colorcode(score) + "'>" + score + "</span>" +
        "<br>"+details+"</td>";
        ;
      }
    }

    function setNoteFilters() {
      let hand = getSelectedHand();

      if (preferences['noteFilter'] === -1) {
        // do not use notefilters
        noteFilterHigh = -1;
        noteFilterLow = 1000;
        return;
      }
      let f = parseInt(preferences['noteFilter']);
      if (hand === 'both') {
        noteFilterHigh = Math.max(...notesToPlay.flat()) + f;
        noteFilterLow = Math.min(...notesToPlay.flat()) - f;
      } else if (hand === 'left') {
        noteFilterHigh = Math.max(...notesToPlay[0]) + f;
        noteFilterLow = Math.min(...notesToPlay[0]) - f;
      } else {
        noteFilterHigh = Math.max(...notesToPlay[1]) + f;
        noteFilterLow = Math.min(...notesToPlay[1]) - f;
      }
    }

    function colorcode(merit) {
      if (merit > 84) {
        return "green";
      } else if (merit > 69) {
        return "orange";
      } else {
        return "red";
      }
    }

    function strikeScore(merit) {
      if (merit > 84) {
        return 0;
      } else if (merit > 69) {
        return 1;
      } else if (merit > 50) {
        return 2;
      } else {
        return 3;
      }
    }

    function StatTracker() {
      // Internal variables
      var data = [];
      var notes = [];
      var sum = 0;
      var squaredSum = 0;

      // Function to reset the statistics
      this.reset = function() {
        data = [];
        sum = 0;
        squaredSum = 0;
        notes = [];
      };

      // Function to add a data point
      this.addDataPoint = function(value, note) {
        data.push(value);
        notes.push(note);
        sum += value;
        squaredSum += value * value;
      };

      // Function to calculate the mean
      this.calculateMean = function() {
        if (data.length === 0) {
          return 0;
        }
        return sum / data.length;
      };

      // Function to calculate the standard deviation
      this.calculateStandardDeviation = function() {
        if (data.length <= 1) {
          return 0;
        }
        var mean = this.calculateMean();
        var variance = squaredSum / data.length - mean * mean;
        return Math.sqrt(variance);
      };

      // Function to find outliers using IQR method
        this.findOutliers = function(messagelow, messagehigh, alerts) {
          if (data.length === 0) {
            return { outliers: [], outlierNotes: [] };
          }

          // Step 1: Create an array of objects containing value and note information
          var dataWithNotes = data.map((value, index) => ({ value, note: notes[index] }));

          // Step 2: Sort the dataWithNotes array based on values in ascending order
          dataWithNotes.sort((a, b) => a.value - b.value);

          // Step 3: Calculate Q1 and Q3
          const q1Index = Math.floor(dataWithNotes.length * 0.25);
          const q3Index = Math.floor(dataWithNotes.length * 0.75);
          const q1 = dataWithNotes[q1Index].value;
          const q3 = dataWithNotes[q3Index].value;

          // Step 4: Calculate IQR
          const iqr = q3 - q1;

          // Step 5: Define lower and upper bounds for outliers
          const lowerBound = q1 - 1.5 * iqr;
          const upperBound = q3 + 1.5 * iqr;

          // Step 6: Identify outliers and their corresponding notes
          const outliers = [];
          const outlierNotes = [];
          dataWithNotes.forEach((dataPoint) => {
            if (dataPoint.value < lowerBound || dataPoint.value > upperBound) {
              outliers.push(dataPoint.value);
              outlierNotes.push(dataPoint.note);
            }
          });

          for (let i = 0; i < outlierNotes.length; i++) {
            alerts.push({
              name: ((outliers[i]<lowerBound) ? messagelow : messagehigh),
              data: outliers[i],
              note: outlierNotes[i]
            })
          }

          return { outliers, outlierNotes };
        };

    }

    function calcDur(h, i) {
      var d = parseFloat(avail(beatDur, 1/4));

      if (isAvail(durationsToPlay) && isAvail(durationsToPlay[h]) && durationsToPlay[h].length > 0) {
        d = parseFloat(durationsToPlay[h][i%durationsToPlay[h].length]); // durations array wraps
      }

      if (swingEighths && d === 1/8) {
        const msg = "Graph SW8 orig="+d;
        if ( (i%2) === 1) {
          // short swung note
          d = d*2/3;
        } else {
          // long swung note
          d = d*4/3;
        }
        //console.log(msg+" adj="+d+" i="+i);
      } else {
        //console.log("Graph NOT SW8. sw8="+swingEighths+" d="+d);
      }
      return parseFloat(d);
    }

    function clearStats() {
      //currentBPM = 0;
      averageBPM = 0;
      maxBPM = 0;
      bestBPM = 0;
      successCount = 0;
      failCount = 0;    // a fail could include soft fails depending on prefs
      softFailCount = 0;
      noteFailCount = 0;
      repCount = 0;
      totalDuration = 0;
      startTime = null;
      wrongNotePlayed = false;
      numQBPM = [0,0,0,0];
      sumQBPM = [0,0,0,0];
      midiNotes = [];
      curStreak = [0,0,0,0];
      maxStreak = [0,0,0,0];
      errorNotes = [[],[]];
      nnAccuracy = {success:0, fail:0};

      displayTestStats(null, "reset");
    }

    var patternCanvas = null;
    var stripePattern = null;

    function createPattern() {
      // Create a pattern for the diagonal stripes
      patternCanvas = document.createElement('canvas');
      var patternCtx = patternCanvas.getContext('2d');
      patternCanvas.width = 10;
      patternCanvas.height = 10;

      patternCtx.clearRect(0, 0, patternCanvas.width, patternCanvas.height);

      patternCtx.strokeStyle = 'white';
      patternCtx.lineWidth = 2;
      patternCtx.beginPath();
      patternCtx.moveTo(0, patternCanvas.height);
      patternCtx.lineTo(patternCanvas.width, 0);
      patternCtx.stroke();
    }

    var priorOptions = null;

    function redrawNoteBarGraph() {
      if (priorOptions !== null) {
        drawNoteBarGraph(priorOptions[0].slice(), priorOptions[1], priorOptions[2].slice(), priorOptions[3]);
      } else {
        console.log("No prior options, not redrawing graph");
      }
    }

    function drawNoteBarGraph(notes, strikes, alerts, metmean) {
      if (notes === null) {
        return;
      }

      priorOptions = [notes.slice(), strikes, (alerts!==null)?alerts.slice():null, metmean];

      midiNotes = []; // we'll fill this in as we traverse the note data

      //console.log("Drawing graph notes="+notes);
      const graphCanvas = document.getElementById('graphCanvas');
      const s = getComputedStyle(graphCanvas);
      graphCanvas.width = parseInt(s.width);
      graphCanvas.height = parseInt(s.height);
      console.log("Graph w="+graphCanvas.width+" h="+graphCanvas.height);

      if (canvasLarge === null) {
        canvasLarge = document.createElement("canvas");
        canvasLarge.width = Math.trunc(parseInt(s.width)*2.2);
        canvasLarge.height = parseInt(s.height)*2;
        canvasLarge.style.display = "none";
        document.body.appendChild(canvasLarge);
      }
      canvasLarge.width = parseInt(s.width)*2;
      canvasLarge.height = parseInt(s.height)*2;

      // reset magnification and offset.
      graphMag = 0.5;
      graphOffset = {x:0, y:0};

      const ctx = canvasLarge.getContext('2d');

      if (patternCanvas === null) {
        createPattern();
        // Create the fill pattern from the patternCanvas
        stripePattern = ctx.createPattern(patternCanvas, 'repeat');
      }

      // Clear the canvas
      ctx.clearRect(0, 0, canvasLarge.width, canvasLarge.height);

      // Define the bar dimensions
      const hand = getSelectedHand();
      var numnotes = 0;
      if (hand === 'both') {
        numnotes = 2*Math.max(notes[0].length,notes[1].length);
      } else if (hand === 'right') {
        numnotes = 2*notes[1].length;
      } else {
        numnotes = 2*notes[0].length;
      }
      const barSpacing = 0;
      const barHeight = Math.trunc(canvasLarge.height/(numnotes+barSpacing));
      const noteSpacing = (2*barHeight+barSpacing);

      // Compute the scaling factor for the horizontal axis
      var lastNote;
      var earlySTime;
      var lateETime;

      if (hand === 'left') {
        lastNote = notes[0].length - 1;
        earlySTime = notes[0][0].sTime;
        lateETime = notes[0][lastNote].eTime;
      } else if (hand === 'right') {
        lastNote = notes[1].length - 1;
        earlySTime = notes[1][0].sTime;
        lateETime = notes[1][lastNote].eTime;
      } else {
        //warning("Graph Finding last note");
        lastNote = Math.max(notes[0].length-1, notes[1].length-1);
        earlySTime = Math.min(notes[1][0].sTime, notes[0][0].sTime);
        lateETime = Math.max(notes[1][notes[1].length-1].eTime, notes[0][notes[0].length-1].eTime);
      }

      const hmargin = 65; // horizontal margin on both left and right.

      const maxDuration = lateETime - earlySTime;
      const scaleFactor = (maxDuration === 0) ? 1 : (canvasLarge.width-2*hmargin) / maxDuration;

      // Draw scale
      const scaleMarkerWidth = 10; // Width of the scale marker line
      const scaleMarkerHeight = 5; // Height of the scale marker line

      ctx.fillStyle = "black";
      ctx.font = "24px Arial";
      let fontHeight = 24;
      ctx.textAlign = "left";
      ctx.textBaseline = "bottom";

      // Calculate the length of the scale marker line
      const scaleMarkerLength = 100 * scaleFactor; // 100ms scaled to the current scaleFactor

      const scaleX = 20; // canvasLarge.width-scaleMarkerLength-40;
      const scaleY = canvasLarge.height/2;
      ctx.fillText("100 ms", scaleX, scaleY-5); // Draw the scale label above the marker

      // Draw the scale marker line
      ctx.beginPath();
      ctx.moveTo(scaleX, scaleY); // Move to the starting position of the scale marker
      ctx.lineTo(scaleX + scaleMarkerLength, scaleY); // Draw the line
      ctx.stroke();

      // Draw the two vertical ticks at the ends of the scale marker line
      ctx.beginPath();
      ctx.moveTo(scaleX, scaleY-5); // Top vertical tick
      ctx.lineTo(scaleX, scaleY+5);
      ctx.moveTo(scaleX + scaleMarkerLength, scaleY-5); // Bottom vertical tick
      ctx.lineTo(scaleX + scaleMarkerLength, scaleY+5);
      ctx.stroke();

      // Draw the note bars
      const barcolors = ["rgba(0,0,255,255)", "rgba(255,0,0,255)"];

      for (let i = 0; i <= lastNote; i++) {
        for (let h = 0; h < 2; h++) {

          //console.log("graphing hand:"+h);
          if ((h === 0 && hand === 'right') || (h === 1 && hand === 'left')) {
            console.log("skipping");
            continue;
          }
          if (notes[h].length <= i) {
            // this hand ran out of notes, sometimes one hand has fewer notes than the other
            // for example when practicing a piece of a song
            continue;
          }
          //console.log("graphing note:"+i);
          const n = notes[h][i];
          const sTime = n.sTime - earlySTime;
          const eTime = n.eTime - earlySTime;
          const w = (eTime - sTime) * scaleFactor;

          // take into account note durations here

          const d = calcDur(h,i);
          const adjmetmean = metmean*d/beatDur;
          const wmean = (metmean*d/beatDur) * scaleFactor;

          // we conveniently have everything we need to set up the midi replay
          // data structure right here. So, although it doesn't have much to do
          // with the graph, go ahead and grab the data.
          //console.log("New note:"+n.note);
          const tt = "+"+(sTime+1000).toString(); // start 1 second after button pressed
          const nn = new Note(n.note.number);
          nn.options = {
            duration:   n.eTime - n.sTime,
            attack:     n.velocity,
            time:       tt
          }

          midiNotes.push(nn);

          // Draw bar
          //console.log("Drawing bar, flushright="+flushRight);
          const x = (!flushRight)?(sTime * scaleFactor+hmargin):40;
          const y = i * noteSpacing + h*(barHeight+barSpacing);

          // Draw rectangular outline with 100% opacity
          ctx.strokeStyle = `rgba(${h === 0 ? 0 : 255}, 0, ${h === 1 ? 0 : 255}, 1)`;
          ctx.strokeRect(x, y, w, barHeight);

          // fill in the rectangle proportional to square of loudness (works better if squared)
          const speed = Math.trunc(100*notes[h][i].velocity);
          // Set opacity based on velocity (loudness)
          ctx.fillStyle = `rgba(${h === 0 ? 0 : 255}, 0, ${h === 1 ? 0 : 255}, ${(speed/100)*(speed/100)})`;

          // Fill the bar with adjusted opacity
          ctx.fillRect(x, y, w, barHeight);

          // Show an outline with dashed lines of
          // the "correct" length of this note given its duration and BPM figures.
          // So the steps are: (1) take the BPM figure computed by stats and then figure out
          // the number of milliseconds that implies for beatDur. Then scale that to the dur of
          // this note. Then draw a dashed rectangle starting where this note started and ending
          // at the "ideal" length figure. Take into account swung eighths too.
          ctx.save();


          // draw different emphasis depending on how close the expected duration was
          // the played duration
          var err = adjmetmean/(eTime - sTime);
          if (err > 1) { // short note
            err = 1/err; // gives us value between 0 and 1 where 1 === perfect
          }

          if (err > 0.9) { // good match
            ctx.strokeStyle = "green";
            ctx.setLineDash([2,4]);
            ctx.lineWidth = 1;
          } else if (err > 0.70) { // not so good
            ctx.strokeStyle = "orange";
            ctx.setLineDash([4,4]);
            ctx.lineWidth = 2;
          } else { // bad
            ctx.strokeStyle = "red";
            ctx.setLineDash([8,4]);
            ctx.lineWidth = 3;
          }

          ctx.fillStyle = "black";

          ctx.strokeRect(x, y, wmean, barHeight);
          //ctx.fillText("m:"+Math.trunc(adjmetmean)+" a:"+Math.trunc(eTime-sTime), x+w+10, y+25);
          ctx.restore();

          // see if there is an alert for this note
          let numalertsfound = 0;
          for (let a = 0; a < alerts.length; a++) {
            //console.log("Alerts["+a+"]="+alerts[a].name+" n="+alerts[a].note);
            if (alerts[a].note && alerts[a].note[0] === h && alerts[a].note[1] === i) {
              // found an alert for this note, highlight it
              //console.log("Found an alert on note:"+alerts[a].note);
              ctx.setLineDash([8,8]);
              ctx.strokeRect(x,y-barHeight*3,w,barHeight*7);
              ctx.textAlign = "right";
              ctx.textBaseline = "bottom";
              ctx.fillStyle = barcolors[h];
              ctx.fillText(alerts[a].name, x+w-2, y-barHeight*(3)-1-numalertsfound*fontHeight);
              ctx.textBaseline = "top";
              ctx.fillText(alerts[a].name, x+w-2, y+barHeight*(4)+1+numalertsfound*fontHeight);

              if (alerts[a].name.startsWith("OVLP")) {
                // draw a vertical line illustrating the overlap
                const nextstart = notes[h][i+1].sTime - earlySTime;
                const x2 = nextstart * scaleFactor;
                ctx.strokeRect(x2,y,w-(x2-x),barHeight*3);
                ctx.setLineDash([]);  // turn of dashes
                ctx.fillStyle = stripePattern;
                ctx.fillRect(x2,y,w-(x2-x),barHeight*3);
              }

              ctx.setLineDash([]);  // turn of dashes

              numalertsfound++;
            }
          }

          if (barHeight < 18) {
            fontHeight = 11;
          } else {
            fontHeight = Math.trunc(barHeight*0.7);
            if (fontHeight > 24) {
              fontHeight = 24;
            }
          }
          ctx.font = "italic " + fontHeight + "px Arial";

          // find finger, if any available
          let finger = "";
          if (isAvail(fingersToPlay) && isAvail(fingersToPlay[h])) {
                if (isAvail(fingersToPlay[h][i])) {
                  finger = "."+fingersToPlay[h][i];
                }
          }

          // find duration, if any available
          var dur = prDur(h, i);

          // draw the note name to left of bar
          ctx.fillStyle = barcolors[h];
          ctx.textAlign = "right";
          ctx.textBaseline = "top";

          ctx.fillText(prnote(notes[h][i].note)+finger+dur, x-3, y);

          // Show velocity
          if (speed < 70) {
            ctx.fillStyle = "black"; // easier to see if low opacity
          } else {
            ctx.fillStyle = "white";
          }

          ctx.textAlign = "left";
          ctx.textBaseline = "bottom";

          var speednotation = "";
          if (speed < 25) {
            speednotation = "ppp";
          } else if (speed < 33) {
            speednotation = "pp";
          } else if (speed < 42) {
            speednotation = "p";
          } else if (speed < 51) {
            speednotation = "mp";
          } else if (speed < 63) {
            speednotation = "mf";
          } else if (speed < 75) {
            speednotation = "f";
          } else if (speed < 88 ) {
            speednotation = "ff";
          } else {
            speednotation = "fff";
          }

          ctx.fillText(" "+speed+" "+speednotation, x, y+barHeight+1);
      }
    }

    if (!flushRight) {
      ctx.font = "90px Arial";
      if (strikes > 2) {
        ctx.fillStyle = "red";
        ctx.textBaseline = "bottom";
        ctx.textAlign = "left";
        ctx.fillText("SLOW DOWN!", 10, canvasLarge.height-60/graphMag);
      } else if (strikes === 2) {
        ctx.fillStyle = "orange";
        ctx.textBaseline = "bottom";
        ctx.textAlign = "left";
        ctx.fillText("PASSING", 10, canvasLarge.height-60/graphMag);
      } else if (strikes === 1) {
        ctx.fillStyle = "blue";
        ctx.textBaseline = "bottom";
        ctx.textAlign = "left";
        ctx.fillText("GOOD", 10, canvasLarge.height-60/graphMag);
      } else {
        ctx.fillStyle = "green";
        ctx.textBaseline = "bottom";
        ctx.textAlign = "left";
        ctx.fillText("EXCELLENT", 10, canvasLarge.height-60/graphMag);
      }
    }

    var delay = 300; // used to schedule various tones out into the future
    if (!wrongNotePlayed && preferences['enableTones']) {
      if (strikes > 2) {
        if (preferences['toneOnQFail'] !== 'none') {
          playMIDINote(preferences['toneOnQFail'],
            preferences['toneDuration'], preferences['toneVelocity'],
            preferences['toneFailVoice']);
            delay = preferences['toneDuration'];
        }
      } else if (strikes === 2) {
        if (preferences['toneOnPassing'] !== 'none') {
          playMIDINote(preferences['toneOnPassing'],
            preferences['toneDuration'], preferences['toneVelocity'],
            preferences['toneSuccessVoice']);
            delay = preferences['toneDuration'];
        }
      } else if (strikes == 1) {
        // play both the passing and good tones one after the other
        if (preferences['toneOnGood'] !== 'none') {
          playMIDINote(preferences['toneOnPassing'],
            preferences['toneDuration'], preferences['toneVelocity'],
            preferences['toneSuccessVoice']);
          setTimeout( function() {
            playMIDINote(preferences['toneOnGood'],
            preferences['toneDuration'], preferences['toneVelocity'],
            preferences['toneSuccessVoice']);
          }, 1.2*preferences['toneDuration']);

          delay = 2.5*preferences['toneDuration'];
        }
      } else {
        // play passing, good, and excellent tones
        if (preferences['toneOnExcellent'] !== 'none') {
          playMIDINote(preferences['toneOnPassing'],
            preferences['toneDuration'], preferences['toneVelocity'],
            preferences['toneSuccessVoice']);
          setTimeout( function() {
            playMIDINote(preferences['toneOnGood'],
              preferences['toneDuration'], preferences['toneVelocity'],
              preferences['toneSuccessVoice']);
          }, 1.2*preferences['toneDuration']);
          setTimeout(function() {
            playMIDINote(preferences['toneOnExcellent'],
              preferences['toneDuration'], preferences['toneVelocity'],
              preferences['toneSuccessVoice']);
          }, 2.4*preferences['toneDuration'])

          delay = 3.5*preferences['toneDuration'];
        }
      }

      // play an indication if reps is a multiple of 10
      if (successCount > 0 && (successCount%10) === 0) {
        var sc = successCount;
        // first a lower tone if multiples of 50
        for (let i = 0; Math.trunc(sc/50) > 0; i++) {
          setTimeout(function() {
              playMIDINote("C6", 120, 127, preferences['toneFailVoice']);
          }, delay + i*200);
          sc -= 50;
          delay += 250;
        }
        for (let i = 0; i < sc/10; i++) {
          setTimeout(function() {
              playMIDINote("C7", 120, 127, preferences['toneFailVoice']);
          }, delay + i*200);
        }
      }
    }
    if (!wrongNotePlayed) {
      graphShow();
    }
  }

  function graphShow() {
    const graphCanvas = document.getElementById('graphCanvas');
    const ctx = graphCanvas.getContext("2d");

    if (canvasLarge === null) {
      return; // no graph yet
    }
    const ctxLarge = canvasLarge.getContext("2d");

    ctxLarge.setLineDash([7,7]);
    ctxLarge.strokeRect(0,0,canvasLarge.width,canvasLarge.height);

    ctx.clearRect(0,0,graphCanvas.width,graphCanvas.height);

    console.log("ShowGraph: cw="+canvasLarge.width+" ch="+canvasLarge.height+" gw="+graphCanvas.width+" gh="+graphCanvas.height);
    ctx.drawImage(canvasLarge, graphOffset.x, graphOffset.y, canvasLarge.width, canvasLarge.height,
                          0, 0, Math.trunc(canvasLarge.width*graphMag), Math.trunc(canvasLarge.height*graphMag));
    ctx.save();
    ctx.setLineDash([2,2]);
    ctx.strokeStyle = "orange";
    ctx.strokeRect(0,0,graphCanvas.width,graphCanvas.height);

    ctx.restore();
  }

  function prDur(h, i) {
    var dur = "";
    if (isAvail(durationsToPlay) && isAvail(durationsToPlay[h])
          && durationsToPlay[h].length > 0) {
        dur = durationsToPlay[h][i%durationsToPlay[h].length];
        if (dur === beatDur) {
          dur = ""; // if dur is default, don't clutter up the screen
        } else {
          dur = durMap(dur);
        }
    }
    return dur;

    function durMap(dur) {
      dur = dur.toString();
      const durmap = { "1":"w", "1.5": "w.",
        "0.5":"h", "0.75":"h.", "0.25":"q", "0.375":"q.",
        "0.125":"e", "0.0625":"s", "0.03125":"t"
      };
      return avail(durmap[dur], dur);
    }
  }

  function durFrac(dur) {
    dur = dur.toString();
    const durmap = { "1":"1/1", "1.5": "1.5/1",
      "0.5":"1/2", "0.75":"3/4", "0.25":"1/4", "0.375":"3/8",
      "0.125":"1/8", "0.0625":"1/16", "0.03125":"1/32"
    };
    return avail(durmap[dur], dur);
  }

  function graphTap(event) {
    const canvas = document.getElementById('graphCanvas');
    const rect = canvas.getBoundingClientRect();
    const tapX = event.clientX - rect.left; // X-coordinate of the tap relative to the canvas
    const tapY = event.clientY - rect.top;

    // Calculate the center of the canvas
    const centerX = canvas.width / 2;
    const oneHalfY = canvas.height / 2;

    // Set flushRight based on the tap position
    if (tapY > oneHalfY) {
          // don't count it close to the top of the canvas because there are other controls there and the user's
          // finger could touch the top of the canvas sometimes.
          flushRight = tapX < centerX;
          redrawNoteBarGraph();
    }
  }

// Attach the graphTap function to the onload event of the window
window.addEventListener('load', function () {

  redirectConsole();

  // Attach event listeners to the canvas for tap and click events
  const canvas = document.getElementById('graphCanvas');
  canvas.addEventListener('mousedown', graphDragStart);
  canvas.addEventListener('mousemove', graphDragMove);
  canvas.addEventListener('mouseup', graphDragEnd);

  canvas.addEventListener('touchstart', graphDragStart);
  canvas.addEventListener('touchmove', graphDragMove);
  canvas.addEventListener('touchend', graphDragEnd);

  //warning("loading prefs");
  loadPrefs();
  //warning("displaying empty results");
  displayTestStats(null, "reset");
  //warning("calling setPedalSymbol");
  setPedalSymbol();

  document.getElementById('pedalSymbolDiv').innerHTML = pedalSymbol?pedalSymbol:"PEDAL";
  setTimeout(function() {
    document.getElementById('pedalSymbolDiv').innerHTML = "";
  }, 2000);

  //showTestGenerateForm();
});

var dragOrigin = null;
var startOffset = null;

function graphDragStart(event) {
  dragOrigin = {x:0,y:0};
  //warning("Event type:"+event.type);
  if (event.type === 'touchstart') {
    dragOrigin.x = event.touches[0].clientX;
    dragOrigin.y = event.touches[0].clientY;
    //warning("Touches:"+ event.touches.length+" x:"+dragOrigin.x+" y:"+dragOrigin.y);
    if (typeof dragOrigin.x === 'undefined') {
      dragOrigin.x = 0;
    }
  } else {
    dragOrigin.x = event.clientX;
    dragOrigin.y = event.clientY;
  }

  if (dragOrigin.x > graphCanvas.width*0.66 || graphMag === 0.5) { // ignore touchstart near the right edge, or if not magnified, so its easier to scroll the window
    dragOrigin = null;
    return;
  }
  event.preventDefault();
  startOffset = {x:0,y:0};
  startOffset.x = graphOffset.x;
  startOffset.y = graphOffset.y;
  //warning("DRAGSTART: offx:"+dragOrigin.x+" offy:"+dragOrigin.y+" gx"+graphOffset.x+" gy:"+graphOffset.y+" cw:"+graphCanvas.width);
}

function graphDragMove(event) {
  if (graphMag === 0.5 || graphOrigin === null) {
    return; // no dragging needed when half magnified because entire graph fits on screen
  }
  //warning("Event type:"+event.type);
  event.preventDefault();
  if (dragOrigin === null) { // there's been no touchstart inside the window
    return;
  }
  var x;
  var y;
  if (event.type === 'touchmove') {
    x = event.touches[0].clientX;
    y = event.touches[0].clientY;
    //warning("Touches:"+ event.touches.length+" x:"+x+" y:"+y);
  } else {
    x = event.clientX;
    y = event.clientY
  }

  graphOffset.x = startOffset.x+dragOrigin.x-x;
  graphOffset.y = startOffset.y+dragOrigin.y-y;
  //warning("DRAG: offx:"+graphOffset.x+" offy:"+graphOffset.y+" x:"+x+" y:"+y+" startx:"+startOffset.x+" starty:"+startOffset.y);
  graphShow();
}

function graphDragEnd(event) {
  event.preventDefault();
  dragOrigin = null;
  startOffset = null;
}

function magnifyScreen(dir) {
  if (dir === -1) {
    graphMag *= 3/4;
  } else {
    graphMag *= 4/3;
  }

  if (graphMag > 2) {
    graphMag = 2;
  } else if (graphMag <= 1/2) {
    graphMag = 1/2;
    graphOffset = {x:0,y:0}; // reset when things get small enough to show entire thing on the screen
  }
  graphShow();
}

function clearPlayedNotes() {
  playedNotes = [[], []];
  wrongNotePlayed = false;

  for (let h = 0; h < 2; h++) {
    for (let i = 0; i <= notesToPlay[h].length; i++) {
      let ntp = null;
      if (i === notesToPlay[h].length) {
        ntp = document.getElementById("ntp_"+h+"_error");
      } else {
        ntp = document.getElementById("ntp_"+h+"_"+i);
      }
      if (ntp !== null) {
        ntp.style.color = "black";
        ntp.style.fontWeight = "normal";
        ntp.style.backgroundColor = "";
      } else {
        console.log("**** NTP is null during RESET");
      }
    }
  }
}


function clearNotesToPlay() {
  notesToPlay = [[], []];
  errorNotes = [[],[]];
  var notesDiv = document.getElementById('notesLH');
  notesDiv.innerHTML = '';
  notesDiv = document.getElementById('notesRH');
  notesDiv.innerHTML = '';
  wrongNotePlayed = false;
  errorStats(wrongNotePlayed);
}

function prnotenum(note) {
  const octave = Math.floor(note / 12) - 1;
  const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

  if (note === -1) {
    return "_"; // rest
  }
  return noteNames[note % 12] + octave;
}

function prnote(note) {
  return prnotenum(note.number);
}

if (typeof WebMidi !== 'undefined' && WebMidi !== null) {
  // Check if Web MIDI is supported
  if (WebMidi.supported) {
    WebMidi.enable(function (err) {
      if (err) {
        console.error('WebMidi could not be enabled:', err);
      } else { // initialize

        WebMidi.addListener("connected", function(event) {
            warning("Connection to MIDI received");
            connectMidi();
        });

        WebMidi.addListener("disconnected", function(event) {
            warning("Lost MIDI connection: "+event.port.id+" "+event.port.manufacturer+" "+event.port.name);
            keyboardStatus = 'disconnected';
        });

        connectMidi();

      } // end of initialize
    }); // end of webmidi.enable
  } else { // end of if webmidi supported
    console.error('Web MIDI is not supported in this browser.');
  }
} else {
  console.error('Web MIDI is null--is not supported in this browser.');
}

function connectMidi() {
  var outputs = WebMidi.outputs;
  if (outputs.length > 0) {
    for (let i = 0; i < outputs.length; i++) {
      message("Output["+i+"]="+outputs[i].type+"/"+outputs[i].manufacturer+"/"+outputs[i].name);
    }
    midiOutput = outputs[0];
    setTimeout(function () {
      playMIDINote("C1", 300, 80, 52);
    },1000);
    setTimeout(function () {
      playMIDINote("C2", 300, 100, 52);
    },1400);
    setTimeout(function () {
      playMIDINote("C3", 300, 127, 52);
    },1800);
  } else {
    warning('No MIDI output devices found.');
  }

  // Retrieve the first available MIDI input device
  var input;
  if (WebMidi.inputs.length > 0) {

    for (let i = 0; i < WebMidi.inputs.length; i++) {
      WebMidi.inputs[i].removeListener(); // remove any prior listeners so we don't get double-listeners
    }
    input = WebMidi.inputs[0];
    message("Connected to WebMidi input port 0:" + WebMidi.inputs[0].name + " " + WebMidi.inputs[0].manufacturer);
    keyboardStatus = 'connected';
  } else {
    warning('No MIDI input devices found. Connect a device then refresh.');
    keyboardStatus = 'disconnected';
    return;
  }

  input.addListener('controlchange', "all", controlChangeHandler, { once: true });

  function controlChangeHandler(event) {
    if (event.controller.name === 'holdpedal') {
      if (event.value) {
        document.getElementById('pedalSymbolDiv').innerHTML = pedalSymbol?pedalSymbol:"PEDAL";
      } else {
        document.getElementById('pedalSymbolDiv').innerHTML = "<div style=width:4em;>&nbsp;</div>";
      }
    }
  }

  input.addListener('noteoff', 'all', noteOffHandler, { once: true });
  input.addListener('noteon', 'all', noteOnHandler, { once: true });

  function noteOffHandler(e) {

    // remove from list of notes showing on mini keyboard canvas
    keyboardOptions.notesOn = keyboardOptions.notesOn.filter((element) => element !== e.note.number);

    if (currentState !== STATE.SETTING_NOTES &&
      (e.note.number > noteFilterHigh || e.note.number < noteFilterLow)) {
      console.log("ignoring note out of range");
      return;
    }
    const all = [waitNotes, playedNotes];  // the ending note could be in either

    for (let d = 0; d < 2; d++) {
      if (d === 0 && all[d] === null) {
        console.log("Waitnotes null, skipping d="+d);
        continue; // waitNotes can be null if processing was previously completed
      }
      for (let hand = 0; hand < 2; hand++) {
        // go backwards since most recent notes are likely the ones that have just finished playing
        //console.log("Finding note in: d="+d+" hand=" + hand);
        for (let n = all[d][hand].length-1; n >= 0; n--) {
            if (all[d][hand][n].note.number === e.note.number && all[d][hand][n].eTime === null) {
              all[d][hand][n].eTime = e.timestamp;
              //console.log("found ending note");
              if (d === 0) {  // if the note was found in the waitNotes array
                // we found the noteoff in the waitNotes array so it might now
                // be complete. see if it has any eTime === null
                for (let h2 = 0; h2 < 2; h2++) {
                  for (let n2 = 0; n2 < waitNotes[h2].length; n2++) {
                    if (waitNotes[h2][n2].eTime === null) {
                      console.log("waitNotes is still incomplete");
                      return; // no we're still waiting for at least 1 note
                    }
                  }
                }

                // if we get here then waitNotes is now full so we can compute stats and
                // clear it out.
                // to avoid blocking here, we spin it off async using a 0 second timeout.
                // to avoid race conditions, we send it a copy of the waitNotes array.

                setTimeout(function() {displayTestStats(waitNotes.slice());}, 0);
              }
              return;
            }
          }
      }
    }
    console.log("Could not find ending note");
    //debugWindow();
  }

  function noteOnHandler(e) {

    console.log("*****NoteOn: "+e.note.number);

    keyboardOptions.notesOn.push(e.note.number);

    // we ignore notes that are significantly out of range
    // of the current hand. This allows you, for example, to accompany
    // a RH scale with a LH chord progression (common when practicing blues scales)

    if (currentState !== STATE.SETTING_NOTES &&
      (e.note.number > noteFilterHigh || e.note.number < noteFilterLow)) {
      console.log("ignoring note out of range");
      return;
    }
    currentHand = getSelectedHand();

    // store stats (used further down in the code)
    const notestruct = {
        note:   e.note,
        velocity: e.velocity,
        sTime:  e.timestamp,
        eTime:  null
    };

    if (currentState === STATE.SETTING_NOTES) {
      var note = e.note.number;
      if (currentHand === 'left') {
        notesToPlay[0].push(note);
        // Display the human-readable note name on the main screen
        var noteName = prnote(e.note);
        var notesDiv = document.getElementById('notesLH');
        notesDiv.textContent = notesDiv.textContent + " " + noteName;
      }
      if (currentHand === 'right' || currentHand === 'both') {
        notesToPlay[1].push(note);
        // Display the human-readable note name on the main screen
        var noteName = prnote(e.note);
        var notesDiv = document.getElementById('notesRH');
        notesDiv.textContent = notesDiv.textContent + " " + noteName;
      }
      updateDisplayedNotesToPlay();

    } else if (currentState === STATE.TESTING_NOTES) {
      console.log("STATE.TESTING_NOTES");

      // Check if the played note matches the expected note
      var playedNote = e.note.number;

      var matchhand = 0;

      if (currentHand === 'left') {
        playedNotes[0].push(notestruct);
      } else if (currentHand === 'right') {
        playedNotes[1].push(notestruct);
        matchhand = 1;
      } else {
        // take a peek and see if it matches expected left hand

        function nextNonRest(notes, start) {
          for (let i = start; i < notes.length; i++) {
            if (notes[i] !== RESTNOTE) {
              return notes[i];
            }
          }
          return null;
        }
        const nextLeft = nextNonRest(notesToPlay[0], playedNotes[0].length); //notesToPlay[0][playedNotes[0].length];
        const nextRight = nextNonRest(notesToPlay[1], playedNotes[1].length); //notesToPlay[1][playedNotes[1].length];
        if (playedNote === nextLeft) {
          playedNotes[0].push(notestruct);
        } else if (playedNote === nextRight){
          playedNotes[1].push(notestruct);
          matchhand = 1;
        } else {
          // it doesn't match either hand. Choose the hand where the played note is
          // closest to the expected note (in terms of midi number of the notes)

          if (Math.abs(playedNote-nextLeft) < Math.abs(playedNote-nextRight)) {
            matchhand = 0;
          } else {
            matchhand = 1;
          }
          console.log("MISS MATCH: pn="+playedNote+" nextLeft="+nextLeft+
            " nextRight="+nextRight+
            " matchhand="+matchhand
          );
          playedNotes[matchhand].push(notestruct);
        }
      }

      const expectedNote = notesToPlay[matchhand][playedNotes[matchhand].length - 1]; // note number

      // if this is the first note for the matching hand, and
      // there is no data in the other hand, then this is the very
      // first note of the new test cycle so start the timer.

      if (playedNotes[matchhand].length === 1 && playedNotes[1-matchhand].length === 0) {
        startTime = performance.now(); // we always start when the first note starts
      }

      console.log("Test: Expected: " + expectedNote + " got: " + playedNote + " start=" + notestruct.sTime);

      console.log("NOTE ANALYSIS: curhand:"+currentHand+" priorFailed:"+priorFailed+
        " played0:"+playedNotes[0].length+" played1:"+playedNotes[1].length+
        " played=expected:"+(playedNote===expectedNote));

      if (playedNote === expectedNote) {
        showNote(e.note, matchhand, playedNotes[matchhand].length - 1, true);
        wrongNotePlayed = false;
        errorStats(wrongNotePlayed);
        nnAccuracy.success++;
        goodNotes++;  // this is the number of good notes just in the current run, it gets reset by logOneRun
        console.log("NN.SUCCESS");
      } else if (
        (currentHand === 'both' && (playedNote === notesToPlay[0][0] || playedNote === notesToPlay[1][0]))
         ||
        (currentHand === 'right' && (playedNote === notesToPlay[1][0]))
          ||
        (currentHand === 'left' && (playedNote === notesToPlay[0][0]))
      ) {
          // FALSE FAIL DETECT #1 (Restart cancels run)
          // This could, rarely, result in a false good run, but it is necessary to
          // avoid false fails. Basically, at any time the user can restart the current run
          // without penalty as long as they haven't hit a wrong note.
          // Without this code, with scales and arpeggios the starting and ending notes
          // of each hand are the same, so if a user hits a wrong note and doesn't notice
          // and continues playing, the ending notes will be falsely detected as the
          // starting note, which will cause failures to stack up even though no mistakes
          // are being made.

          // no credit for notes played if you cancel early!
          const canc = goodNotes - 1; // cancel them all except the one just played
          nnAccuracy.success -= canc; // adjust entire session accuracy figures too
          goodNotes = 1; // just the one just played is now considered good
          console.log("CANCELED GOOD NOTES "+canc+" gn="+goodNotes);

          playedNotes = [[],[]];
          clearPlayedNotes();
          if (playedNote === notesToPlay[0][0]) {
            matchhand = 0;
          } else {
            matchhand = 1;
          }
          playedNotes[matchhand].push(notestruct);
          showNote(e.note, matchhand, 0, true);
          wrongNotePlayed = false;
          startTime = performance.now();
          errorStats(wrongNotePlayed);
      } else if (currentHand === 'both' && priorFailed === true &&
          (playedNotes[0].length+playedNotes[1].length)===2) {
        // FALSE FAIL DETECTION #2
        // ok, this is a missed note that occurred in a very specific situation:
        // 1. we are in hands together mode
        // 2. the prior result was failure, meaning we recently came back into a new run after a fail
        // 3. Exactly one note has been recognized as good so far.
        // 4. We now have a bad note.
        // In this situation, if we count this as a failed run, we will very frequently be causing a
        // false bad run. What can happen (esp with scales/arps) is that the user kept playing after
        // a bad note (which in fact they should get in the habit of doing: keep playing after a mistake)
        // and, for example, the left hand gets up to the tonic note of the right hand, which would cause
        // a new run to start being counted, however as soon as the right hand plays another notes it would
        // be logged as yet another failure. So essentially we are saying that in this situation it would
        // be better to just consider this to be part of the prior failure rather than count it as a new
        // failure. Another way to look at it is that after a fail state, we will require BOTH hands to play
        // one good note before we'll consider a new run to be truly started. As with the code above, this
        // may on occassion fail to count a legit error, but the vast majority of the time this will stop
        // a false failure.
        currentState = STATE.TEST_FLUSHING;
        wrongNotePlayed = true;
        priorFailed = true;
        console.log("***********TEST OF FALSE NEG TRIGGERED");
      } else { // missed the note
        console.log("NFail got:"+prnote(e.note));
        wrongNotePlayed = true;
        nnAccuracy.fail++;
        console.log("NN.FAIL");
        // add one error at note position played.
        const errorindex = playedNotes[matchhand].length-1
        if (!isAvail(errorNotes[matchhand])) {
          errorNotes[matchhand] = [];
        }
        if (!isAvail(errorNotes[matchhand][errorindex])) {
          errorNotes[matchhand][errorindex] = 0;
        }
        currentErrorNote = {hand:matchhand, errorIndex:errorindex}; // needed for logOneRun
        errorNotes[matchhand][errorindex]++;

        showNoteErrors(e.note, matchhand, errorindex, errorNotes[matchhand][errorindex]);
        showNote(e.note, matchhand, errorindex, false);

        errorStats(wrongNotePlayed);
        failCount++; // we do this here, but not again in the flushing state
        noteFailCount++;
        displayTestStats(null, "failure");
        currentState = STATE.TEST_FLUSHING;
        console.log("State=flushing, failcount=" + failCount);
        priorFailed = true;
      }

      // See if we have played the last note required, thus ending this
      // test cycle.
      //warning("Test cycle check. ch="+currentHand+" ntp0len="+notesToPlay[0].length+" ntp1len="+notesToPlay[1].length+" pn0len="+playedNotes[0].length+" pn1len="+playedNotes[1].length)
      if ( (!wrongNotePlayed) &&
        (
          (currentHand === 'right' && notesToPlay[1].length === playedNotes[1].length) ||
          (currentHand === 'left' && notesToPlay[0].length === playedNotes[0].length) ||
          (currentHand === 'both' && notesToPlay[0].length === playedNotes[0].length &&
            notesToPlay[1].length === playedNotes[1].length)
        )
      ) {
        // we've come to the end of a successful test cycle.
        //message("Completed Test Cycle");
        successCount++;
        waitNotes = playedNotes.slice(); // copy of array
        playedNotes = [[], []];
        clearPlayedNotes();
        priorFailed = false;
      }
    } else if (currentState === STATE.TEST_FLUSHING) {
      // continue testing when we see either the first LH or first RH

      var playedNote = e.note.number;

      if (
          ( currentHand === 'right' && playedNote === notesToPlay[1][0] ) ||
          (currentHand === 'left' && playedNote === notesToPlay[0][0]) ||
          (currentHand === 'both' &&
            (playedNote === notesToPlay[0][0] || playedNote === notesToPlay[1][0])
          )
        ) {
        wrongNotePlayed = false;
        clearPlayedNotes();
        if (currentHand === 'left') {
          playedNotes[0].push(notestruct);
          showNote(e.note, 0, playedNotes[0].length-1, true);
        } else if (currentHand === 'right') {
          playedNotes[1].push(notestruct);
          showNote(e.note, 1, playedNotes[1].length-1, true);
        } else if (playedNote === notesToPlay[0][0]) {
          playedNotes[0].push(notestruct);
          showNote(e.note, 0, playedNotes[0].length-1, true);
        } else {
          playedNotes[1].push(notestruct);
          showNote(e.note, 1, playedNotes[1].length-1, true);
        }
        startTime = performance.now();
        //console.log("While Flushing, got start note: going back into state testing");
        currentState = STATE.TESTING_NOTES;
      } else {
        wrongNotePlayed = true;
        currentState = STATE.TEST_FLUSHING;
        //console.log("In state flushing, note still wrong, still flushing failed=" + failCount);
      }
    }
  } // end of noteOnHandler
}

// Function to start the test and initialize the start time
function startTest() {
  testStartTime = Date.now();
  updateElapsedTime(); // Update elapsed time starts a timer to keep it up to date
}

function showNote(note, hand, index, correct) {
  //console.log("Showing note h="+hand+" index="+index+" correct="+correct);
  // Display the played note during the test phase, highlighting in green or red

  if (index >= notesToPlay[hand].length) {
    index = "error";
  }
  const ntp = document.getElementById("ntp_"+hand+"_"+index);
  if (ntp !== null) {
    ntp.style.color = correct?"green":"red";
    ntp.style.fontWeight = "bold";
    ntp.style.backgroundColor = correct?"#98FB98":"#FFCCCB"; // pale green or pale red

    ntp.parentElement.scrollIntoView({behavior:'smooth', block: 'nearest', inline: 'nearest'}, false);
  } else {
    console.log("ShowNote NPT is null");
  }
}

function showNoteErrors(note, hand, index, errors) {
  //console.log("Showing note error for h="+hand+" i="+index+" numerr="+errors);
  if (index >= notesToPlay[hand].length) {
    index = "error"; // we're past the end of the played notes
  }
  const ntp = document.getElementById("ntp_"+hand+"_"+index);
  if (ntp !== null) {
    if (errors === 0) {
      ntp.style.border = "none";
    } else if (errors === 1) {
      ntp.style.border = "1px dotted orange";
    } else if (errors === 2) {
      ntp.style.border = "1px solid orange";
    } else if (errors === 3) {
      ntp.style.border = "2px solid orange";
    } else if (errors === 4) {
      ntp.style.border = "1px solid red";
    } else if (errors === 5) {
      ntp.style.border = "2px solid red";
    }  else if (errors === 6) {
      ntp.style.border = "3px solid red";
    } else if (errors === 7) {
      ntp.style.border = "4px double red";
    } else if (errors > 7) {
      ntp.style.border = "6px double red";
    }
  } else {
    console.error("*NTP IS NULL");
  }
}

function printObject(obj) {
  var p = "";
  for (const key in obj) {
    p += `${key}:`+obj[key]+'\n';
  }
  return p;
}

function replay(notes, hand, speedMultiplier) {
  if (midiOutput === null || notes === null) {
    warning("No MIDI output device available for replay.");
    return;
  }

  var startTime;

  if (hand === 'left') {
    startTime = notes[0][0].sTime;
  } else if (hand === 'right') {
    startTime = notes[1][0].sTime;
  } else {
    startTime = math.Min(notes[0][0].sTime, notes[0][1].sTime);
  }

  for (let i = 0; i < notes.length; i++) {
    if (hand === 'both' || hand === 'left') {

    }
    if (hand === 'both' || hand === 'right') {

    }
  }
}

// Function to play a MIDI note for a specific duration
function playMIDINote(noteNumber, dur, vel, voice) {
  if (midiOutput === null)
    return;

  dur = (typeof dur === 'string') ? parseInt(dur) : dur;
  vel = (typeof vel === 'string') ? parseInt(vel) : vel;
  voice = (typeof voice === 'string') ? parseInt(voice) : voice;

  let n = new Note(noteNumber);
  n.duration = dur;
  n.rawAttack = vel;
  n.rawRelease = 127;

  console.log("Playing note "+noteNumber+" att:"+vel+" dur:"+dur+" voice:"+voice);

  midiOutput.channels[1].sendProgramChange(voice);

  setTimeout(function() {
    midiOutput.channels[1].playNote(n);

    setTimeout(function() { // for some reason automatic noteoff not always working
      midiOutput.channels[1].sendNoteOff(noteNumber);
    }, dur);
  }, 20);
}

// Function to update the elapsed time display
function updateElapsedTime() {
  if (testStartTime) {
    var currentTime = Date.now();
    var elapsedTime = currentTime - testStartTime;
    var elapsedSeconds = Math.floor(elapsedTime / 1000); // Convert milliseconds to seconds

    // Update the element with the elapsed time
    var elapsedTimeElement = document.getElementById('elapsedTime');
    elapsedTimeElement.textContent = formatTime(elapsedSeconds);
    // Schedule the next update in 1 second
    setTimeout(updateElapsedTime, 1000);
  }
}

// Function to format the elapsed time in MM:SS format
function formatTime(seconds) {
  var minutes = Math.floor(seconds / 60);
  var remainingSeconds = Math.trunc(seconds % 60);

  // Pad single-digit seconds with leading zero
  var secondsString = remainingSeconds < 10 ? '0' + remainingSeconds : remainingSeconds;

  return minutes + ':' + secondsString;
}

// Function to end the test and reset the start time
var run = 0;

function endTest() {

  testStartTime = null;
}

// Create an AudioContext instance
var audioContext = new (window.AudioContext || window.webkitAudioContext)();

// Function to generate and play a tone
function playTone(frequency, duration) {
  // Create an OscillatorNode
  var oscillator = audioContext.createOscillator();

  // Set the frequency of the oscillator
  oscillator.frequency.value = frequency;

  // Connect the oscillator to the destination (speakers)
  oscillator.connect(audioContext.destination);

  // Start the oscillator
  oscillator.start();

  // Stop the oscillator after the specified duration
  setTimeout(function() {
    oscillator.stop();
  }, duration);
}

function errorBeep() {
  //playTone(100,250);
}

function chirp() {
  //playTone(2000,50);
}

function debugWindow() {

  var d = "<p>Notes list:";

  for (var hand = 0; hand < 2; hand++) {
    for (var n = 0; n < playedNotes[hand].length; n++) {
      if (playedNotes[hand][n].sTime !== null && playedNotes[hand][n].eTime !== null) {
        //continue; // this note was finished
      }
      d += "H"+hand+"N"+n+
        "(" + prnote(playedNotes[hand][n].note) + ") s=" +
        Math.trunc(playedNotes[hand][n].sTime) + " e="+
        (playedNotes[hand][n].eTime !==null?Math.trunc(playedNotes[hand][n].eTime):"NULL") + "</br>";
    }
  }
  d+="</p>";

  document.getElementById("debugDiv").innerHTML = d;
}



function scrollToDataTop(godata) {

  if (godata) {
    const dataTable = document.getElementById('data');
    if (dataTable) {
      const dataTableRect = dataTable.getBoundingClientRect();
      const dataTableTop = dataTableRect.top + window.scrollY - 3;
      window.scrollTo({
        top: dataTableTop,
        behavior: 'smooth'
      });
    }
  } else {
    const uitop = document.getElementById('uitop');
    if (top) {
      const rect = uitop.getBoundingClientRect();
      const top = rect.top + window.scrollY - 3;
      window.scrollTo({
        top: top,
        behavior: 'smooth'
      });
    }
  }
}

function drawPianoKeyboard(options) {
  const canvas = document.getElementById(options.canvasId);
  const ctx = canvas.getContext('2d');
  const s = getComputedStyle(canvas);
  canvas.width = parseInt(s.width);
  canvas.height = parseInt(s.height);

  const numOctaves = options.numOctaves || 5;
  const startingOctave = options.startingOctave || 1;
  const canvasWidth = canvas.width;
  const canvasHeight = canvas.height;

  const whiteKeyWidth = canvasWidth / (1 + numOctaves * 7); // we will tack on one extra "C" at the end
  const whiteKeyHeight = canvasHeight;
  const blackKeyWidth = whiteKeyWidth * 0.6;
  const blackKeyHeight = whiteKeyHeight * 0.6;

  const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

  ctx.clearRect(0, 0, canvasWidth, canvasHeight);

  if (preferences.showKeyboard === false) {
    return;
  }

  const whiteKeyOffsets = [0,2,4,5,7,9,11]; // offset within an octave of white key numbers

  // Draw white keys
  for (let o = 0; o <= numOctaves; o++) {
    for (let i = 0; i < 7; i++) {
      const x = o * 7 * whiteKeyWidth + i * whiteKeyWidth;
      ctx.fillStyle = 'white';
      ctx.fillRect(x, 0, whiteKeyWidth, whiteKeyHeight);
      ctx.strokeStyle = 'black';
      ctx.strokeRect(x, 0, whiteKeyWidth, whiteKeyHeight);

      // Check if the current note should be highlighted
      const noteNumber = (startingOctave+o+1) * 12 + whiteKeyOffsets[i];

      if (noteNumber === 60) {
        ctx.font = "9px Arial";
        ctx.textAlign = "left";
        ctx.textBaseline = "bottom";
        ctx.fillStyle = "black";
        ctx.fillText("C4", x+1, whiteKeyHeight-2);
      }

      if (options.notesOn && options.notesOn.includes(noteNumber)) {
        ctx.fillStyle = 'blue';
        ctx.fillRect(x+1, 1, whiteKeyWidth-3, whiteKeyHeight-2);
        ctx.fillStyle = 'white';
        ctx.font = "9px Arial";
        ctx.textAlign = "left";
        ctx.textBaseline = "bottom";
        ctx.fillText(prnotenum(noteNumber), x+1, whiteKeyHeight-2)
      }

      if (o === numOctaves) {
        break;  // this is just one more C to end the keyboard.
      }
    }
  }

  // Draw black keys
  ctx.fillStyle = 'black';
  const blackKeyIndices = [1, 2, 4, 5, 6];
  const blackKeyOffsets = [1,3,6,8,10];
  for (let o = 0; o < numOctaves; o++) {
    let keynum = 0;
    for (const keyIndex of blackKeyIndices) {
      const x = o * 7 * whiteKeyWidth + keyIndex * whiteKeyWidth - blackKeyWidth / 2;
      ctx.fillRect(x, 0, blackKeyWidth, blackKeyHeight);
      // Check if the current note should be highlighted
      const noteNumber = (startingOctave+o+1) * 12 + blackKeyOffsets[keynum];
      if (options.notesOn && options.notesOn.includes(noteNumber)) {
        ctx.fillStyle = 'blue';
        ctx.fillRect(x+1, 1, blackKeyWidth-2, blackKeyHeight-2);
        ctx.fillStyle = 'white';
        ctx.textAlign = "left";
        ctx.textBaseline = "bottom";
        ctx.save();
        ctx.translate(x-1,5);
        ctx.rotate(Math.PI/2);
        ctx.font = "10px Arial";
        ctx.fillText(prnotenum(noteNumber), 0, 0);
        ctx.restore();
        ctx.fillStyle = 'black';
      }
      keynum++;
    }
  }

  if (keyboardStatus === 'disconnected') {
    ctx.fillStyle = "rgba(240,240,240,0.8)";
    ctx.fillRect(0,0,keyboardCanvas.width,keyboardCanvas.height);
    ctx.font = "bold "+Math.trunc(whiteKeyHeight)+"px Arial";
    ctx.fillStyle = "red";
    ctx.textBaseline = "bottom";
    ctx.textAlign = "center";
    ctx.fillText("DISCONNECTED", keyboardCanvas.width/2, keyboardCanvas.height+5);
  }
}

function copyToClipboard(text) {
  const textarea = document.createElement('textarea');
  textarea.value = text;
  document.body.appendChild(textarea);
  textarea.select();
  document.execCommand('copy');
  document.body.removeChild(textarea);
}

function setPedalSymbol() {
  //warning("In setPedalSymbol");
pedalSymbol = `<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   version="1.1"
   width="40"
   height="24"
   viewBox="0 0 900 200"
   id="svg2"
   inkscape:version="0.48.2 r9819"
   sodipodi:docname="drawing.svg">
  <sodipodi:namedview
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1"
     objecttolerance="10"
     gridtolerance="10"
     guidetolerance="10"
     inkscape:pageopacity="0"
     inkscape:pageshadow="2"
     inkscape:window-width="1101"
     inkscape:window-height="669"
     id="namedview6"
     showgrid="false"
     inkscape:zoom="1.3382627"
     inkscape:cx="390.07092"
     inkscape:cy="173.04965"
     inkscape:window-x="303"
     inkscape:window-y="114"
     inkscape:window-maximized="0"
     inkscape:current-layer="svg2" />
  <defs
     id="defs4" />
  <metadata
     id="metadata7">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title />
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <path
     d="m 191.83899,376.55107 c -12.08671,-12.08668 0.85681,-32.19829 35.87229,-55.73824 51.89748,-34.88925 54.64344,-50.12343 18.11794,-100.51554 -21.79047,-30.06304 -21.7183,-28.63003 -3.36491,-66.81394 8.95412,-18.6289 17.23297,-37.95588 18.39744,-42.94885 l 2.11722,-9.07813 c -54.76123,2.67437 -97.98801,41.03093 -99.74983,76.73616 0,33.64054 33.87143,32.84904 41.29825,-0.96504 1.52652,-6.95019 2.16313,-10.50169 2.16313,-10.50169 l 13.58161,0.75331 -1.86775,18.09676 c -5.84923,56.67358 -64.07626,75.48118 -81.23961,26.2408 -19.85018,-56.94868 50.38082,-117.417852 131.77015,-121.88431 21.00753,-1.152844 31.70905,1.405987 50.16855,10.81996 55.89177,28.50367 74.834,91.75497 30.77933,106.29432 -22.84358,6.38638 -34.23149,-2.63725 -43.05423,-11.50787 -9.3371,-8.9089 -19.5014,-38.45725 -19.5014,-38.45725 l 16.22818,3.88326 c 0,0 3.66772,7.43221 6.59511,9.86923 9.61774,7.6053 23.50155,4.60482 28.40087,-4.03123 10.2698,-19.18929 -8.47869,-47.29367 -39.22342,-58.79675 -11.00032,-4.11575 -21.14642,-4.8323 -21.14642,-4.8323 0,0 -6.35087,12.25962 -12.58985,28.43785 l -10.3089,26.73189 c 4.08341,13.72735 12.06889,26.72998 19.7047,36.94276 28.28953,37.46923 29.28835,46.52942 9.04546,82.0511 l -14.54283,25.51934 8.76584,2.04482 c 4.82121,1.12463 20.21202,8.14219 34.20178,15.59457 l 25.43594,13.54978 9.22599,-6.9691 c 6.0645,-4.58095 9.0229,-9.64731 8.6333,-14.78477 -3.46502,-45.69179 25.37756,-91.99468 57.30447,-91.99468 40.01014,0 38.52898,42.52258 -2.62404,75.33543 -10.47199,8.34971 -20.54094,18.95418 -20.54094,18.95418 0,0 2.33422,7.42981 6.10101,14.71398 10.57603,20.45176 35.35232,23.50281 54.60423,1.03851 l 9.4438,-11.01961 c -9.35474,-26.22478 12.63978,-69.08124 31.5462,-85.18103 14.3329,-12.21447 23.47727,-18.03898 23.47727,-18.03898 0,0 -5.80525,-9.79565 -16.72564,-21.59097 -20.27501,-21.89944 -50.70582,-39.69563 -83.44038,-48.79664 -15.3592,-4.27025 -22.09683,-7.05824 -22.09683,-7.05824 l 1.50662,-10.37336 12.37926,1.86411 c 94.95257,14.29827 172.00624,80.10498 178.03791,152.05097 6.80939,81.22216 -71.95414,129.83327 -110.88949,68.43857 l -9.18908,-14.48964 -28.90653,21.30362 c -38.14513,28.11231 -48.37446,26.75188 -66.40595,-8.83153 l -8.24935,-16.27936 -26.33286,22.382 c -31.9336,27.14241 -31.29734,27.10035 -41.20479,2.7236 -4.39437,-10.81211 -12.96481,-24.63341 -19.04543,-30.71403 l -11.05567,-11.05567 -20.41072,24.67533 c -24.33352,29.41775 -44.04405,43.35551 -51.197,36.20254 z m 345.58849,-28.3703 c 13.15618,-17.69878 10.8849,-65.04688 -4.87803,-101.68873 l -6.96572,-16.19232 c -22.00421,14.5718 -31.33482,44.5539 -33.8527,64.96717 -5.35104,47.54775 24.22655,81.79688 45.69645,52.91388 z M 407.0928,281.44206 c 14.07123,-15.26548 17.70812,-29.33208 9.66362,-37.37659 -6.61898,-6.61898 -17.99729,-4.22397 -25.50927,4.73667 -7.39513,8.82125 -10.59213,20.48406 -10.37834,30.88883 0.24692,12.01697 4.44217,20.13044 4.44217,20.13044 0,0 12.44089,-8.24563 21.78182,-18.37935 z"
     id="path3067"
     style="fill:#000000"
     inkscape:connector-curvature="0"
     sodipodi:nodetypes="sssssccsccssssccccccscsccscsscsssscsscccssccssscsscssscssssccssssscs" />
  <path
     sodipodi:type="arc"
     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
     id="path2983"
     sodipodi:cx="609.68689"
     sodipodi:cy="357.58929"
     sodipodi:rx="23.340681"
     sodipodi:ry="23.340681"
     d="m 633.02757,357.58929 a 23.340681,23.340681 0 1 1 -46.68136,0 23.340681,23.340681 0 1 1 46.68136,0 z"
     transform="translate(2.551844e-6,-2.1276596)" />
</svg>`;

  if (pedalSymbol === null) {
    warning("PedalSymbol is null");
  }
}

const voiceNumberElement = document.getElementById('voiceNumber');
const incrementButton = document.getElementById('increment');
const decrementButton = document.getElementById('decrement');

let counterValue = 0;

function updateCounterDisplay() {
  if (voiceNumberElement !== null) voiceNumberElement.textContent = counterValue;
}

function incrementCounter() {
  if (counterValue < 100) {
    counterValue++;
    updateCounterDisplay();
  }
}

function decrementCounter() {
  if (counterValue > 1) {
    counterValue--;
    updateCounterDisplay();
  }
}

if (incrementButton !== null) incrementButton.addEventListener('click', incrementCounter);
if (decrementButton !== null) decrementButton.addEventListener('click', decrementCounter);

updateCounterDisplay(); // Initialize the display with the initial value

function playVoice(event) {
  let vn = document.getElementById("voiceNumber");
  let voice = 1;

  if (vn !== null) {
    voice = vn.textContent;
  }

  console.log("Playing voice "+voice);
  playMIDINote("C4", 500, 100, voice);

}

// This makes it easier to debug on tablet devices with no access to the console.
// Since the midi is using the OTG port, it's hard to get debugging info out.
function redirectConsole() {
  // Override the console.log function
  const originalConsoleError = console.error;
  console.error = function (...args) {
    // Call the original console.error function
    originalConsoleError.apply(console, args);

    // Create a new div element to display the message
    warning(args.join(' ')); // Join arguments into a single string
  };
}

function showTestGenerateForm() {
  const popupContainer = document.getElementById('popup-container');
  popupContainer.style.display = 'block';
}

function dismissForm() {
  const popupContainer = document.getElementById('popup-container');
  popupContainer.style.display = 'none';
}

function generateTest() {
  const testType = document.getElementById('test-type').value;
  const tonic = document.getElementById('tonic').value;
  const mode = document.getElementById('mode').value;
  const octaves = document.getElementById('octaves').value;
  const lhStartOctave = document.getElementById('lh-start-octave').value;

  var modename = mode;
  if (testType === 'Arpeggio') {
    modename += "Arp";
  }
  console.log("Modename:"+modename);

  // Call your generateTestNotes function here with the retrieved values
  const tmp = presets.length;

  const p = generateScalePreset(tonic, modename, parseInt(octaves), parseInt(lhStartOctave));

  if (p === null) {
    // generate failed.
    alert("Not able to generate that arpeggio yet: try Major or Minor");
    return;
  }
  presets.push(p);
  var option = document.createElement('option');
  option.value = tmp;
  option.innerHTML = presets[tmp].name;
  option.style.fontSize = "16px";
  presetMenu.appendChild(option);
  option.selected = true;

  handlePresetSelection(tmp);

  dismissForm();
}

function populateTestNameOptions() {
    const testNameSelect = document.getElementById("testNameHistorySelect");
    testNameSelect.innerHTML = ""; // blank it out

    // add the "all" option
    const allopt = document.createElement("option");
    allopt.value = "all";
    allopt.textContent = " ALL";
    testNameSelect.appendChild(allopt);

    const testNames = Object.keys(runHistory);
    const seen = [];
    testNames.forEach((testName) => {
        const option = document.createElement("option");
        const [date, preset, hand] = testName.split("|");

        const decoded = decodeHTMLEntities(preset);
        if (typeof seen[preset] !== 'undefined') {
          return;
        }
        seen[preset] = true;
        option.value = preset;
        option.textContent = decoded;
        if (preset === curPresetName) {
          option.selected = true;
        }
        testNameSelect.appendChild(option);

        // also select current hand
        const h = getSelectedHand();
        const sel = document.getElementById("handSelect");
        sel.value = h;
    });

    sortSelectedOptions(testNameSelect);
}

function sortSelectedOptions(select) {
  // Get all options in the select element
  const options = Array.from(select.options);

  // Sort the options alphabetically by textContent
  options.sort((a, b) => {
    const textA = a.textContent.toUpperCase();
    const textB = b.textContent.toUpperCase();
    return textA.localeCompare(textB);
  });

  // Clear the select element
  select.innerHTML = '';

  // Append the sorted options back to the select element
  options.forEach((option) => {
    select.appendChild(option);
  });
}


function decodeHTMLEntities(html) {
  const textarea = document.createElement("textarea");
  textarea.innerHTML = html;
  return textarea.value;
}

// This function populates the history table with run data
function populateHistoryTable() {
    const historyTableBody = document.getElementById("historyTableBody");
    historyTableBody.innerHTML = ""; // Clear the table body

    if (runHistory === null) {
      // hasn't been read yet
      runHistory = localStorage.getItem("runHistory");

      if (runHistory === null) { // still null, wasn't stored
        runHistory = {};

        alert("There is no history to display");
      } else {
        if (runHistory === null) {
          runHistory = {};
        } else {
          // Parse 'runHistory' from JSON if it exists
          runHistory = JSON.parse(runHistory);
        }
      }
    }

    populateTestNameOptions();

    return;
}

// Function to filter and display history based on selected filters
function filterAndDisplayHistory() {
    const historyTableBody = document.getElementById("historyTableBody");
    historyTableBody.innerHTML = ""; // Clear the existing rows in the table

    const dateRange = document.getElementById("dateRangeSelect").value;
    const selectedTestName = document.getElementById("testNameHistorySelect").value;
    const selectedHand = document.getElementById("handSelect").value;

    // Initialize an object to store statistics for graphing
    const stats = {};

    let maxBPM = 0;
    let minBPM = 10000; // higher than humanly possible
    let firstMonth = '';
    let lastMonth = '';

    // Loop through the runHistory object and populate the table
    var totReps = 0;
    var totNfail = 0;
    var totElapsed = 0;
    for (const runName in runHistory) {
        const runData = runHistory[runName];
        const [date, preset, hand] = runName.split("|");

        // Date range filtering logic
        if (dateRange === "1Month" && !isWithinLastMonths(date, 1)) continue;
        if (dateRange === "3Months" && !isWithinLastMonths(date, 3)) continue;
        if (dateRange === "1Year" && !isWithinLastMonths(date, 12)) continue;

        // Test name filtering logic
        if (selectedTestName !== "all" && selectedTestName !== preset) continue;

        // Hand filtering logic
        if (selectedHand !== "any" && selectedHand !== hand) continue;

        const [year, month, day] = date.split('-');
        const datedisp = year + "-" + month;
        if (firstMonth === '') {
          firstMonth = date;
        }
        lastMonth = date; // this will keep overwriting until it is really the last one

        // Initialize the monthly statistics if not already done
        if (!stats[date]) {
            stats[date] = {
                avgBPM: 0,
                bestBPM: 0,
                maxBPM: 0
            };
        }

        // Update the monthly statistics
        stats[date].avgBPM = runData.sumBPM / (runData.success>0?runData.success:1);
        stats[date].bestBPM = runData.bestBPM;
        stats[date].maxBPM = runData.maxBPM;
        stats[date].notefail = Math.trunc(100*runData.notefail/(runData.success+runData.notefail+0.1));

        // Update maxBPM
        //console.log("avg="+stats[date].avgBPM+" best="+stats[date].bestBPM+" max="+stats[date].maxBPM);


        maxBPM = Math.max(
            maxBPM,
            stats[date].bestBPM,
            stats[date].maxBPM,
            stats[date].avgBPM
        );

        if (stats[date].bestBPM>0||stats[date].maxBPM>0||stats[date].avgBPM>0) {
          // only update if at least one of the above is over zero, this avoids pathological cases
          // where no reps were successful and so all the data would be zero.
          minBPM = Math.min(
              minBPM,
              stats[date].bestBPM,
              stats[date].maxBPM,
              stats[date].avgBPM
          );
        }

        const newRow = document.createElement("tr");
        var acc = "&nbsp;";
        if (typeof runData.goodNotes !== 'undefined' && runData.goodNotes !== null) {
          acc = (100*runData.goodNotes/Math.max(runData.goodNotes+runData.notefail,1)).toFixed(2);
          qrows += `<td>${acc}%</td>`;
        }

        var errmaplink = "";
        if (isAvail(runData.errorNotes)) {
          errmaplink = "<div onclick=showErrorMap('"+runName+"') onmouseover='this.style.backgroundColor=\"white\"' onmouseout='this.style.backgroundColor=\"rgb(238,238,238)\"' style=color:blue;>SHOW</span>";
        }
        var streaklink = "";
        if (isAvail(runData.maxStreak)) {
          streaklink = "<div onclick=showStreakData('"+runName+"') onmouseover='this.style.backgroundColor=\"white\"' onmouseout='this.style.backgroundColor=\"rgb(238,238,238)\"' style=color:blue;>SHOW</span>";
        }

        newRow.innerHTML = `
            <td>${date}</td>
            <td>${preset}</td>
            <td>${hand}</td>
            <td>${runData.success}</td>
            <td>${runData.notefail} (${Math.trunc(100*runData.notefail/(runData.count))}%)</td>
            <td>${(runData.elapsed/1000).toFixed(1)}</td>
            <td>${(runData.sumStrikes / runData.success).toFixed(2)}</td>
            <td>${acc}</td>
            <td>${errmaplink}</td>
            <td>${streaklink}</td>
            <td>${Math.trunc(runData.sumBPM / runData.success)}</td>
            <td>${runData.maxBPM}</td>
            <td>${runData.bestBPM}</td>

        `;

        totReps += runData.success;
        totNfail += runData.notefail;
        totElapsed += (runData.elapsed/1000);

        if (typeof runData.numQBPM !== 'undefined' && runData.numQBPM !== null) {
            var qrows = "";
            var sum = 0;
            for (var q = 0; q < 4; q++) {
              if (typeof runData.numQBPM[q] !== 'undefined' && runData.numQBPM[q] !== null) {
                sum += runData.numQBPM[q];
              } else {
                runData.numQBPM[q] = 0;
              }
            }
            if (sum === 0) sum = 1;  // avoid div by zero errors
            for (var q = 0; q < 4; q++) {
              console.log("ADDING QROW: q:"+q+" sum:"+sum+" rD[q]:"+runData.sumQBPM[q]+" n:"+runData.numQBPM[q]);
              qrows += `<td>${Math.trunc(100*runData.numQBPM[q]/sum)}%</td>`;
            }
            newRow.innerHTML += qrows;
        }

        historyTableBody.appendChild(newRow);
    }

    const sumRow = document.createElement("tr");

    sumRow.innerHTML += "<td colspan=3 style=text-align:left;font-weight:bold>TOTALS</td>" +
                        "<td style=text-align:left;font-weight:bold>"+totReps+"</td>" +
                        "<td style=text-align:left;font-weight:bold>"+totNfail+" ("+Math.trunc(100*totNfail/(totNfail+totReps))+"%)"+"</td>" +
                        "<td style=text-align:left;font-weight:bold>"+formatTime(totElapsed)+"</td>";
    historyTableBody.appendChild(sumRow);

    maxBPM = Math.ceil(maxBPM/20)*20;  // round nearest 20
    minBPM = Math.floor(minBPM/20)*20;  // round nearest 20

    // Call the graphing function with the required parameters
    if (selectedTestName !== "all" && selectedHand !== "any") {
      drawHistoryGraph(stats, firstMonth, lastMonth, maxBPM, minBPM);
    }
}


function drawHistoryGraph(stats, firstMonth, lastMonth, maxBPM, minBPM) {

  //console.log("In Drawhist fm="+firstMonth+" lm="+lastMonth+" maxbpm="+maxBPM);
  if (maxBPM === 0) {
    maxBPM = 1; // avoid div by 0 errors, the graph is pathologic in this case anyway.
  }
  // Get the canvas context
  const canvas = document.getElementById("historyGraph");
  const ctx = canvas.getContext("2d");

  // Set canvas dimensions from actual size as rendered in html
  const s = getComputedStyle(canvas);
  canvas.width = parseInt(s.width);
  canvas.height = parseInt(s.height);
  ctx.font = "10px Arial";

  // Set up colors and styles
  ctx.fillStyle = "#BBB"; // Background color
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.lineWidth = 2;
  ctx.strokeStyle = "white";
  ctx.fillStyle = "white";
  ctx.textAlign = "left";

  let [fyear,fmonth,fday] = firstMonth.split('-');
  if (fday >= 22) {
    fday = 22;
  } else if (fday >= 15) {
    fday = 15;
  } else if (fday >= 7) {
    fday = 7;
  } else {
    fday = "01";
  }
  let [lyear,lmonth,lday] = lastMonth.split('-');
  if (lday < 7) {
    lday = 7;
  } else if (lday < 15) {
    lday = 15;

  } else if (lday < 22) {
    lday = 22;
  } else if (lday <= 28) {
    if (lmonth === 2) {
      lday = 28;
    } else if (lmonth === 3 || lmonth === 4 || lmonth===6||lmonth===9||lmonth===11) {
      lday = 30;
    } else {
      lday = 31;
    }
  }

  console.log("graphhist: firstMonth="+firstMonth+" Adj lastmonth="+lastMonth);

  const firstday = dateToDaysSince1970(fyear+"-"+fmonth+"-"+fday);
  const lastday = dateToDaysSince1970(lyear+"-"+lmonth+"-"+lday);
  const totdays = lastday-firstday;

  console.log("Totdays="+totdays+" firsmonth="+firstMonth+" lastm="+lastMonth);

  const graphAxisHorizontalMargin = 55; // pixels to leave for axis and labels
  const graphAxisVerticalMargin = 25;

  const xScale = (canvas.width-2*graphAxisHorizontalMargin) / totdays;
  const yScale = (canvas.height-2*graphAxisVerticalMargin) / (maxBPM-minBPM);

  //console.log("xscale="+xScale);

  // Draw horizontal and vertical axes

  ctx.beginPath();
  ctx.moveTo(graphAxisHorizontalMargin, canvas.height-graphAxisVerticalMargin);
  ctx.lineTo(canvas.width-graphAxisHorizontalMargin, canvas.height-graphAxisVerticalMargin);
  ctx.moveTo(graphAxisHorizontalMargin, graphAxisVerticalMargin);
  ctx.lineTo(graphAxisHorizontalMargin, canvas.height-graphAxisVerticalMargin);
  ctx.stroke();

  ctx.lineWidth = 2;

  //console.log("Drawing history graph "+fyear+"."+fmonth+" "+lyear+"."+lmonth);

  // Draw labels on the horizontal axis
  for (let year = fyear, month = fmonth, day = fday;
       parseInt(year) <= parseInt(lyear) && parseInt(month) <= parseInt(lmonth) ;
       // there is no third part for the for loop, this is handled at the end of the loop
     ) {
    console.log("Drawing date axis m="+month+" d="+day+" y="+year);
    const x = graphAxisHorizontalMargin + (dateToDaysSince1970(year+'-'+month+'-'+day) - firstday)*xScale;
    console.log(" x="+x+" daystodate returned:"+dateToDaysSince1970(year+'-'+month+'-'+day)+" firstday="+firstday);

    ctx.fillText(year+'-'+month+'-'+day, x, canvas.height - graphAxisVerticalMargin/2); // Adjust label position

    //console.log("***label "+year+'-'+month+" at x="+x+" y="+(canvas.height-graphAxisVerticalMargin/2));

    ctx.moveTo(x, graphAxisVerticalMargin);
    ctx.lineTo(x, canvas.height-graphAxisVerticalMargin);
    ctx.stroke();

    // increment date by quarter-months (approximately)
    // IMPLEMENT: This really should be different amounts based on how long the total time span is.
    // For example, if the timespan is less than 15 days, this should go by just a few days. If the
    // timespan is 9 months, it should probably go by months. If 36 months, perhaps by quarters, etc.
    // there's room for about 8 labels at the bottom, so the increment should be something like
    // timespan/8 days, but with rounding to something reasonable like 1 week, 1 month, etc.

    if (day < 15) {
      day = 15;
    } else {
      day = "01";
      month++;
      if (month > 12) {
        month = "01";
        year++;
      }
    }
    console.log("Updated yyyy mm dd="+year+" "+month+" "+day+" last="+lyear+" "+lmonth+" "+lday);
  }
  // draw labels on the left vertical axis
  ctx.textAlign = "right";
  ctx.strokeStyle = "#444";
  ctx.lineWidth = "1";
  for (let bpm = minBPM; bpm <= maxBPM; bpm += 20) {
    const y = canvas.height - graphAxisVerticalMargin - (bpm-minBPM)*yScale;

    ctx.fillText(bpm+' ', graphAxisHorizontalMargin, y);

    ctx.moveTo(graphAxisHorizontalMargin, y);
    ctx.lineTo(canvas.width-graphAxisHorizontalMargin, y);
    ctx.stroke();
  }

  // draw labels on the right vertical axis
  ctx.textAlign = "left";
  ctx.strokeStyle = "#F00";
  ctx.fillStyle = "#F00";
  ctx.lineWidth = "1";
  let perYScale = (canvas.height-2*graphAxisVerticalMargin) / (100);
  for (let per = 10; per < 100; per += 10) {
    const y = canvas.height - graphAxisVerticalMargin - per*perYScale + 5;

    ctx.fillText(per+'% ', canvas.width-graphAxisHorizontalMargin+3, y);

    ctx.moveTo(graphAxisHorizontalMargin, y);
    ctx.lineTo(canvas.width-graphAxisHorizontalMargin, y);
  }

  // give color code
  ctx.font = "12px Arial";
  ctx.textAlign = "left";
  ctx.fillStyle = "#AAFF00";
  ctx.fillText("BestBPM", graphAxisVerticalMargin*2, graphAxisVerticalMargin/2);
  ctx.fillStyle = "#0096FF";
  ctx.fillText("AvgBPM", graphAxisVerticalMargin*5, graphAxisVerticalMargin/2);
  ctx.fillStyle = "#BF40BF";
  ctx.fillText("MaxBPM", graphAxisVerticalMargin*8, graphAxisVerticalMargin/2);
  ctx.fillStyle = "#FF0000";
  ctx.fillText("NoteFail", graphAxisVerticalMargin*13, graphAxisVerticalMargin/2);

  // Plot lines for Average BPM (blue), Best BPM (green), and Max BPM (purple)
  const colors = ["#0096FF", "#AAFF00", "#BF40BF"];
  const dataKeys = ["avgBPM", "bestBPM", "maxBPM"];

  ctx.lineWidth = "3";

  for (let i = 0; i < dataKeys.length; i++) {
    ctx.strokeStyle = colors[i];
    ctx.beginPath();

    let firstkey = true;
    for (const key in stats) {
      if (stats.hasOwnProperty(key)) {
          if (stats[key][dataKeys[i]] === 0) {
            continue; // don't graph 0 bpm data points, they represent a lack of data not actual data
          }
          const x = graphAxisHorizontalMargin + (dateToDaysSince1970(key) - firstday) * xScale + 2*i;
          const y = canvas.height - graphAxisVerticalMargin - (stats[key][dataKeys[i]]-minBPM) * yScale;
          if (firstkey) {
            ctx.moveTo(x, y);
            firstkey = false;
          } else {
            ctx.lineTo(x, y);
          }
      }
    }

    ctx.stroke();

    for (const key in stats) {
      if (stats.hasOwnProperty(key)) {
          if (stats[key][dataKeys[i]] === 0) {
            continue; // don't graph 0 bpm data points, they represent a lack of data not actual data
          }
          const x = graphAxisHorizontalMargin + (dateToDaysSince1970(key) - firstday) * xScale + 2*i;
          const y = canvas.height - graphAxisVerticalMargin - (stats[key][dataKeys[i]]-minBPM) * yScale;
          ctx.fillStyle = colors[i];
          ctx.beginPath();
          ctx.moveTo(x, y - 4); // Move to the top point
          ctx.lineTo(x + 4, y); // Line to the right point
          ctx.lineTo(x, y + 4); // Line to the bottom point
          ctx.lineTo(x - 4, y); // Line to the left point
          ctx.closePath(); // Close the path to complete the diamond
          ctx.fill(); // Fill the diamond
      }
    }
  }

  // draw the notefail data

  var first = true;
  ctx.strokeStyle = "rgba(255,0,0,0.5)";
  ctx.setLineDash([4,4]);
  ctx.lineDashOffset = 0;
  ctx.beginPath();

  for (const date in stats) {
    if (!stats.hasOwnProperty(date)) {
      continue;
    }
    const x = graphAxisHorizontalMargin + (dateToDaysSince1970(date) - firstday) * xScale;
    const y = canvas.height - graphAxisVerticalMargin - (stats[date].notefail) * perYScale;

    //console.log("Drawing nfail at x="+x+" y="+y+" val="+stats[date].notefail);

    if (first) {
      ctx.moveTo(x, y);
      first = false;
    } else {
      ctx.lineTo(x, y);
    }
  }
  ctx.stroke();
  ctx.setLineDash([]);

  ctx.fillStyle = "rgba(255,0,0,0.5)";

  for (const date in stats) {
    if (!stats.hasOwnProperty(date)) {
      continue;
    }
    const x = graphAxisHorizontalMargin + (dateToDaysSince1970(date) - firstday) * xScale;
    const y = canvas.height - graphAxisVerticalMargin - (stats[date].notefail) * perYScale;
     ctx.beginPath();
     ctx.moveTo(x, y - 4); // Move to the top point
     ctx.lineTo(x + 4, y); // Line to the right point
     ctx.lineTo(x, y + 4); // Line to the bottom point
     ctx.lineTo(x - 4, y); // Line to the left point
     ctx.closePath(); // Close the path to complete the diamond
     ctx.fill(); // Fill the diamond
  }

}


// Function to check if a date is within the last 'n' months
function isWithinLastMonths(dateString, n) {
    const currentDate = new Date();
    const date = new Date(dateString);
    const diff = currentDate - date;
    const monthDiff = diff / (1000 * 60 * 60 * 24 * 30.44); // Approximate average days in a month

    return monthDiff <= n;
}

// Event listener for the "History" button
const historyButton = document.getElementById("historyButton");
const historyTableContainer = document.getElementById("historyTableContainer");

historyButton.addEventListener("click", function() {
    populateHistoryTable();
    historyTableContainer.style.display = "block";
    setTimeout(function() {
      filterAndDisplayHistory();
    }, 1000);
});

function dateToDaysSince1970(dateString) {
    const parts = dateString.split('-');
    if (parts.length === 2) {
      parts[2] = 1;
      console.log("auto added 01 day to date");
    } else if (parts.length !== 3) {
        throw new Error("Invalid date format. '"+dateString+"' Use yyyy-mm-dd.");
    }

    const year = parseInt(parts[0], 10);
    const month = parseInt(parts[1], 10) - 1; // Months are 0-indexed in JavaScript
    const day = parseInt(parts[2], 10);

    const inputDate = new Date(year, month, day);
    const januaryFirst1970 = new Date(1970, 0, 1); // January is month 0

    // Calculate the difference in milliseconds and convert to days
    const daysDifference = Math.floor((inputDate - januaryFirst1970) / (24 * 60 * 60 * 1000));

    return daysDifference;
}

function showHistory() {
  document.getElementById('importExportContainer').style.display='block';
  const hist = JSON.stringify(runHistory);
  document.getElementById('importExportTextarea').value = hist;
  document.getElementById('importExportSizeDiv').innerHTML = "Bytes: "+hist.length;

  setTimeout(function() {
    document.getElementById("historyGraph").scrollIntoView({ behavior: "smooth", block: "end" });
  }, 1200);

}

function playGraph() {

  console.log("playing midi notes from graph");

  if (midiNotes === null || midiNotes.length === 0) {
    warning("There are no notes to play.");
    return;
  }

 document.getElementById("svgPlayButton").style.fill = "red";

 setTimeout(function() {
    document.getElementById("svgPlayButton").style.fill = "black";
 }, 1000);

 for (let i = 0; i < midiNotes.length; i++) {
   warning("MidiNote["+i+"]="+midiNotes[i].name+
    ":"+midiNotes[i].options.time+
    ":"+midiNotes[i].options.duration+
    ":"+midiNotes[i].options.attack);
 }

 midiOutput.channels[1].sendProgramChange(0); // grand piano
 for (let i = 0; i < midiNotes.length; i++) {
    midiOutput.channels[1].playNote(midiNotes[i], midiNotes[i].options);
 }


}

</script>
</body>
</html>
